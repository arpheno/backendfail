<html>
<head>
    <meta charset="UTF-8">
    <script>/**
     * @license
     * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
     */
// @version 0.7.15
    (function () {
        window.WebComponents = window.WebComponents || {
                    flags: {}
                };
        var file = "webcomponents.js";
        var script = document.querySelector('script[src*="' + file + '"]');
        var flags = {};
        if (!flags.noOpts) {
            location.search.slice(1).split("&").forEach(function (option) {
                var parts = option.split("=");
                var match;
                if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {
                    flags[match[1]] = parts[1] || true;
                }
            });
            if (script) {
                for (var i = 0, a; a = script.attributes[i]; i++) {
                    if (a.name !== "src") {
                        flags[a.name] = a.value || true;
                    }
                }
            }
            if (flags.log && flags.log.split) {
                var parts = flags.log.split(",");
                flags.log = {};
                parts.forEach(function (f) {
                    flags.log[f] = true;
                });
            } else {
                flags.log = {};
            }
        }
        flags.shadow = flags.shadow || flags.shadowdom || flags.polyfill;
        if (flags.shadow === "native") {
            flags.shadow = false;
        } else {
            flags.shadow = flags.shadow || !HTMLElement.prototype.createShadowRoot;
        }
        if (flags.register) {
            window.CustomElements = window.CustomElements || {
                        flags: {}
                    };
            window.CustomElements.flags.register = flags.register;
        }
        WebComponents.flags = flags;
    })();

    if (WebComponents.flags.shadow) {
        if (typeof WeakMap === "undefined") {
            (function () {
                var defineProperty = Object.defineProperty;
                var counter = Date.now() % 1e9;
                var WeakMap = function () {
                    this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
                };
                WeakMap.prototype = {
                    set: function (key, value) {
                        var entry = key[this.name];
                        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
                            value: [key, value],
                            writable: true
                        });
                        return this;
                    },
                    get: function (key) {
                        var entry;
                        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
                    },
                    "delete": function (key) {
                        var entry = key[this.name];
                        if (!entry || entry[0] !== key) return false;
                        entry[0] = entry[1] = undefined;
                        return true;
                    },
                    has: function (key) {
                        var entry = key[this.name];
                        if (!entry) return false;
                        return entry[0] === key;
                    }
                };
                window.WeakMap = WeakMap;
            })();
        }
        window.ShadowDOMPolyfill = {};
        (function (scope) {
            "use strict";
            var constructorTable = new WeakMap();
            var nativePrototypeTable = new WeakMap();
            var wrappers = Object.create(null);

            function detectEval() {
                if (typeof chrome !== "undefined" && chrome.app && chrome.app.runtime) {
                    return false;
                }
                if (navigator.getDeviceStorage) {
                    return false;
                }
                try {
                    var f = new Function("return true;");
                    return f();
                } catch (ex) {
                    return false;
                }
            }

            var hasEval = detectEval();

            function assert(b) {
                if (!b) throw new Error("Assertion failed");
            }

            var defineProperty = Object.defineProperty;
            var getOwnPropertyNames = Object.getOwnPropertyNames;
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

            function mixin(to, from) {
                var names = getOwnPropertyNames(from);
                for (var i = 0; i < names.length; i++) {
                    var name = names[i];
                    defineProperty(to, name, getOwnPropertyDescriptor(from, name));
                }
                return to;
            }

            function mixinStatics(to, from) {
                var names = getOwnPropertyNames(from);
                for (var i = 0; i < names.length; i++) {
                    var name = names[i];
                    switch (name) {
                        case "arguments":
                        case "caller":
                        case "length":
                        case "name":
                        case "prototype":
                        case "toString":
                            continue;
                    }
                    defineProperty(to, name, getOwnPropertyDescriptor(from, name));
                }
                return to;
            }

            function oneOf(object, propertyNames) {
                for (var i = 0; i < propertyNames.length; i++) {
                    if (propertyNames[i] in object) return propertyNames[i];
                }
            }

            var nonEnumerableDataDescriptor = {
                value: undefined,
                configurable: true,
                enumerable: false,
                writable: true
            };

            function defineNonEnumerableDataProperty(object, name, value) {
                nonEnumerableDataDescriptor.value = value;
                defineProperty(object, name, nonEnumerableDataDescriptor);
            }

            getOwnPropertyNames(window);
            function getWrapperConstructor(node, opt_instance) {
                var nativePrototype = node.__proto__ || Object.getPrototypeOf(node);
                if (isFirefox) {
                    try {
                        getOwnPropertyNames(nativePrototype);
                    } catch (error) {
                        nativePrototype = nativePrototype.__proto__;
                    }
                }
                var wrapperConstructor = constructorTable.get(nativePrototype);
                if (wrapperConstructor) return wrapperConstructor;
                var parentWrapperConstructor = getWrapperConstructor(nativePrototype);
                var GeneratedWrapper = createWrapperConstructor(parentWrapperConstructor);
                registerInternal(nativePrototype, GeneratedWrapper, opt_instance);
                return GeneratedWrapper;
            }

            function addForwardingProperties(nativePrototype, wrapperPrototype) {
                installProperty(nativePrototype, wrapperPrototype, true);
            }

            function registerInstanceProperties(wrapperPrototype, instanceObject) {
                installProperty(instanceObject, wrapperPrototype, false);
            }

            var isFirefox = /Firefox/.test(navigator.userAgent);
            var dummyDescriptor = {
                get: function () {
                },
                set: function (v) {
                },
                configurable: true,
                enumerable: true
            };

            function isEventHandlerName(name) {
                return /^on[a-z]+$/.test(name);
            }

            function isIdentifierName(name) {
                return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name);
            }

            function getGetter(name) {
                return hasEval && isIdentifierName(name) ? new Function("return this.__impl4cf1e782hg__." + name) : function () {
                    return this.__impl4cf1e782hg__[name];
                };
            }

            function getSetter(name) {
                return hasEval && isIdentifierName(name) ? new Function("v", "this.__impl4cf1e782hg__." + name + " = v") : function (v) {
                    this.__impl4cf1e782hg__[name] = v;
                };
            }

            function getMethod(name) {
                return hasEval && isIdentifierName(name) ? new Function("return this.__impl4cf1e782hg__." + name + ".apply(this.__impl4cf1e782hg__, arguments)") : function () {
                    return this.__impl4cf1e782hg__[name].apply(this.__impl4cf1e782hg__, arguments);
                };
            }

            function getDescriptor(source, name) {
                try {
                    return Object.getOwnPropertyDescriptor(source, name);
                } catch (ex) {
                    return dummyDescriptor;
                }
            }

            var isBrokenSafari = function () {
                var descr = Object.getOwnPropertyDescriptor(Node.prototype, "nodeType");
                return descr && !descr.get && !descr.set;
            }();

            function installProperty(source, target, allowMethod, opt_blacklist) {
                var names = getOwnPropertyNames(source);
                for (var i = 0; i < names.length; i++) {
                    var name = names[i];
                    if (name === "polymerBlackList_") continue;
                    if (name in target) continue;
                    if (source.polymerBlackList_ && source.polymerBlackList_[name]) continue;
                    if (isFirefox) {
                        source.__lookupGetter__(name);
                    }
                    var descriptor = getDescriptor(source, name);
                    var getter, setter;
                    if (typeof descriptor.value === "function") {
                        if (allowMethod) {
                            target[name] = getMethod(name);
                        }
                        continue;
                    }
                    var isEvent = isEventHandlerName(name);
                    if (isEvent) getter = scope.getEventHandlerGetter(name); else getter = getGetter(name);
                    if (descriptor.writable || descriptor.set || isBrokenSafari) {
                        if (isEvent) setter = scope.getEventHandlerSetter(name); else setter = getSetter(name);
                    }
                    var configurable = isBrokenSafari || descriptor.configurable;
                    defineProperty(target, name, {
                        get: getter,
                        set: setter,
                        configurable: configurable,
                        enumerable: descriptor.enumerable
                    });
                }
            }

            function register(nativeConstructor, wrapperConstructor, opt_instance) {
                if (nativeConstructor == null) {
                    return;
                }
                var nativePrototype = nativeConstructor.prototype;
                registerInternal(nativePrototype, wrapperConstructor, opt_instance);
                mixinStatics(wrapperConstructor, nativeConstructor);
            }

            function registerInternal(nativePrototype, wrapperConstructor, opt_instance) {
                var wrapperPrototype = wrapperConstructor.prototype;
                assert(constructorTable.get(nativePrototype) === undefined);
                constructorTable.set(nativePrototype, wrapperConstructor);
                nativePrototypeTable.set(wrapperPrototype, nativePrototype);
                addForwardingProperties(nativePrototype, wrapperPrototype);
                if (opt_instance) registerInstanceProperties(wrapperPrototype, opt_instance);
                defineNonEnumerableDataProperty(wrapperPrototype, "constructor", wrapperConstructor);
                wrapperConstructor.prototype = wrapperPrototype;
            }

            function isWrapperFor(wrapperConstructor, nativeConstructor) {
                return constructorTable.get(nativeConstructor.prototype) === wrapperConstructor;
            }

            function registerObject(object) {
                var nativePrototype = Object.getPrototypeOf(object);
                var superWrapperConstructor = getWrapperConstructor(nativePrototype);
                var GeneratedWrapper = createWrapperConstructor(superWrapperConstructor);
                registerInternal(nativePrototype, GeneratedWrapper, object);
                return GeneratedWrapper;
            }

            function createWrapperConstructor(superWrapperConstructor) {
                function GeneratedWrapper(node) {
                    superWrapperConstructor.call(this, node);
                }

                var p = Object.create(superWrapperConstructor.prototype);
                p.constructor = GeneratedWrapper;
                GeneratedWrapper.prototype = p;
                return GeneratedWrapper;
            }

            function isWrapper(object) {
                return object && object.__impl4cf1e782hg__;
            }

            function isNative(object) {
                return !isWrapper(object);
            }

            function wrap(impl) {
                if (impl === null) return null;
                assert(isNative(impl));
                var wrapper = impl.__wrapper8e3dd93a60__;
                if (wrapper != null) {
                    return wrapper;
                }
                return impl.__wrapper8e3dd93a60__ = new (getWrapperConstructor(impl, impl))(impl);
            }

            function unwrap(wrapper) {
                if (wrapper === null) return null;
                assert(isWrapper(wrapper));
                return wrapper.__impl4cf1e782hg__;
            }

            function unsafeUnwrap(wrapper) {
                return wrapper.__impl4cf1e782hg__;
            }

            function setWrapper(impl, wrapper) {
                wrapper.__impl4cf1e782hg__ = impl;
                impl.__wrapper8e3dd93a60__ = wrapper;
            }

            function unwrapIfNeeded(object) {
                return object && isWrapper(object) ? unwrap(object) : object;
            }

            function wrapIfNeeded(object) {
                return object && !isWrapper(object) ? wrap(object) : object;
            }

            function rewrap(node, wrapper) {
                if (wrapper === null) return;
                assert(isNative(node));
                assert(wrapper === undefined || isWrapper(wrapper));
                node.__wrapper8e3dd93a60__ = wrapper;
            }

            var getterDescriptor = {
                get: undefined,
                configurable: true,
                enumerable: true
            };

            function defineGetter(constructor, name, getter) {
                getterDescriptor.get = getter;
                defineProperty(constructor.prototype, name, getterDescriptor);
            }

            function defineWrapGetter(constructor, name) {
                defineGetter(constructor, name, function () {
                    return wrap(this.__impl4cf1e782hg__[name]);
                });
            }

            function forwardMethodsToWrapper(constructors, names) {
                constructors.forEach(function (constructor) {
                    names.forEach(function (name) {
                        constructor.prototype[name] = function () {
                            var w = wrapIfNeeded(this);
                            return w[name].apply(w, arguments);
                        };
                    });
                });
            }

            scope.assert = assert;
            scope.constructorTable = constructorTable;
            scope.defineGetter = defineGetter;
            scope.defineWrapGetter = defineWrapGetter;
            scope.forwardMethodsToWrapper = forwardMethodsToWrapper;
            scope.isIdentifierName = isIdentifierName;
            scope.isWrapper = isWrapper;
            scope.isWrapperFor = isWrapperFor;
            scope.mixin = mixin;
            scope.nativePrototypeTable = nativePrototypeTable;
            scope.oneOf = oneOf;
            scope.registerObject = registerObject;
            scope.registerWrapper = register;
            scope.rewrap = rewrap;
            scope.setWrapper = setWrapper;
            scope.unsafeUnwrap = unsafeUnwrap;
            scope.unwrap = unwrap;
            scope.unwrapIfNeeded = unwrapIfNeeded;
            scope.wrap = wrap;
            scope.wrapIfNeeded = wrapIfNeeded;
            scope.wrappers = wrappers;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            function newSplice(index, removed, addedCount) {
                return {
                    index: index,
                    removed: removed,
                    addedCount: addedCount
                };
            }

            var EDIT_LEAVE = 0;
            var EDIT_UPDATE = 1;
            var EDIT_ADD = 2;
            var EDIT_DELETE = 3;

            function ArraySplice() {
            }

            ArraySplice.prototype = {
                calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
                    var rowCount = oldEnd - oldStart + 1;
                    var columnCount = currentEnd - currentStart + 1;
                    var distances = new Array(rowCount);
                    for (var i = 0; i < rowCount; i++) {
                        distances[i] = new Array(columnCount);
                        distances[i][0] = i;
                    }
                    for (var j = 0; j < columnCount; j++) distances[0][j] = j;
                    for (var i = 1; i < rowCount; i++) {
                        for (var j = 1; j < columnCount; j++) {
                            if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1]; else {
                                var north = distances[i - 1][j] + 1;
                                var west = distances[i][j - 1] + 1;
                                distances[i][j] = north < west ? north : west;
                            }
                        }
                    }
                    return distances;
                },
                spliceOperationsFromEditDistances: function (distances) {
                    var i = distances.length - 1;
                    var j = distances[0].length - 1;
                    var current = distances[i][j];
                    var edits = [];
                    while (i > 0 || j > 0) {
                        if (i == 0) {
                            edits.push(EDIT_ADD);
                            j--;
                            continue;
                        }
                        if (j == 0) {
                            edits.push(EDIT_DELETE);
                            i--;
                            continue;
                        }
                        var northWest = distances[i - 1][j - 1];
                        var west = distances[i - 1][j];
                        var north = distances[i][j - 1];
                        var min;
                        if (west < north) min = west < northWest ? west : northWest; else min = north < northWest ? north : northWest;
                        if (min == northWest) {
                            if (northWest == current) {
                                edits.push(EDIT_LEAVE);
                            } else {
                                edits.push(EDIT_UPDATE);
                                current = northWest;
                            }
                            i--;
                            j--;
                        } else if (min == west) {
                            edits.push(EDIT_DELETE);
                            i--;
                            current = west;
                        } else {
                            edits.push(EDIT_ADD);
                            j--;
                            current = north;
                        }
                    }
                    edits.reverse();
                    return edits;
                },
                calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
                    var prefixCount = 0;
                    var suffixCount = 0;
                    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
                    if (currentStart == 0 && oldStart == 0) prefixCount = this.sharedPrefix(current, old, minLength);
                    if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
                    currentStart += prefixCount;
                    oldStart += prefixCount;
                    currentEnd -= suffixCount;
                    oldEnd -= suffixCount;
                    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];
                    if (currentStart == currentEnd) {
                        var splice = newSplice(currentStart, [], 0);
                        while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);
                        return [splice];
                    } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];
                    var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
                    var splice = undefined;
                    var splices = [];
                    var index = currentStart;
                    var oldIndex = oldStart;
                    for (var i = 0; i < ops.length; i++) {
                        switch (ops[i]) {
                            case EDIT_LEAVE:
                                if (splice) {
                                    splices.push(splice);
                                    splice = undefined;
                                }
                                index++;
                                oldIndex++;
                                break;

                            case EDIT_UPDATE:
                                if (!splice) splice = newSplice(index, [], 0);
                                splice.addedCount++;
                                index++;
                                splice.removed.push(old[oldIndex]);
                                oldIndex++;
                                break;

                            case EDIT_ADD:
                                if (!splice) splice = newSplice(index, [], 0);
                                splice.addedCount++;
                                index++;
                                break;

                            case EDIT_DELETE:
                                if (!splice) splice = newSplice(index, [], 0);
                                splice.removed.push(old[oldIndex]);
                                oldIndex++;
                                break;
                        }
                    }
                    if (splice) {
                        splices.push(splice);
                    }
                    return splices;
                },
                sharedPrefix: function (current, old, searchLength) {
                    for (var i = 0; i < searchLength; i++) if (!this.equals(current[i], old[i])) return i;
                    return searchLength;
                },
                sharedSuffix: function (current, old, searchLength) {
                    var index1 = current.length;
                    var index2 = old.length;
                    var count = 0;
                    while (count < searchLength && this.equals(current[--index1], old[--index2])) count++;
                    return count;
                },
                calculateSplices: function (current, previous) {
                    return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
                },
                equals: function (currentValue, previousValue) {
                    return currentValue === previousValue;
                }
            };
            scope.ArraySplice = ArraySplice;
        })(window.ShadowDOMPolyfill);
        (function (context) {
            "use strict";
            var OriginalMutationObserver = window.MutationObserver;
            var callbacks = [];
            var pending = false;
            var timerFunc;

            function handle() {
                pending = false;
                var copies = callbacks.slice(0);
                callbacks = [];
                for (var i = 0; i < copies.length; i++) {
                    (0, copies[i])();
                }
            }

            if (OriginalMutationObserver) {
                var counter = 1;
                var observer = new OriginalMutationObserver(handle);
                var textNode = document.createTextNode(counter);
                observer.observe(textNode, {
                    characterData: true
                });
                timerFunc = function () {
                    counter = (counter + 1) % 2;
                    textNode.data = counter;
                };
            } else {
                timerFunc = window.setTimeout;
            }
            function setEndOfMicrotask(func) {
                callbacks.push(func);
                if (pending) return;
                pending = true;
                timerFunc(handle, 0);
            }

            context.setEndOfMicrotask = setEndOfMicrotask;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var setEndOfMicrotask = scope.setEndOfMicrotask;
            var wrapIfNeeded = scope.wrapIfNeeded;
            var wrappers = scope.wrappers;
            var registrationsTable = new WeakMap();
            var globalMutationObservers = [];
            var isScheduled = false;

            function scheduleCallback(observer) {
                if (observer.scheduled_) return;
                observer.scheduled_ = true;
                globalMutationObservers.push(observer);
                if (isScheduled) return;
                setEndOfMicrotask(notifyObservers);
                isScheduled = true;
            }

            function notifyObservers() {
                isScheduled = false;
                while (globalMutationObservers.length) {
                    var notifyList = globalMutationObservers;
                    globalMutationObservers = [];
                    notifyList.sort(function (x, y) {
                        return x.uid_ - y.uid_;
                    });
                    for (var i = 0; i < notifyList.length; i++) {
                        var mo = notifyList[i];
                        mo.scheduled_ = false;
                        var queue = mo.takeRecords();
                        removeTransientObserversFor(mo);
                        if (queue.length) {
                            mo.callback_(queue, mo);
                        }
                    }
                }
            }

            function MutationRecord(type, target) {
                this.type = type;
                this.target = target;
                this.addedNodes = new wrappers.NodeList();
                this.removedNodes = new wrappers.NodeList();
                this.previousSibling = null;
                this.nextSibling = null;
                this.attributeName = null;
                this.attributeNamespace = null;
                this.oldValue = null;
            }

            function registerTransientObservers(ancestor, node) {
                for (; ancestor; ancestor = ancestor.parentNode) {
                    var registrations = registrationsTable.get(ancestor);
                    if (!registrations) continue;
                    for (var i = 0; i < registrations.length; i++) {
                        var registration = registrations[i];
                        if (registration.options.subtree) registration.addTransientObserver(node);
                    }
                }
            }

            function removeTransientObserversFor(observer) {
                for (var i = 0; i < observer.nodes_.length; i++) {
                    var node = observer.nodes_[i];
                    var registrations = registrationsTable.get(node);
                    if (!registrations) return;
                    for (var j = 0; j < registrations.length; j++) {
                        var registration = registrations[j];
                        if (registration.observer === observer) registration.removeTransientObservers();
                    }
                }
            }

            function enqueueMutation(target, type, data) {
                var interestedObservers = Object.create(null);
                var associatedStrings = Object.create(null);
                for (var node = target; node; node = node.parentNode) {
                    var registrations = registrationsTable.get(node);
                    if (!registrations) continue;
                    for (var j = 0; j < registrations.length; j++) {
                        var registration = registrations[j];
                        var options = registration.options;
                        if (node !== target && !options.subtree) continue;
                        if (type === "attributes" && !options.attributes) continue;
                        if (type === "attributes" && options.attributeFilter && (data.namespace !== null || options.attributeFilter.indexOf(data.name) === -1)) {
                            continue;
                        }
                        if (type === "characterData" && !options.characterData) continue;
                        if (type === "childList" && !options.childList) continue;
                        var observer = registration.observer;
                        interestedObservers[observer.uid_] = observer;
                        if (type === "attributes" && options.attributeOldValue || type === "characterData" && options.characterDataOldValue) {
                            associatedStrings[observer.uid_] = data.oldValue;
                        }
                    }
                }
                for (var uid in interestedObservers) {
                    var observer = interestedObservers[uid];
                    var record = new MutationRecord(type, target);
                    if ("name" in data && "namespace" in data) {
                        record.attributeName = data.name;
                        record.attributeNamespace = data.namespace;
                    }
                    if (data.addedNodes) record.addedNodes = data.addedNodes;
                    if (data.removedNodes) record.removedNodes = data.removedNodes;
                    if (data.previousSibling) record.previousSibling = data.previousSibling;
                    if (data.nextSibling) record.nextSibling = data.nextSibling;
                    if (associatedStrings[uid] !== undefined) record.oldValue = associatedStrings[uid];
                    scheduleCallback(observer);
                    observer.records_.push(record);
                }
            }

            var slice = Array.prototype.slice;

            function MutationObserverOptions(options) {
                this.childList = !!options.childList;
                this.subtree = !!options.subtree;
                if (!("attributes" in options) && ("attributeOldValue" in options || "attributeFilter" in options)) {
                    this.attributes = true;
                } else {
                    this.attributes = !!options.attributes;
                }
                if ("characterDataOldValue" in options && !("characterData" in options)) this.characterData = true; else this.characterData = !!options.characterData;
                if (!this.attributes && (options.attributeOldValue || "attributeFilter" in options) || !this.characterData && options.characterDataOldValue) {
                    throw new TypeError();
                }
                this.characterData = !!options.characterData;
                this.attributeOldValue = !!options.attributeOldValue;
                this.characterDataOldValue = !!options.characterDataOldValue;
                if ("attributeFilter" in options) {
                    if (options.attributeFilter == null || typeof options.attributeFilter !== "object") {
                        throw new TypeError();
                    }
                    this.attributeFilter = slice.call(options.attributeFilter);
                } else {
                    this.attributeFilter = null;
                }
            }

            var uidCounter = 0;

            function MutationObserver(callback) {
                this.callback_ = callback;
                this.nodes_ = [];
                this.records_ = [];
                this.uid_ = ++uidCounter;
                this.scheduled_ = false;
            }

            MutationObserver.prototype = {
                constructor: MutationObserver,
                observe: function (target, options) {
                    target = wrapIfNeeded(target);
                    var newOptions = new MutationObserverOptions(options);
                    var registration;
                    var registrations = registrationsTable.get(target);
                    if (!registrations) registrationsTable.set(target, registrations = []);
                    for (var i = 0; i < registrations.length; i++) {
                        if (registrations[i].observer === this) {
                            registration = registrations[i];
                            registration.removeTransientObservers();
                            registration.options = newOptions;
                        }
                    }
                    if (!registration) {
                        registration = new Registration(this, target, newOptions);
                        registrations.push(registration);
                        this.nodes_.push(target);
                    }
                },
                disconnect: function () {
                    this.nodes_.forEach(function (node) {
                        var registrations = registrationsTable.get(node);
                        for (var i = 0; i < registrations.length; i++) {
                            var registration = registrations[i];
                            if (registration.observer === this) {
                                registrations.splice(i, 1);
                                break;
                            }
                        }
                    }, this);
                    this.records_ = [];
                },
                takeRecords: function () {
                    var copyOfRecords = this.records_;
                    this.records_ = [];
                    return copyOfRecords;
                }
            };
            function Registration(observer, target, options) {
                this.observer = observer;
                this.target = target;
                this.options = options;
                this.transientObservedNodes = [];
            }

            Registration.prototype = {
                addTransientObserver: function (node) {
                    if (node === this.target) return;
                    scheduleCallback(this.observer);
                    this.transientObservedNodes.push(node);
                    var registrations = registrationsTable.get(node);
                    if (!registrations) registrationsTable.set(node, registrations = []);
                    registrations.push(this);
                },
                removeTransientObservers: function () {
                    var transientObservedNodes = this.transientObservedNodes;
                    this.transientObservedNodes = [];
                    for (var i = 0; i < transientObservedNodes.length; i++) {
                        var node = transientObservedNodes[i];
                        var registrations = registrationsTable.get(node);
                        for (var j = 0; j < registrations.length; j++) {
                            if (registrations[j] === this) {
                                registrations.splice(j, 1);
                                break;
                            }
                        }
                    }
                }
            };
            scope.enqueueMutation = enqueueMutation;
            scope.registerTransientObservers = registerTransientObservers;
            scope.wrappers.MutationObserver = MutationObserver;
            scope.wrappers.MutationRecord = MutationRecord;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            function TreeScope(root, parent) {
                this.root = root;
                this.parent = parent;
            }

            TreeScope.prototype = {
                get renderer() {
                    if (this.root instanceof scope.wrappers.ShadowRoot) {
                        return scope.getRendererForHost(this.root.host);
                    }
                    return null;
                },
                contains: function (treeScope) {
                    for (; treeScope; treeScope = treeScope.parent) {
                        if (treeScope === this) return true;
                    }
                    return false;
                }
            };
            function setTreeScope(node, treeScope) {
                if (node.treeScope_ !== treeScope) {
                    node.treeScope_ = treeScope;
                    for (var sr = node.shadowRoot; sr; sr = sr.olderShadowRoot) {
                        sr.treeScope_.parent = treeScope;
                    }
                    for (var child = node.firstChild; child; child = child.nextSibling) {
                        setTreeScope(child, treeScope);
                    }
                }
            }

            function getTreeScope(node) {
                if (node instanceof scope.wrappers.Window) {
                    debugger;
                }
                if (node.treeScope_) return node.treeScope_;
                var parent = node.parentNode;
                var treeScope;
                if (parent) treeScope = getTreeScope(parent); else treeScope = new TreeScope(node, null);
                return node.treeScope_ = treeScope;
            }

            scope.TreeScope = TreeScope;
            scope.getTreeScope = getTreeScope;
            scope.setTreeScope = setTreeScope;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;
            var getTreeScope = scope.getTreeScope;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var setWrapper = scope.setWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var unwrap = scope.unwrap;
            var wrap = scope.wrap;
            var wrappers = scope.wrappers;
            var wrappedFuns = new WeakMap();
            var listenersTable = new WeakMap();
            var handledEventsTable = new WeakMap();
            var currentlyDispatchingEvents = new WeakMap();
            var targetTable = new WeakMap();
            var currentTargetTable = new WeakMap();
            var relatedTargetTable = new WeakMap();
            var eventPhaseTable = new WeakMap();
            var stopPropagationTable = new WeakMap();
            var stopImmediatePropagationTable = new WeakMap();
            var eventHandlersTable = new WeakMap();
            var eventPathTable = new WeakMap();

            function isShadowRoot(node) {
                return node instanceof wrappers.ShadowRoot;
            }

            function rootOfNode(node) {
                return getTreeScope(node).root;
            }

            function getEventPath(node, event) {
                var path = [];
                var current = node;
                path.push(current);
                while (current) {
                    var destinationInsertionPoints = getDestinationInsertionPoints(current);
                    if (destinationInsertionPoints && destinationInsertionPoints.length > 0) {
                        for (var i = 0; i < destinationInsertionPoints.length; i++) {
                            var insertionPoint = destinationInsertionPoints[i];
                            if (isShadowInsertionPoint(insertionPoint)) {
                                var shadowRoot = rootOfNode(insertionPoint);
                                var olderShadowRoot = shadowRoot.olderShadowRoot;
                                if (olderShadowRoot) path.push(olderShadowRoot);
                            }
                            path.push(insertionPoint);
                        }
                        current = destinationInsertionPoints[destinationInsertionPoints.length - 1];
                    } else {
                        if (isShadowRoot(current)) {
                            if (inSameTree(node, current) && eventMustBeStopped(event)) {
                                break;
                            }
                            current = current.host;
                            path.push(current);
                        } else {
                            current = current.parentNode;
                            if (current) path.push(current);
                        }
                    }
                }
                return path;
            }

            function eventMustBeStopped(event) {
                if (!event) return false;
                switch (event.type) {
                    case "abort":
                    case "error":
                    case "select":
                    case "change":
                    case "load":
                    case "reset":
                    case "resize":
                    case "scroll":
                    case "selectstart":
                        return true;
                }
                return false;
            }

            function isShadowInsertionPoint(node) {
                return node instanceof HTMLShadowElement;
            }

            function getDestinationInsertionPoints(node) {
                return scope.getDestinationInsertionPoints(node);
            }

            function eventRetargetting(path, currentTarget) {
                if (path.length === 0) return currentTarget;
                if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;
                var currentTargetTree = getTreeScope(currentTarget);
                var originalTarget = path[0];
                var originalTargetTree = getTreeScope(originalTarget);
                var relativeTargetTree = lowestCommonInclusiveAncestor(currentTargetTree, originalTargetTree);
                for (var i = 0; i < path.length; i++) {
                    var node = path[i];
                    if (getTreeScope(node) === relativeTargetTree) return node;
                }
                return path[path.length - 1];
            }

            function getTreeScopeAncestors(treeScope) {
                var ancestors = [];
                for (; treeScope; treeScope = treeScope.parent) {
                    ancestors.push(treeScope);
                }
                return ancestors;
            }

            function lowestCommonInclusiveAncestor(tsA, tsB) {
                var ancestorsA = getTreeScopeAncestors(tsA);
                var ancestorsB = getTreeScopeAncestors(tsB);
                var result = null;
                while (ancestorsA.length > 0 && ancestorsB.length > 0) {
                    var a = ancestorsA.pop();
                    var b = ancestorsB.pop();
                    if (a === b) result = a; else break;
                }
                return result;
            }

            function getTreeScopeRoot(ts) {
                if (!ts.parent) return ts;
                return getTreeScopeRoot(ts.parent);
            }

            function relatedTargetResolution(event, currentTarget, relatedTarget) {
                if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;
                var currentTargetTree = getTreeScope(currentTarget);
                var relatedTargetTree = getTreeScope(relatedTarget);
                var relatedTargetEventPath = getEventPath(relatedTarget, event);
                var lowestCommonAncestorTree;
                var lowestCommonAncestorTree = lowestCommonInclusiveAncestor(currentTargetTree, relatedTargetTree);
                if (!lowestCommonAncestorTree) lowestCommonAncestorTree = relatedTargetTree.root;
                for (var commonAncestorTree = lowestCommonAncestorTree; commonAncestorTree; commonAncestorTree = commonAncestorTree.parent) {
                    var adjustedRelatedTarget;
                    for (var i = 0; i < relatedTargetEventPath.length; i++) {
                        var node = relatedTargetEventPath[i];
                        if (getTreeScope(node) === commonAncestorTree) return node;
                    }
                }
                return null;
            }

            function inSameTree(a, b) {
                return getTreeScope(a) === getTreeScope(b);
            }

            var NONE = 0;
            var CAPTURING_PHASE = 1;
            var AT_TARGET = 2;
            var BUBBLING_PHASE = 3;
            var pendingError;

            function dispatchOriginalEvent(originalEvent) {
                if (handledEventsTable.get(originalEvent)) return;
                handledEventsTable.set(originalEvent, true);
                dispatchEvent(wrap(originalEvent), wrap(originalEvent.target));
                if (pendingError) {
                    var err = pendingError;
                    pendingError = null;
                    throw err;
                }
            }

            function isLoadLikeEvent(event) {
                switch (event.type) {
                    case "load":
                    case "beforeunload":
                    case "unload":
                        return true;
                }
                return false;
            }

            function dispatchEvent(event, originalWrapperTarget) {
                if (currentlyDispatchingEvents.get(event)) throw new Error("InvalidStateError");
                currentlyDispatchingEvents.set(event, true);
                scope.renderAllPending();
                var eventPath;
                var overrideTarget;
                var win;
                if (isLoadLikeEvent(event) && !event.bubbles) {
                    var doc = originalWrapperTarget;
                    if (doc instanceof wrappers.Document && (win = doc.defaultView)) {
                        overrideTarget = doc;
                        eventPath = [];
                    }
                }
                if (!eventPath) {
                    if (originalWrapperTarget instanceof wrappers.Window) {
                        win = originalWrapperTarget;
                        eventPath = [];
                    } else {
                        eventPath = getEventPath(originalWrapperTarget, event);
                        if (!isLoadLikeEvent(event)) {
                            var doc = eventPath[eventPath.length - 1];
                            if (doc instanceof wrappers.Document) win = doc.defaultView;
                        }
                    }
                }
                eventPathTable.set(event, eventPath);
                if (dispatchCapturing(event, eventPath, win, overrideTarget)) {
                    if (dispatchAtTarget(event, eventPath, win, overrideTarget)) {
                        dispatchBubbling(event, eventPath, win, overrideTarget);
                    }
                }
                eventPhaseTable.set(event, NONE);
                currentTargetTable.delete(event, null);
                currentlyDispatchingEvents.delete(event);
                return event.defaultPrevented;
            }

            function dispatchCapturing(event, eventPath, win, overrideTarget) {
                var phase = CAPTURING_PHASE;
                if (win) {
                    if (!invoke(win, event, phase, eventPath, overrideTarget)) return false;
                }
                for (var i = eventPath.length - 1; i > 0; i--) {
                    if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return false;
                }
                return true;
            }

            function dispatchAtTarget(event, eventPath, win, overrideTarget) {
                var phase = AT_TARGET;
                var currentTarget = eventPath[0] || win;
                return invoke(currentTarget, event, phase, eventPath, overrideTarget);
            }

            function dispatchBubbling(event, eventPath, win, overrideTarget) {
                var phase = BUBBLING_PHASE;
                for (var i = 1; i < eventPath.length; i++) {
                    if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return;
                }
                if (win && eventPath.length > 0) {
                    invoke(win, event, phase, eventPath, overrideTarget);
                }
            }

            function invoke(currentTarget, event, phase, eventPath, overrideTarget) {
                var listeners = listenersTable.get(currentTarget);
                if (!listeners) return true;
                var target = overrideTarget || eventRetargetting(eventPath, currentTarget);
                if (target === currentTarget) {
                    if (phase === CAPTURING_PHASE) return true;
                    if (phase === BUBBLING_PHASE) phase = AT_TARGET;
                } else if (phase === BUBBLING_PHASE && !event.bubbles) {
                    return true;
                }
                if ("relatedTarget" in event) {
                    var originalEvent = unwrap(event);
                    var unwrappedRelatedTarget = originalEvent.relatedTarget;
                    if (unwrappedRelatedTarget) {
                        if (unwrappedRelatedTarget instanceof Object && unwrappedRelatedTarget.addEventListener) {
                            var relatedTarget = wrap(unwrappedRelatedTarget);
                            var adjusted = relatedTargetResolution(event, currentTarget, relatedTarget);
                            if (adjusted === target) return true;
                        } else {
                            adjusted = null;
                        }
                        relatedTargetTable.set(event, adjusted);
                    }
                }
                eventPhaseTable.set(event, phase);
                var type = event.type;
                var anyRemoved = false;
                targetTable.set(event, target);
                currentTargetTable.set(event, currentTarget);
                listeners.depth++;
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var listener = listeners[i];
                    if (listener.removed) {
                        anyRemoved = true;
                        continue;
                    }
                    if (listener.type !== type || !listener.capture && phase === CAPTURING_PHASE || listener.capture && phase === BUBBLING_PHASE) {
                        continue;
                    }
                    try {
                        if (typeof listener.handler === "function") listener.handler.call(currentTarget, event); else listener.handler.handleEvent(event);
                        if (stopImmediatePropagationTable.get(event)) return false;
                    } catch (ex) {
                        if (!pendingError) pendingError = ex;
                    }
                }
                listeners.depth--;
                if (anyRemoved && listeners.depth === 0) {
                    var copy = listeners.slice();
                    listeners.length = 0;
                    for (var i = 0; i < copy.length; i++) {
                        if (!copy[i].removed) listeners.push(copy[i]);
                    }
                }
                return !stopPropagationTable.get(event);
            }

            function Listener(type, handler, capture) {
                this.type = type;
                this.handler = handler;
                this.capture = Boolean(capture);
            }

            Listener.prototype = {
                equals: function (that) {
                    return this.handler === that.handler && this.type === that.type && this.capture === that.capture;
                },
                get removed() {
                    return this.handler === null;
                },
                remove: function () {
                    this.handler = null;
                }
            };
            var OriginalEvent = window.Event;
            OriginalEvent.prototype.polymerBlackList_ = {
                returnValue: true,
                keyLocation: true
            };
            function Event(type, options) {
                if (type instanceof OriginalEvent) {
                    var impl = type;
                    if (!OriginalBeforeUnloadEvent && impl.type === "beforeunload" && !(this instanceof BeforeUnloadEvent)) {
                        return new BeforeUnloadEvent(impl);
                    }
                    setWrapper(impl, this);
                } else {
                    return wrap(constructEvent(OriginalEvent, "Event", type, options));
                }
            }

            Event.prototype = {
                get target() {
                    return targetTable.get(this);
                },
                get currentTarget() {
                    return currentTargetTable.get(this);
                },
                get eventPhase() {
                    return eventPhaseTable.get(this);
                },
                get path() {
                    var eventPath = eventPathTable.get(this);
                    if (!eventPath) return [];
                    return eventPath.slice();
                },
                stopPropagation: function () {
                    stopPropagationTable.set(this, true);
                },
                stopImmediatePropagation: function () {
                    stopPropagationTable.set(this, true);
                    stopImmediatePropagationTable.set(this, true);
                }
            };
            registerWrapper(OriginalEvent, Event, document.createEvent("Event"));
            function unwrapOptions(options) {
                if (!options || !options.relatedTarget) return options;
                return Object.create(options, {
                    relatedTarget: {
                        value: unwrap(options.relatedTarget)
                    }
                });
            }

            function registerGenericEvent(name, SuperEvent, prototype) {
                var OriginalEvent = window[name];
                var GenericEvent = function (type, options) {
                    if (type instanceof OriginalEvent) setWrapper(type, this); else return wrap(constructEvent(OriginalEvent, name, type, options));
                };
                GenericEvent.prototype = Object.create(SuperEvent.prototype);
                if (prototype) mixin(GenericEvent.prototype, prototype);
                if (OriginalEvent) {
                    try {
                        registerWrapper(OriginalEvent, GenericEvent, new OriginalEvent("temp"));
                    } catch (ex) {
                        registerWrapper(OriginalEvent, GenericEvent, document.createEvent(name));
                    }
                }
                return GenericEvent;
            }

            var UIEvent = registerGenericEvent("UIEvent", Event);
            var CustomEvent = registerGenericEvent("CustomEvent", Event);
            var relatedTargetProto = {
                get relatedTarget() {
                    var relatedTarget = relatedTargetTable.get(this);
                    if (relatedTarget !== undefined) return relatedTarget;
                    return wrap(unwrap(this).relatedTarget);
                }
            };

            function getInitFunction(name, relatedTargetIndex) {
                return function () {
                    arguments[relatedTargetIndex] = unwrap(arguments[relatedTargetIndex]);
                    var impl = unwrap(this);
                    impl[name].apply(impl, arguments);
                };
            }

            var mouseEventProto = mixin({
                initMouseEvent: getInitFunction("initMouseEvent", 14)
            }, relatedTargetProto);
            var focusEventProto = mixin({
                initFocusEvent: getInitFunction("initFocusEvent", 5)
            }, relatedTargetProto);
            var MouseEvent = registerGenericEvent("MouseEvent", UIEvent, mouseEventProto);
            var FocusEvent = registerGenericEvent("FocusEvent", UIEvent, focusEventProto);
            var defaultInitDicts = Object.create(null);
            var supportsEventConstructors = function () {
                try {
                    new window.FocusEvent("focus");
                } catch (ex) {
                    return false;
                }
                return true;
            }();

            function constructEvent(OriginalEvent, name, type, options) {
                if (supportsEventConstructors) return new OriginalEvent(type, unwrapOptions(options));
                var event = unwrap(document.createEvent(name));
                var defaultDict = defaultInitDicts[name];
                var args = [type];
                Object.keys(defaultDict).forEach(function (key) {
                    var v = options != null && key in options ? options[key] : defaultDict[key];
                    if (key === "relatedTarget") v = unwrap(v);
                    args.push(v);
                });
                event["init" + name].apply(event, args);
                return event;
            }

            if (!supportsEventConstructors) {
                var configureEventConstructor = function (name, initDict, superName) {
                    if (superName) {
                        var superDict = defaultInitDicts[superName];
                        initDict = mixin(mixin({}, superDict), initDict);
                    }
                    defaultInitDicts[name] = initDict;
                };
                configureEventConstructor("Event", {
                    bubbles: false,
                    cancelable: false
                });
                configureEventConstructor("CustomEvent", {
                    detail: null
                }, "Event");
                configureEventConstructor("UIEvent", {
                    view: null,
                    detail: 0
                }, "Event");
                configureEventConstructor("MouseEvent", {
                    screenX: 0,
                    screenY: 0,
                    clientX: 0,
                    clientY: 0,
                    ctrlKey: false,
                    altKey: false,
                    shiftKey: false,
                    metaKey: false,
                    button: 0,
                    relatedTarget: null
                }, "UIEvent");
                configureEventConstructor("FocusEvent", {
                    relatedTarget: null
                }, "UIEvent");
            }
            var OriginalBeforeUnloadEvent = window.BeforeUnloadEvent;

            function BeforeUnloadEvent(impl) {
                Event.call(this, impl);
            }

            BeforeUnloadEvent.prototype = Object.create(Event.prototype);
            mixin(BeforeUnloadEvent.prototype, {
                get returnValue() {
                    return unsafeUnwrap(this).returnValue;
                },
                set returnValue(v) {
                    unsafeUnwrap(this).returnValue = v;
                }
            });
            if (OriginalBeforeUnloadEvent) registerWrapper(OriginalBeforeUnloadEvent, BeforeUnloadEvent);
            function isValidListener(fun) {
                if (typeof fun === "function") return true;
                return fun && fun.handleEvent;
            }

            function isMutationEvent(type) {
                switch (type) {
                    case "DOMAttrModified":
                    case "DOMAttributeNameChanged":
                    case "DOMCharacterDataModified":
                    case "DOMElementNameChanged":
                    case "DOMNodeInserted":
                    case "DOMNodeInsertedIntoDocument":
                    case "DOMNodeRemoved":
                    case "DOMNodeRemovedFromDocument":
                    case "DOMSubtreeModified":
                        return true;
                }
                return false;
            }

            var OriginalEventTarget = window.EventTarget;

            function EventTarget(impl) {
                setWrapper(impl, this);
            }

            var methodNames = ["addEventListener", "removeEventListener", "dispatchEvent"];
            [Node, Window].forEach(function (constructor) {
                var p = constructor.prototype;
                methodNames.forEach(function (name) {
                    Object.defineProperty(p, name + "_", {
                        value: p[name]
                    });
                });
            });
            function getTargetToListenAt(wrapper) {
                if (wrapper instanceof wrappers.ShadowRoot) wrapper = wrapper.host;
                return unwrap(wrapper);
            }

            EventTarget.prototype = {
                addEventListener: function (type, fun, capture) {
                    if (!isValidListener(fun) || isMutationEvent(type)) return;
                    var listener = new Listener(type, fun, capture);
                    var listeners = listenersTable.get(this);
                    if (!listeners) {
                        listeners = [];
                        listeners.depth = 0;
                        listenersTable.set(this, listeners);
                    } else {
                        for (var i = 0; i < listeners.length; i++) {
                            if (listener.equals(listeners[i])) return;
                        }
                    }
                    listeners.push(listener);
                    var target = getTargetToListenAt(this);
                    target.addEventListener_(type, dispatchOriginalEvent, true);
                },
                removeEventListener: function (type, fun, capture) {
                    capture = Boolean(capture);
                    var listeners = listenersTable.get(this);
                    if (!listeners) return;
                    var count = 0, found = false;
                    for (var i = 0; i < listeners.length; i++) {
                        if (listeners[i].type === type && listeners[i].capture === capture) {
                            count++;
                            if (listeners[i].handler === fun) {
                                found = true;
                                listeners[i].remove();
                            }
                        }
                    }
                    if (found && count === 1) {
                        var target = getTargetToListenAt(this);
                        target.removeEventListener_(type, dispatchOriginalEvent, true);
                    }
                },
                dispatchEvent: function (event) {
                    var nativeEvent = unwrap(event);
                    var eventType = nativeEvent.type;
                    handledEventsTable.set(nativeEvent, false);
                    scope.renderAllPending();
                    var tempListener;
                    if (!hasListenerInAncestors(this, eventType)) {
                        tempListener = function () {
                        };
                        this.addEventListener(eventType, tempListener, true);
                    }
                    try {
                        return unwrap(this).dispatchEvent_(nativeEvent);
                    } finally {
                        if (tempListener) this.removeEventListener(eventType, tempListener, true);
                    }
                }
            };
            function hasListener(node, type) {
                var listeners = listenersTable.get(node);
                if (listeners) {
                    for (var i = 0; i < listeners.length; i++) {
                        if (!listeners[i].removed && listeners[i].type === type) return true;
                    }
                }
                return false;
            }

            function hasListenerInAncestors(target, type) {
                for (var node = unwrap(target); node; node = node.parentNode) {
                    if (hasListener(wrap(node), type)) return true;
                }
                return false;
            }

            if (OriginalEventTarget) registerWrapper(OriginalEventTarget, EventTarget);
            function wrapEventTargetMethods(constructors) {
                forwardMethodsToWrapper(constructors, methodNames);
            }

            var originalElementFromPoint = document.elementFromPoint;

            function elementFromPoint(self, document, x, y) {
                scope.renderAllPending();
                var element = wrap(originalElementFromPoint.call(unsafeUnwrap(document), x, y));
                if (!element) return null;
                var path = getEventPath(element, null);
                var idx = path.lastIndexOf(self);
                if (idx == -1) return null; else path = path.slice(0, idx);
                return eventRetargetting(path, self);
            }

            function getEventHandlerGetter(name) {
                return function () {
                    var inlineEventHandlers = eventHandlersTable.get(this);
                    return inlineEventHandlers && inlineEventHandlers[name] && inlineEventHandlers[name].value || null;
                };
            }

            function getEventHandlerSetter(name) {
                var eventType = name.slice(2);
                return function (value) {
                    var inlineEventHandlers = eventHandlersTable.get(this);
                    if (!inlineEventHandlers) {
                        inlineEventHandlers = Object.create(null);
                        eventHandlersTable.set(this, inlineEventHandlers);
                    }
                    var old = inlineEventHandlers[name];
                    if (old) this.removeEventListener(eventType, old.wrapped, false);
                    if (typeof value === "function") {
                        var wrapped = function (e) {
                            var rv = value.call(this, e);
                            if (rv === false) e.preventDefault(); else if (name === "onbeforeunload" && typeof rv === "string") e.returnValue = rv;
                        };
                        this.addEventListener(eventType, wrapped, false);
                        inlineEventHandlers[name] = {
                            value: value,
                            wrapped: wrapped
                        };
                    }
                };
            }

            scope.elementFromPoint = elementFromPoint;
            scope.getEventHandlerGetter = getEventHandlerGetter;
            scope.getEventHandlerSetter = getEventHandlerSetter;
            scope.wrapEventTargetMethods = wrapEventTargetMethods;
            scope.wrappers.BeforeUnloadEvent = BeforeUnloadEvent;
            scope.wrappers.CustomEvent = CustomEvent;
            scope.wrappers.Event = Event;
            scope.wrappers.EventTarget = EventTarget;
            scope.wrappers.FocusEvent = FocusEvent;
            scope.wrappers.MouseEvent = MouseEvent;
            scope.wrappers.UIEvent = UIEvent;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var UIEvent = scope.wrappers.UIEvent;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var setWrapper = scope.setWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var wrap = scope.wrap;
            var OriginalTouchEvent = window.TouchEvent;
            if (!OriginalTouchEvent) return;
            var nativeEvent;
            try {
                nativeEvent = document.createEvent("TouchEvent");
            } catch (ex) {
                return;
            }
            var nonEnumDescriptor = {
                enumerable: false
            };

            function nonEnum(obj, prop) {
                Object.defineProperty(obj, prop, nonEnumDescriptor);
            }

            function Touch(impl) {
                setWrapper(impl, this);
            }

            Touch.prototype = {
                get target() {
                    return wrap(unsafeUnwrap(this).target);
                }
            };
            var descr = {
                configurable: true,
                enumerable: true,
                get: null
            };
            ["clientX", "clientY", "screenX", "screenY", "pageX", "pageY", "identifier", "webkitRadiusX", "webkitRadiusY", "webkitRotationAngle", "webkitForce"].forEach(function (name) {
                descr.get = function () {
                    return unsafeUnwrap(this)[name];
                };
                Object.defineProperty(Touch.prototype, name, descr);
            });
            function TouchList() {
                this.length = 0;
                nonEnum(this, "length");
            }

            TouchList.prototype = {
                item: function (index) {
                    return this[index];
                }
            };
            function wrapTouchList(nativeTouchList) {
                var list = new TouchList();
                for (var i = 0; i < nativeTouchList.length; i++) {
                    list[i] = new Touch(nativeTouchList[i]);
                }
                list.length = i;
                return list;
            }

            function TouchEvent(impl) {
                UIEvent.call(this, impl);
            }

            TouchEvent.prototype = Object.create(UIEvent.prototype);
            mixin(TouchEvent.prototype, {
                get touches() {
                    return wrapTouchList(unsafeUnwrap(this).touches);
                },
                get targetTouches() {
                    return wrapTouchList(unsafeUnwrap(this).targetTouches);
                },
                get changedTouches() {
                    return wrapTouchList(unsafeUnwrap(this).changedTouches);
                },
                initTouchEvent: function () {
                    throw new Error("Not implemented");
                }
            });
            registerWrapper(OriginalTouchEvent, TouchEvent, nativeEvent);
            scope.wrappers.Touch = Touch;
            scope.wrappers.TouchEvent = TouchEvent;
            scope.wrappers.TouchList = TouchList;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var unsafeUnwrap = scope.unsafeUnwrap;
            var wrap = scope.wrap;
            var nonEnumDescriptor = {
                enumerable: false
            };

            function nonEnum(obj, prop) {
                Object.defineProperty(obj, prop, nonEnumDescriptor);
            }

            function NodeList() {
                this.length = 0;
                nonEnum(this, "length");
            }

            NodeList.prototype = {
                item: function (index) {
                    return this[index];
                }
            };
            nonEnum(NodeList.prototype, "item");
            function wrapNodeList(list) {
                if (list == null) return list;
                var wrapperList = new NodeList();
                for (var i = 0, length = list.length; i < length; i++) {
                    wrapperList[i] = wrap(list[i]);
                }
                wrapperList.length = length;
                return wrapperList;
            }

            function addWrapNodeListMethod(wrapperConstructor, name) {
                wrapperConstructor.prototype[name] = function () {
                    return wrapNodeList(unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments));
                };
            }

            scope.wrappers.NodeList = NodeList;
            scope.addWrapNodeListMethod = addWrapNodeListMethod;
            scope.wrapNodeList = wrapNodeList;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            scope.wrapHTMLCollection = scope.wrapNodeList;
            scope.wrappers.HTMLCollection = scope.wrappers.NodeList;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var EventTarget = scope.wrappers.EventTarget;
            var NodeList = scope.wrappers.NodeList;
            var TreeScope = scope.TreeScope;
            var assert = scope.assert;
            var defineWrapGetter = scope.defineWrapGetter;
            var enqueueMutation = scope.enqueueMutation;
            var getTreeScope = scope.getTreeScope;
            var isWrapper = scope.isWrapper;
            var mixin = scope.mixin;
            var registerTransientObservers = scope.registerTransientObservers;
            var registerWrapper = scope.registerWrapper;
            var setTreeScope = scope.setTreeScope;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var unwrap = scope.unwrap;
            var unwrapIfNeeded = scope.unwrapIfNeeded;
            var wrap = scope.wrap;
            var wrapIfNeeded = scope.wrapIfNeeded;
            var wrappers = scope.wrappers;

            function assertIsNodeWrapper(node) {
                assert(node instanceof Node);
            }

            function createOneElementNodeList(node) {
                var nodes = new NodeList();
                nodes[0] = node;
                nodes.length = 1;
                return nodes;
            }

            var surpressMutations = false;

            function enqueueRemovalForInsertedNodes(node, parent, nodes) {
                enqueueMutation(parent, "childList", {
                    removedNodes: nodes,
                    previousSibling: node.previousSibling,
                    nextSibling: node.nextSibling
                });
            }

            function enqueueRemovalForInsertedDocumentFragment(df, nodes) {
                enqueueMutation(df, "childList", {
                    removedNodes: nodes
                });
            }

            function collectNodes(node, parentNode, previousNode, nextNode) {
                if (node instanceof DocumentFragment) {
                    var nodes = collectNodesForDocumentFragment(node);
                    surpressMutations = true;
                    for (var i = nodes.length - 1; i >= 0; i--) {
                        node.removeChild(nodes[i]);
                        nodes[i].parentNode_ = parentNode;
                    }
                    surpressMutations = false;
                    for (var i = 0; i < nodes.length; i++) {
                        nodes[i].previousSibling_ = nodes[i - 1] || previousNode;
                        nodes[i].nextSibling_ = nodes[i + 1] || nextNode;
                    }
                    if (previousNode) previousNode.nextSibling_ = nodes[0];
                    if (nextNode) nextNode.previousSibling_ = nodes[nodes.length - 1];
                    return nodes;
                }
                var nodes = createOneElementNodeList(node);
                var oldParent = node.parentNode;
                if (oldParent) {
                    oldParent.removeChild(node);
                }
                node.parentNode_ = parentNode;
                node.previousSibling_ = previousNode;
                node.nextSibling_ = nextNode;
                if (previousNode) previousNode.nextSibling_ = node;
                if (nextNode) nextNode.previousSibling_ = node;
                return nodes;
            }

            function collectNodesNative(node) {
                if (node instanceof DocumentFragment) return collectNodesForDocumentFragment(node);
                var nodes = createOneElementNodeList(node);
                var oldParent = node.parentNode;
                if (oldParent) enqueueRemovalForInsertedNodes(node, oldParent, nodes);
                return nodes;
            }

            function collectNodesForDocumentFragment(node) {
                var nodes = new NodeList();
                var i = 0;
                for (var child = node.firstChild; child; child = child.nextSibling) {
                    nodes[i++] = child;
                }
                nodes.length = i;
                enqueueRemovalForInsertedDocumentFragment(node, nodes);
                return nodes;
            }

            function snapshotNodeList(nodeList) {
                return nodeList;
            }

            function nodeWasAdded(node, treeScope) {
                setTreeScope(node, treeScope);
                node.nodeIsInserted_();
            }

            function nodesWereAdded(nodes, parent) {
                var treeScope = getTreeScope(parent);
                for (var i = 0; i < nodes.length; i++) {
                    nodeWasAdded(nodes[i], treeScope);
                }
            }

            function nodeWasRemoved(node) {
                setTreeScope(node, new TreeScope(node, null));
            }

            function nodesWereRemoved(nodes) {
                for (var i = 0; i < nodes.length; i++) {
                    nodeWasRemoved(nodes[i]);
                }
            }

            function ensureSameOwnerDocument(parent, child) {
                var ownerDoc = parent.nodeType === Node.DOCUMENT_NODE ? parent : parent.ownerDocument;
                if (ownerDoc !== child.ownerDocument) ownerDoc.adoptNode(child);
            }

            function adoptNodesIfNeeded(owner, nodes) {
                if (!nodes.length) return;
                var ownerDoc = owner.ownerDocument;
                if (ownerDoc === nodes[0].ownerDocument) return;
                for (var i = 0; i < nodes.length; i++) {
                    scope.adoptNodeNoRemove(nodes[i], ownerDoc);
                }
            }

            function unwrapNodesForInsertion(owner, nodes) {
                adoptNodesIfNeeded(owner, nodes);
                var length = nodes.length;
                if (length === 1) return unwrap(nodes[0]);
                var df = unwrap(owner.ownerDocument.createDocumentFragment());
                for (var i = 0; i < length; i++) {
                    df.appendChild(unwrap(nodes[i]));
                }
                return df;
            }

            function clearChildNodes(wrapper) {
                if (wrapper.firstChild_ !== undefined) {
                    var child = wrapper.firstChild_;
                    while (child) {
                        var tmp = child;
                        child = child.nextSibling_;
                        tmp.parentNode_ = tmp.previousSibling_ = tmp.nextSibling_ = undefined;
                    }
                }
                wrapper.firstChild_ = wrapper.lastChild_ = undefined;
            }

            function removeAllChildNodes(wrapper) {
                if (wrapper.invalidateShadowRenderer()) {
                    var childWrapper = wrapper.firstChild;
                    while (childWrapper) {
                        assert(childWrapper.parentNode === wrapper);
                        var nextSibling = childWrapper.nextSibling;
                        var childNode = unwrap(childWrapper);
                        var parentNode = childNode.parentNode;
                        if (parentNode) originalRemoveChild.call(parentNode, childNode);
                        childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;
                        childWrapper = nextSibling;
                    }
                    wrapper.firstChild_ = wrapper.lastChild_ = null;
                } else {
                    var node = unwrap(wrapper);
                    var child = node.firstChild;
                    var nextSibling;
                    while (child) {
                        nextSibling = child.nextSibling;
                        originalRemoveChild.call(node, child);
                        child = nextSibling;
                    }
                }
            }

            function invalidateParent(node) {
                var p = node.parentNode;
                return p && p.invalidateShadowRenderer();
            }

            function cleanupNodes(nodes) {
                for (var i = 0, n; i < nodes.length; i++) {
                    n = nodes[i];
                    n.parentNode.removeChild(n);
                }
            }

            var originalImportNode = document.importNode;
            var originalCloneNode = window.Node.prototype.cloneNode;

            function cloneNode(node, deep, opt_doc) {
                var clone;
                if (opt_doc) clone = wrap(originalImportNode.call(opt_doc, unsafeUnwrap(node), false)); else clone = wrap(originalCloneNode.call(unsafeUnwrap(node), false));
                if (deep) {
                    for (var child = node.firstChild; child; child = child.nextSibling) {
                        clone.appendChild(cloneNode(child, true, opt_doc));
                    }
                    if (node instanceof wrappers.HTMLTemplateElement) {
                        var cloneContent = clone.content;
                        for (var child = node.content.firstChild; child; child = child.nextSibling) {
                            cloneContent.appendChild(cloneNode(child, true, opt_doc));
                        }
                    }
                }
                return clone;
            }

            function contains(self, child) {
                if (!child || getTreeScope(self) !== getTreeScope(child)) return false;
                for (var node = child; node; node = node.parentNode) {
                    if (node === self) return true;
                }
                return false;
            }

            var OriginalNode = window.Node;

            function Node(original) {
                assert(original instanceof OriginalNode);
                EventTarget.call(this, original);
                this.parentNode_ = undefined;
                this.firstChild_ = undefined;
                this.lastChild_ = undefined;
                this.nextSibling_ = undefined;
                this.previousSibling_ = undefined;
                this.treeScope_ = undefined;
            }

            var OriginalDocumentFragment = window.DocumentFragment;
            var originalAppendChild = OriginalNode.prototype.appendChild;
            var originalCompareDocumentPosition = OriginalNode.prototype.compareDocumentPosition;
            var originalIsEqualNode = OriginalNode.prototype.isEqualNode;
            var originalInsertBefore = OriginalNode.prototype.insertBefore;
            var originalRemoveChild = OriginalNode.prototype.removeChild;
            var originalReplaceChild = OriginalNode.prototype.replaceChild;
            var isIEOrEdge = /Trident|Edge/.test(navigator.userAgent);
            var removeChildOriginalHelper = isIEOrEdge ? function (parent, child) {
                try {
                    originalRemoveChild.call(parent, child);
                } catch (ex) {
                    if (!(parent instanceof OriginalDocumentFragment)) throw ex;
                }
            } : function (parent, child) {
                originalRemoveChild.call(parent, child);
            };
            Node.prototype = Object.create(EventTarget.prototype);
            mixin(Node.prototype, {
                appendChild: function (childWrapper) {
                    return this.insertBefore(childWrapper, null);
                },
                insertBefore: function (childWrapper, refWrapper) {
                    assertIsNodeWrapper(childWrapper);
                    var refNode;
                    if (refWrapper) {
                        if (isWrapper(refWrapper)) {
                            refNode = unwrap(refWrapper);
                        } else {
                            refNode = refWrapper;
                            refWrapper = wrap(refNode);
                        }
                    } else {
                        refWrapper = null;
                        refNode = null;
                    }
                    refWrapper && assert(refWrapper.parentNode === this);
                    var nodes;
                    var previousNode = refWrapper ? refWrapper.previousSibling : this.lastChild;
                    var useNative = !this.invalidateShadowRenderer() && !invalidateParent(childWrapper);
                    if (useNative) nodes = collectNodesNative(childWrapper); else nodes = collectNodes(childWrapper, this, previousNode, refWrapper);
                    if (useNative) {
                        ensureSameOwnerDocument(this, childWrapper);
                        clearChildNodes(this);
                        originalInsertBefore.call(unsafeUnwrap(this), unwrap(childWrapper), refNode);
                    } else {
                        if (!previousNode) this.firstChild_ = nodes[0];
                        if (!refWrapper) {
                            this.lastChild_ = nodes[nodes.length - 1];
                            if (this.firstChild_ === undefined) this.firstChild_ = this.firstChild;
                        }
                        var parentNode = refNode ? refNode.parentNode : unsafeUnwrap(this);
                        if (parentNode) {
                            originalInsertBefore.call(parentNode, unwrapNodesForInsertion(this, nodes), refNode);
                        } else {
                            adoptNodesIfNeeded(this, nodes);
                        }
                    }
                    enqueueMutation(this, "childList", {
                        addedNodes: nodes,
                        nextSibling: refWrapper,
                        previousSibling: previousNode
                    });
                    nodesWereAdded(nodes, this);
                    return childWrapper;
                },
                removeChild: function (childWrapper) {
                    assertIsNodeWrapper(childWrapper);
                    if (childWrapper.parentNode !== this) {
                        var found = false;
                        var childNodes = this.childNodes;
                        for (var ieChild = this.firstChild; ieChild; ieChild = ieChild.nextSibling) {
                            if (ieChild === childWrapper) {
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            throw new Error("NotFoundError");
                        }
                    }
                    var childNode = unwrap(childWrapper);
                    var childWrapperNextSibling = childWrapper.nextSibling;
                    var childWrapperPreviousSibling = childWrapper.previousSibling;
                    if (this.invalidateShadowRenderer()) {
                        var thisFirstChild = this.firstChild;
                        var thisLastChild = this.lastChild;
                        var parentNode = childNode.parentNode;
                        if (parentNode) removeChildOriginalHelper(parentNode, childNode);
                        if (thisFirstChild === childWrapper) this.firstChild_ = childWrapperNextSibling;
                        if (thisLastChild === childWrapper) this.lastChild_ = childWrapperPreviousSibling;
                        if (childWrapperPreviousSibling) childWrapperPreviousSibling.nextSibling_ = childWrapperNextSibling;
                        if (childWrapperNextSibling) {
                            childWrapperNextSibling.previousSibling_ = childWrapperPreviousSibling;
                        }
                        childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = undefined;
                    } else {
                        clearChildNodes(this);
                        removeChildOriginalHelper(unsafeUnwrap(this), childNode);
                    }
                    if (!surpressMutations) {
                        enqueueMutation(this, "childList", {
                            removedNodes: createOneElementNodeList(childWrapper),
                            nextSibling: childWrapperNextSibling,
                            previousSibling: childWrapperPreviousSibling
                        });
                    }
                    registerTransientObservers(this, childWrapper);
                    return childWrapper;
                },
                replaceChild: function (newChildWrapper, oldChildWrapper) {
                    assertIsNodeWrapper(newChildWrapper);
                    var oldChildNode;
                    if (isWrapper(oldChildWrapper)) {
                        oldChildNode = unwrap(oldChildWrapper);
                    } else {
                        oldChildNode = oldChildWrapper;
                        oldChildWrapper = wrap(oldChildNode);
                    }
                    if (oldChildWrapper.parentNode !== this) {
                        throw new Error("NotFoundError");
                    }
                    var nextNode = oldChildWrapper.nextSibling;
                    var previousNode = oldChildWrapper.previousSibling;
                    var nodes;
                    var useNative = !this.invalidateShadowRenderer() && !invalidateParent(newChildWrapper);
                    if (useNative) {
                        nodes = collectNodesNative(newChildWrapper);
                    } else {
                        if (nextNode === newChildWrapper) nextNode = newChildWrapper.nextSibling;
                        nodes = collectNodes(newChildWrapper, this, previousNode, nextNode);
                    }
                    if (!useNative) {
                        if (this.firstChild === oldChildWrapper) this.firstChild_ = nodes[0];
                        if (this.lastChild === oldChildWrapper) this.lastChild_ = nodes[nodes.length - 1];
                        oldChildWrapper.previousSibling_ = oldChildWrapper.nextSibling_ = oldChildWrapper.parentNode_ = undefined;
                        if (oldChildNode.parentNode) {
                            originalReplaceChild.call(oldChildNode.parentNode, unwrapNodesForInsertion(this, nodes), oldChildNode);
                        }
                    } else {
                        ensureSameOwnerDocument(this, newChildWrapper);
                        clearChildNodes(this);
                        originalReplaceChild.call(unsafeUnwrap(this), unwrap(newChildWrapper), oldChildNode);
                    }
                    enqueueMutation(this, "childList", {
                        addedNodes: nodes,
                        removedNodes: createOneElementNodeList(oldChildWrapper),
                        nextSibling: nextNode,
                        previousSibling: previousNode
                    });
                    nodeWasRemoved(oldChildWrapper);
                    nodesWereAdded(nodes, this);
                    return oldChildWrapper;
                },
                nodeIsInserted_: function () {
                    for (var child = this.firstChild; child; child = child.nextSibling) {
                        child.nodeIsInserted_();
                    }
                },
                hasChildNodes: function () {
                    return this.firstChild !== null;
                },
                get parentNode() {
                    return this.parentNode_ !== undefined ? this.parentNode_ : wrap(unsafeUnwrap(this).parentNode);
                },
                get firstChild() {
                    return this.firstChild_ !== undefined ? this.firstChild_ : wrap(unsafeUnwrap(this).firstChild);
                },
                get lastChild() {
                    return this.lastChild_ !== undefined ? this.lastChild_ : wrap(unsafeUnwrap(this).lastChild);
                },
                get nextSibling() {
                    return this.nextSibling_ !== undefined ? this.nextSibling_ : wrap(unsafeUnwrap(this).nextSibling);
                },
                get previousSibling() {
                    return this.previousSibling_ !== undefined ? this.previousSibling_ : wrap(unsafeUnwrap(this).previousSibling);
                },
                get parentElement() {
                    var p = this.parentNode;
                    while (p && p.nodeType !== Node.ELEMENT_NODE) {
                        p = p.parentNode;
                    }
                    return p;
                },
                get textContent() {
                    var s = "";
                    for (var child = this.firstChild; child; child = child.nextSibling) {
                        if (child.nodeType != Node.COMMENT_NODE) {
                            s += child.textContent;
                        }
                    }
                    return s;
                },
                set textContent(textContent) {
                    if (textContent == null) textContent = "";
                    var removedNodes = snapshotNodeList(this.childNodes);
                    if (this.invalidateShadowRenderer()) {
                        removeAllChildNodes(this);
                        if (textContent !== "") {
                            var textNode = unsafeUnwrap(this).ownerDocument.createTextNode(textContent);
                            this.appendChild(textNode);
                        }
                    } else {
                        clearChildNodes(this);
                        unsafeUnwrap(this).textContent = textContent;
                    }
                    var addedNodes = snapshotNodeList(this.childNodes);
                    enqueueMutation(this, "childList", {
                        addedNodes: addedNodes,
                        removedNodes: removedNodes
                    });
                    nodesWereRemoved(removedNodes);
                    nodesWereAdded(addedNodes, this);
                },
                get childNodes() {
                    var wrapperList = new NodeList();
                    var i = 0;
                    for (var child = this.firstChild; child; child = child.nextSibling) {
                        wrapperList[i++] = child;
                    }
                    wrapperList.length = i;
                    return wrapperList;
                },
                cloneNode: function (deep) {
                    return cloneNode(this, deep);
                },
                contains: function (child) {
                    return contains(this, wrapIfNeeded(child));
                },
                compareDocumentPosition: function (otherNode) {
                    return originalCompareDocumentPosition.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));
                },
                isEqualNode: function (otherNode) {
                    return originalIsEqualNode.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));
                },
                normalize: function () {
                    var nodes = snapshotNodeList(this.childNodes);
                    var remNodes = [];
                    var s = "";
                    var modNode;
                    for (var i = 0, n; i < nodes.length; i++) {
                        n = nodes[i];
                        if (n.nodeType === Node.TEXT_NODE) {
                            if (!modNode && !n.data.length) this.removeChild(n); else if (!modNode) modNode = n; else {
                                s += n.data;
                                remNodes.push(n);
                            }
                        } else {
                            if (modNode && remNodes.length) {
                                modNode.data += s;
                                cleanupNodes(remNodes);
                            }
                            remNodes = [];
                            s = "";
                            modNode = null;
                            if (n.childNodes.length) n.normalize();
                        }
                    }
                    if (modNode && remNodes.length) {
                        modNode.data += s;
                        cleanupNodes(remNodes);
                    }
                }
            });
            defineWrapGetter(Node, "ownerDocument");
            registerWrapper(OriginalNode, Node, document.createDocumentFragment());
            delete Node.prototype.querySelector;
            delete Node.prototype.querySelectorAll;
            Node.prototype = mixin(Object.create(EventTarget.prototype), Node.prototype);
            scope.cloneNode = cloneNode;
            scope.nodeWasAdded = nodeWasAdded;
            scope.nodeWasRemoved = nodeWasRemoved;
            scope.nodesWereAdded = nodesWereAdded;
            scope.nodesWereRemoved = nodesWereRemoved;
            scope.originalInsertBefore = originalInsertBefore;
            scope.originalRemoveChild = originalRemoveChild;
            scope.snapshotNodeList = snapshotNodeList;
            scope.wrappers.Node = Node;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLCollection = scope.wrappers.HTMLCollection;
            var NodeList = scope.wrappers.NodeList;
            var getTreeScope = scope.getTreeScope;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var wrap = scope.wrap;
            var originalDocumentQuerySelector = document.querySelector;
            var originalElementQuerySelector = document.documentElement.querySelector;
            var originalDocumentQuerySelectorAll = document.querySelectorAll;
            var originalElementQuerySelectorAll = document.documentElement.querySelectorAll;
            var originalDocumentGetElementsByTagName = document.getElementsByTagName;
            var originalElementGetElementsByTagName = document.documentElement.getElementsByTagName;
            var originalDocumentGetElementsByTagNameNS = document.getElementsByTagNameNS;
            var originalElementGetElementsByTagNameNS = document.documentElement.getElementsByTagNameNS;
            var OriginalElement = window.Element;
            var OriginalDocument = window.HTMLDocument || window.Document;

            function filterNodeList(list, index, result, deep) {
                var wrappedItem = null;
                var root = null;
                for (var i = 0, length = list.length; i < length; i++) {
                    wrappedItem = wrap(list[i]);
                    if (!deep && (root = getTreeScope(wrappedItem).root)) {
                        if (root instanceof scope.wrappers.ShadowRoot) {
                            continue;
                        }
                    }
                    result[index++] = wrappedItem;
                }
                return index;
            }

            function shimSelector(selector) {
                return String(selector).replace(/\/deep\/|::shadow|>>>/g, " ");
            }

            function shimMatchesSelector(selector) {
                return String(selector).replace(/:host\(([^\s]+)\)/g, "$1").replace(/([^\s]):host/g, "$1").replace(":host", "*").replace(/\^|\/shadow\/|\/shadow-deep\/|::shadow|\/deep\/|::content|>>>/g, " ");
            }

            function findOne(node, selector) {
                var m, el = node.firstElementChild;
                while (el) {
                    if (el.matches(selector)) return el;
                    m = findOne(el, selector);
                    if (m) return m;
                    el = el.nextElementSibling;
                }
                return null;
            }

            function matchesSelector(el, selector) {
                return el.matches(selector);
            }

            var XHTML_NS = "http://www.w3.org/1999/xhtml";

            function matchesTagName(el, localName, localNameLowerCase) {
                var ln = el.localName;
                return ln === localName || ln === localNameLowerCase && el.namespaceURI === XHTML_NS;
            }

            function matchesEveryThing() {
                return true;
            }

            function matchesLocalNameOnly(el, ns, localName) {
                return el.localName === localName;
            }

            function matchesNameSpace(el, ns) {
                return el.namespaceURI === ns;
            }

            function matchesLocalNameNS(el, ns, localName) {
                return el.namespaceURI === ns && el.localName === localName;
            }

            function findElements(node, index, result, p, arg0, arg1) {
                var el = node.firstElementChild;
                while (el) {
                    if (p(el, arg0, arg1)) result[index++] = el;
                    index = findElements(el, index, result, p, arg0, arg1);
                    el = el.nextElementSibling;
                }
                return index;
            }

            function querySelectorAllFiltered(p, index, result, selector, deep) {
                var target = unsafeUnwrap(this);
                var list;
                var root = getTreeScope(this).root;
                if (root instanceof scope.wrappers.ShadowRoot) {
                    return findElements(this, index, result, p, selector, null);
                } else if (target instanceof OriginalElement) {
                    list = originalElementQuerySelectorAll.call(target, selector);
                } else if (target instanceof OriginalDocument) {
                    list = originalDocumentQuerySelectorAll.call(target, selector);
                } else {
                    return findElements(this, index, result, p, selector, null);
                }
                return filterNodeList(list, index, result, deep);
            }

            var SelectorsInterface = {
                querySelector: function (selector) {
                    var shimmed = shimSelector(selector);
                    var deep = shimmed !== selector;
                    selector = shimmed;
                    var target = unsafeUnwrap(this);
                    var wrappedItem;
                    var root = getTreeScope(this).root;
                    if (root instanceof scope.wrappers.ShadowRoot) {
                        return findOne(this, selector);
                    } else if (target instanceof OriginalElement) {
                        wrappedItem = wrap(originalElementQuerySelector.call(target, selector));
                    } else if (target instanceof OriginalDocument) {
                        wrappedItem = wrap(originalDocumentQuerySelector.call(target, selector));
                    } else {
                        return findOne(this, selector);
                    }
                    if (!wrappedItem) {
                        return wrappedItem;
                    } else if (!deep && (root = getTreeScope(wrappedItem).root)) {
                        if (root instanceof scope.wrappers.ShadowRoot) {
                            return findOne(this, selector);
                        }
                    }
                    return wrappedItem;
                },
                querySelectorAll: function (selector) {
                    var shimmed = shimSelector(selector);
                    var deep = shimmed !== selector;
                    selector = shimmed;
                    var result = new NodeList();
                    result.length = querySelectorAllFiltered.call(this, matchesSelector, 0, result, selector, deep);
                    return result;
                }
            };
            var MatchesInterface = {
                matches: function (selector) {
                    selector = shimMatchesSelector(selector);
                    return scope.originalMatches.call(unsafeUnwrap(this), selector);
                }
            };

            function getElementsByTagNameFiltered(p, index, result, localName, lowercase) {
                var target = unsafeUnwrap(this);
                var list;
                var root = getTreeScope(this).root;
                if (root instanceof scope.wrappers.ShadowRoot) {
                    return findElements(this, index, result, p, localName, lowercase);
                } else if (target instanceof OriginalElement) {
                    list = originalElementGetElementsByTagName.call(target, localName, lowercase);
                } else if (target instanceof OriginalDocument) {
                    list = originalDocumentGetElementsByTagName.call(target, localName, lowercase);
                } else {
                    return findElements(this, index, result, p, localName, lowercase);
                }
                return filterNodeList(list, index, result, false);
            }

            function getElementsByTagNameNSFiltered(p, index, result, ns, localName) {
                var target = unsafeUnwrap(this);
                var list;
                var root = getTreeScope(this).root;
                if (root instanceof scope.wrappers.ShadowRoot) {
                    return findElements(this, index, result, p, ns, localName);
                } else if (target instanceof OriginalElement) {
                    list = originalElementGetElementsByTagNameNS.call(target, ns, localName);
                } else if (target instanceof OriginalDocument) {
                    list = originalDocumentGetElementsByTagNameNS.call(target, ns, localName);
                } else {
                    return findElements(this, index, result, p, ns, localName);
                }
                return filterNodeList(list, index, result, false);
            }

            var GetElementsByInterface = {
                getElementsByTagName: function (localName) {
                    var result = new HTMLCollection();
                    var match = localName === "*" ? matchesEveryThing : matchesTagName;
                    result.length = getElementsByTagNameFiltered.call(this, match, 0, result, localName, localName.toLowerCase());
                    return result;
                },
                getElementsByClassName: function (className) {
                    return this.querySelectorAll("." + className);
                },
                getElementsByTagNameNS: function (ns, localName) {
                    var result = new HTMLCollection();
                    var match = null;
                    if (ns === "*") {
                        match = localName === "*" ? matchesEveryThing : matchesLocalNameOnly;
                    } else {
                        match = localName === "*" ? matchesNameSpace : matchesLocalNameNS;
                    }
                    result.length = getElementsByTagNameNSFiltered.call(this, match, 0, result, ns || null, localName);
                    return result;
                }
            };
            scope.GetElementsByInterface = GetElementsByInterface;
            scope.SelectorsInterface = SelectorsInterface;
            scope.MatchesInterface = MatchesInterface;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var NodeList = scope.wrappers.NodeList;

            function forwardElement(node) {
                while (node && node.nodeType !== Node.ELEMENT_NODE) {
                    node = node.nextSibling;
                }
                return node;
            }

            function backwardsElement(node) {
                while (node && node.nodeType !== Node.ELEMENT_NODE) {
                    node = node.previousSibling;
                }
                return node;
            }

            var ParentNodeInterface = {
                get firstElementChild() {
                    return forwardElement(this.firstChild);
                },
                get lastElementChild() {
                    return backwardsElement(this.lastChild);
                },
                get childElementCount() {
                    var count = 0;
                    for (var child = this.firstElementChild; child; child = child.nextElementSibling) {
                        count++;
                    }
                    return count;
                },
                get children() {
                    var wrapperList = new NodeList();
                    var i = 0;
                    for (var child = this.firstElementChild; child; child = child.nextElementSibling) {
                        wrapperList[i++] = child;
                    }
                    wrapperList.length = i;
                    return wrapperList;
                },
                remove: function () {
                    var p = this.parentNode;
                    if (p) p.removeChild(this);
                }
            };
            var ChildNodeInterface = {
                get nextElementSibling() {
                    return forwardElement(this.nextSibling);
                },
                get previousElementSibling() {
                    return backwardsElement(this.previousSibling);
                }
            };
            var NonElementParentNodeInterface = {
                getElementById: function (id) {
                    if (/[ \t\n\r\f]/.test(id)) return null;
                    return this.querySelector('[id="' + id + '"]');
                }
            };
            scope.ChildNodeInterface = ChildNodeInterface;
            scope.NonElementParentNodeInterface = NonElementParentNodeInterface;
            scope.ParentNodeInterface = ParentNodeInterface;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var ChildNodeInterface = scope.ChildNodeInterface;
            var Node = scope.wrappers.Node;
            var enqueueMutation = scope.enqueueMutation;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var OriginalCharacterData = window.CharacterData;

            function CharacterData(node) {
                Node.call(this, node);
            }

            CharacterData.prototype = Object.create(Node.prototype);
            mixin(CharacterData.prototype, {
                get nodeValue() {
                    return this.data;
                },
                set nodeValue(data) {
                    this.data = data;
                },
                get textContent() {
                    return this.data;
                },
                set textContent(value) {
                    this.data = value;
                },
                get data() {
                    return unsafeUnwrap(this).data;
                },
                set data(value) {
                    var oldValue = unsafeUnwrap(this).data;
                    enqueueMutation(this, "characterData", {
                        oldValue: oldValue
                    });
                    unsafeUnwrap(this).data = value;
                }
            });
            mixin(CharacterData.prototype, ChildNodeInterface);
            registerWrapper(OriginalCharacterData, CharacterData, document.createTextNode(""));
            scope.wrappers.CharacterData = CharacterData;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var CharacterData = scope.wrappers.CharacterData;
            var enqueueMutation = scope.enqueueMutation;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;

            function toUInt32(x) {
                return x >>> 0;
            }

            var OriginalText = window.Text;

            function Text(node) {
                CharacterData.call(this, node);
            }

            Text.prototype = Object.create(CharacterData.prototype);
            mixin(Text.prototype, {
                splitText: function (offset) {
                    offset = toUInt32(offset);
                    var s = this.data;
                    if (offset > s.length) throw new Error("IndexSizeError");
                    var head = s.slice(0, offset);
                    var tail = s.slice(offset);
                    this.data = head;
                    var newTextNode = this.ownerDocument.createTextNode(tail);
                    if (this.parentNode) this.parentNode.insertBefore(newTextNode, this.nextSibling);
                    return newTextNode;
                }
            });
            registerWrapper(OriginalText, Text, document.createTextNode(""));
            scope.wrappers.Text = Text;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            if (!window.DOMTokenList) {
                console.warn("Missing DOMTokenList prototype, please include a " + "compatible classList polyfill such as http://goo.gl/uTcepH.");
                return;
            }
            var unsafeUnwrap = scope.unsafeUnwrap;
            var enqueueMutation = scope.enqueueMutation;

            function getClass(el) {
                return unsafeUnwrap(el).getAttribute("class");
            }

            function enqueueClassAttributeChange(el, oldValue) {
                enqueueMutation(el, "attributes", {
                    name: "class",
                    namespace: null,
                    oldValue: oldValue
                });
            }

            function invalidateClass(el) {
                scope.invalidateRendererBasedOnAttribute(el, "class");
            }

            function changeClass(tokenList, method, args) {
                var ownerElement = tokenList.ownerElement_;
                if (ownerElement == null) {
                    return method.apply(tokenList, args);
                }
                var oldValue = getClass(ownerElement);
                var retv = method.apply(tokenList, args);
                if (getClass(ownerElement) !== oldValue) {
                    enqueueClassAttributeChange(ownerElement, oldValue);
                    invalidateClass(ownerElement);
                }
                return retv;
            }

            var oldAdd = DOMTokenList.prototype.add;
            DOMTokenList.prototype.add = function () {
                changeClass(this, oldAdd, arguments);
            };
            var oldRemove = DOMTokenList.prototype.remove;
            DOMTokenList.prototype.remove = function () {
                changeClass(this, oldRemove, arguments);
            };
            var oldToggle = DOMTokenList.prototype.toggle;
            DOMTokenList.prototype.toggle = function () {
                return changeClass(this, oldToggle, arguments);
            };
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var ChildNodeInterface = scope.ChildNodeInterface;
            var GetElementsByInterface = scope.GetElementsByInterface;
            var Node = scope.wrappers.Node;
            var ParentNodeInterface = scope.ParentNodeInterface;
            var SelectorsInterface = scope.SelectorsInterface;
            var MatchesInterface = scope.MatchesInterface;
            var addWrapNodeListMethod = scope.addWrapNodeListMethod;
            var enqueueMutation = scope.enqueueMutation;
            var mixin = scope.mixin;
            var oneOf = scope.oneOf;
            var registerWrapper = scope.registerWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var wrappers = scope.wrappers;
            var OriginalElement = window.Element;
            var matchesNames = ["matches", "mozMatchesSelector", "msMatchesSelector", "webkitMatchesSelector"].filter(function (name) {
                return OriginalElement.prototype[name];
            });
            var matchesName = matchesNames[0];
            var originalMatches = OriginalElement.prototype[matchesName];

            function invalidateRendererBasedOnAttribute(element, name) {
                var p = element.parentNode;
                if (!p || !p.shadowRoot) return;
                var renderer = scope.getRendererForHost(p);
                if (renderer.dependsOnAttribute(name)) renderer.invalidate();
            }

            function enqueAttributeChange(element, name, oldValue) {
                enqueueMutation(element, "attributes", {
                    name: name,
                    namespace: null,
                    oldValue: oldValue
                });
            }

            var classListTable = new WeakMap();

            function Element(node) {
                Node.call(this, node);
            }

            Element.prototype = Object.create(Node.prototype);
            mixin(Element.prototype, {
                createShadowRoot: function () {
                    var newShadowRoot = new wrappers.ShadowRoot(this);
                    unsafeUnwrap(this).polymerShadowRoot_ = newShadowRoot;
                    var renderer = scope.getRendererForHost(this);
                    renderer.invalidate();
                    return newShadowRoot;
                },
                get shadowRoot() {
                    return unsafeUnwrap(this).polymerShadowRoot_ || null;
                },
                setAttribute: function (name, value) {
                    var oldValue = unsafeUnwrap(this).getAttribute(name);
                    unsafeUnwrap(this).setAttribute(name, value);
                    enqueAttributeChange(this, name, oldValue);
                    invalidateRendererBasedOnAttribute(this, name);
                },
                removeAttribute: function (name) {
                    var oldValue = unsafeUnwrap(this).getAttribute(name);
                    unsafeUnwrap(this).removeAttribute(name);
                    enqueAttributeChange(this, name, oldValue);
                    invalidateRendererBasedOnAttribute(this, name);
                },
                get classList() {
                    var list = classListTable.get(this);
                    if (!list) {
                        list = unsafeUnwrap(this).classList;
                        if (!list) return;
                        list.ownerElement_ = this;
                        classListTable.set(this, list);
                    }
                    return list;
                },
                get className() {
                    return unsafeUnwrap(this).className;
                },
                set className(v) {
                    this.setAttribute("class", v);
                },
                get id() {
                    return unsafeUnwrap(this).id;
                },
                set id(v) {
                    this.setAttribute("id", v);
                }
            });
            matchesNames.forEach(function (name) {
                if (name !== "matches") {
                    Element.prototype[name] = function (selector) {
                        return this.matches(selector);
                    };
                }
            });
            if (OriginalElement.prototype.webkitCreateShadowRoot) {
                Element.prototype.webkitCreateShadowRoot = Element.prototype.createShadowRoot;
            }
            mixin(Element.prototype, ChildNodeInterface);
            mixin(Element.prototype, GetElementsByInterface);
            mixin(Element.prototype, ParentNodeInterface);
            mixin(Element.prototype, SelectorsInterface);
            mixin(Element.prototype, MatchesInterface);
            registerWrapper(OriginalElement, Element, document.createElementNS(null, "x"));
            scope.invalidateRendererBasedOnAttribute = invalidateRendererBasedOnAttribute;
            scope.matchesNames = matchesNames;
            scope.originalMatches = originalMatches;
            scope.wrappers.Element = Element;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var Element = scope.wrappers.Element;
            var defineGetter = scope.defineGetter;
            var enqueueMutation = scope.enqueueMutation;
            var mixin = scope.mixin;
            var nodesWereAdded = scope.nodesWereAdded;
            var nodesWereRemoved = scope.nodesWereRemoved;
            var registerWrapper = scope.registerWrapper;
            var snapshotNodeList = scope.snapshotNodeList;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var unwrap = scope.unwrap;
            var wrap = scope.wrap;
            var wrappers = scope.wrappers;
            var escapeAttrRegExp = /[&\u00A0"]/g;
            var escapeDataRegExp = /[&\u00A0<>]/g;

            function escapeReplace(c) {
                switch (c) {
                    case "&":
                        return "&amp;";

                    case "<":
                        return "&lt;";

                    case ">":
                        return "&gt;";

                    case '"':
                        return "&quot;";

                    case " ":
                        return "&nbsp;";
                }
            }

            function escapeAttr(s) {
                return s.replace(escapeAttrRegExp, escapeReplace);
            }

            function escapeData(s) {
                return s.replace(escapeDataRegExp, escapeReplace);
            }

            function makeSet(arr) {
                var set = {};
                for (var i = 0; i < arr.length; i++) {
                    set[arr[i]] = true;
                }
                return set;
            }

            var voidElements = makeSet(["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
            var plaintextParents = makeSet(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
            var XHTML_NS = "http://www.w3.org/1999/xhtml";

            function needsSelfClosingSlash(node) {
                if (node.namespaceURI !== XHTML_NS) return true;
                var doctype = node.ownerDocument.doctype;
                return doctype && doctype.publicId && doctype.systemId;
            }

            function getOuterHTML(node, parentNode) {
                switch (node.nodeType) {
                    case Node.ELEMENT_NODE:
                        var tagName = node.tagName.toLowerCase();
                        var s = "<" + tagName;
                        var attrs = node.attributes;
                        for (var i = 0, attr; attr = attrs[i]; i++) {
                            s += " " + attr.name + '="' + escapeAttr(attr.value) + '"';
                        }
                        if (voidElements[tagName]) {
                            if (needsSelfClosingSlash(node)) s += "/";
                            return s + ">";
                        }
                        return s + ">" + getInnerHTML(node) + "</" + tagName + ">";

                    case Node.TEXT_NODE:
                        var data = node.data;
                        if (parentNode && plaintextParents[parentNode.localName]) return data;
                        return escapeData(data);

                    case Node.COMMENT_NODE:
                        return "<!--" + node.data + "-->";

                    default:
                        console.error(node);
                        throw new Error("not implemented");
                }
            }

            function getInnerHTML(node) {
                if (node instanceof wrappers.HTMLTemplateElement) node = node.content;
                var s = "";
                for (var child = node.firstChild; child; child = child.nextSibling) {
                    s += getOuterHTML(child, node);
                }
                return s;
            }

            function setInnerHTML(node, value, opt_tagName) {
                var tagName = opt_tagName || "div";
                node.textContent = "";
                var tempElement = unwrap(node.ownerDocument.createElement(tagName));
                tempElement.innerHTML = value;
                var firstChild;
                while (firstChild = tempElement.firstChild) {
                    node.appendChild(wrap(firstChild));
                }
            }

            var oldIe = /MSIE/.test(navigator.userAgent);
            var OriginalHTMLElement = window.HTMLElement;
            var OriginalHTMLTemplateElement = window.HTMLTemplateElement;

            function HTMLElement(node) {
                Element.call(this, node);
            }

            HTMLElement.prototype = Object.create(Element.prototype);
            mixin(HTMLElement.prototype, {
                get innerHTML() {
                    return getInnerHTML(this);
                },
                set innerHTML(value) {
                    if (oldIe && plaintextParents[this.localName]) {
                        this.textContent = value;
                        return;
                    }
                    var removedNodes = snapshotNodeList(this.childNodes);
                    if (this.invalidateShadowRenderer()) {
                        if (this instanceof wrappers.HTMLTemplateElement) setInnerHTML(this.content, value); else setInnerHTML(this, value, this.tagName);
                    } else if (!OriginalHTMLTemplateElement && this instanceof wrappers.HTMLTemplateElement) {
                        setInnerHTML(this.content, value);
                    } else {
                        unsafeUnwrap(this).innerHTML = value;
                    }
                    var addedNodes = snapshotNodeList(this.childNodes);
                    enqueueMutation(this, "childList", {
                        addedNodes: addedNodes,
                        removedNodes: removedNodes
                    });
                    nodesWereRemoved(removedNodes);
                    nodesWereAdded(addedNodes, this);
                },
                get outerHTML() {
                    return getOuterHTML(this, this.parentNode);
                },
                set outerHTML(value) {
                    var p = this.parentNode;
                    if (p) {
                        p.invalidateShadowRenderer();
                        var df = frag(p, value);
                        p.replaceChild(df, this);
                    }
                },
                insertAdjacentHTML: function (position, text) {
                    var contextElement, refNode;
                    switch (String(position).toLowerCase()) {
                        case "beforebegin":
                            contextElement = this.parentNode;
                            refNode = this;
                            break;

                        case "afterend":
                            contextElement = this.parentNode;
                            refNode = this.nextSibling;
                            break;

                        case "afterbegin":
                            contextElement = this;
                            refNode = this.firstChild;
                            break;

                        case "beforeend":
                            contextElement = this;
                            refNode = null;
                            break;

                        default:
                            return;
                    }
                    var df = frag(contextElement, text);
                    contextElement.insertBefore(df, refNode);
                },
                get hidden() {
                    return this.hasAttribute("hidden");
                },
                set hidden(v) {
                    if (v) {
                        this.setAttribute("hidden", "");
                    } else {
                        this.removeAttribute("hidden");
                    }
                }
            });
            function frag(contextElement, html) {
                var p = unwrap(contextElement.cloneNode(false));
                p.innerHTML = html;
                var df = unwrap(document.createDocumentFragment());
                var c;
                while (c = p.firstChild) {
                    df.appendChild(c);
                }
                return wrap(df);
            }

            function getter(name) {
                return function () {
                    scope.renderAllPending();
                    return unsafeUnwrap(this)[name];
                };
            }

            function getterRequiresRendering(name) {
                defineGetter(HTMLElement, name, getter(name));
            }

            ["clientHeight", "clientLeft", "clientTop", "clientWidth", "offsetHeight", "offsetLeft", "offsetTop", "offsetWidth", "scrollHeight", "scrollWidth"].forEach(getterRequiresRendering);
            function getterAndSetterRequiresRendering(name) {
                Object.defineProperty(HTMLElement.prototype, name, {
                    get: getter(name),
                    set: function (v) {
                        scope.renderAllPending();
                        unsafeUnwrap(this)[name] = v;
                    },
                    configurable: true,
                    enumerable: true
                });
            }

            ["scrollLeft", "scrollTop"].forEach(getterAndSetterRequiresRendering);
            function methodRequiresRendering(name) {
                Object.defineProperty(HTMLElement.prototype, name, {
                    value: function () {
                        scope.renderAllPending();
                        return unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments);
                    },
                    configurable: true,
                    enumerable: true
                });
            }

            ["getBoundingClientRect", "getClientRects", "scrollIntoView"].forEach(methodRequiresRendering);
            registerWrapper(OriginalHTMLElement, HTMLElement, document.createElement("b"));
            scope.wrappers.HTMLElement = HTMLElement;
            scope.getInnerHTML = getInnerHTML;
            scope.setInnerHTML = setInnerHTML;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var wrap = scope.wrap;
            var OriginalHTMLCanvasElement = window.HTMLCanvasElement;

            function HTMLCanvasElement(node) {
                HTMLElement.call(this, node);
            }

            HTMLCanvasElement.prototype = Object.create(HTMLElement.prototype);
            mixin(HTMLCanvasElement.prototype, {
                getContext: function () {
                    var context = unsafeUnwrap(this).getContext.apply(unsafeUnwrap(this), arguments);
                    return context && wrap(context);
                }
            });
            registerWrapper(OriginalHTMLCanvasElement, HTMLCanvasElement, document.createElement("canvas"));
            scope.wrappers.HTMLCanvasElement = HTMLCanvasElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var OriginalHTMLContentElement = window.HTMLContentElement;

            function HTMLContentElement(node) {
                HTMLElement.call(this, node);
            }

            HTMLContentElement.prototype = Object.create(HTMLElement.prototype);
            mixin(HTMLContentElement.prototype, {
                constructor: HTMLContentElement,
                get select() {
                    return this.getAttribute("select");
                },
                set select(value) {
                    this.setAttribute("select", value);
                },
                setAttribute: function (n, v) {
                    HTMLElement.prototype.setAttribute.call(this, n, v);
                    if (String(n).toLowerCase() === "select") this.invalidateShadowRenderer(true);
                }
            });
            if (OriginalHTMLContentElement) registerWrapper(OriginalHTMLContentElement, HTMLContentElement);
            scope.wrappers.HTMLContentElement = HTMLContentElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var wrapHTMLCollection = scope.wrapHTMLCollection;
            var unwrap = scope.unwrap;
            var OriginalHTMLFormElement = window.HTMLFormElement;

            function HTMLFormElement(node) {
                HTMLElement.call(this, node);
            }

            HTMLFormElement.prototype = Object.create(HTMLElement.prototype);
            mixin(HTMLFormElement.prototype, {
                get elements() {
                    return wrapHTMLCollection(unwrap(this).elements);
                }
            });
            registerWrapper(OriginalHTMLFormElement, HTMLFormElement, document.createElement("form"));
            scope.wrappers.HTMLFormElement = HTMLFormElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var registerWrapper = scope.registerWrapper;
            var unwrap = scope.unwrap;
            var rewrap = scope.rewrap;
            var OriginalHTMLImageElement = window.HTMLImageElement;

            function HTMLImageElement(node) {
                HTMLElement.call(this, node);
            }

            HTMLImageElement.prototype = Object.create(HTMLElement.prototype);
            registerWrapper(OriginalHTMLImageElement, HTMLImageElement, document.createElement("img"));
            function Image(width, height) {
                if (!(this instanceof Image)) {
                    throw new TypeError("DOM object constructor cannot be called as a function.");
                }
                var node = unwrap(document.createElement("img"));
                HTMLElement.call(this, node);
                rewrap(node, this);
                if (width !== undefined) node.width = width;
                if (height !== undefined) node.height = height;
            }

            Image.prototype = HTMLImageElement.prototype;
            scope.wrappers.HTMLImageElement = HTMLImageElement;
            scope.wrappers.Image = Image;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var mixin = scope.mixin;
            var NodeList = scope.wrappers.NodeList;
            var registerWrapper = scope.registerWrapper;
            var OriginalHTMLShadowElement = window.HTMLShadowElement;

            function HTMLShadowElement(node) {
                HTMLElement.call(this, node);
            }

            HTMLShadowElement.prototype = Object.create(HTMLElement.prototype);
            HTMLShadowElement.prototype.constructor = HTMLShadowElement;
            if (OriginalHTMLShadowElement) registerWrapper(OriginalHTMLShadowElement, HTMLShadowElement);
            scope.wrappers.HTMLShadowElement = HTMLShadowElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var unwrap = scope.unwrap;
            var wrap = scope.wrap;
            var contentTable = new WeakMap();
            var templateContentsOwnerTable = new WeakMap();

            function getTemplateContentsOwner(doc) {
                if (!doc.defaultView) return doc;
                var d = templateContentsOwnerTable.get(doc);
                if (!d) {
                    d = doc.implementation.createHTMLDocument("");
                    while (d.lastChild) {
                        d.removeChild(d.lastChild);
                    }
                    templateContentsOwnerTable.set(doc, d);
                }
                return d;
            }

            function extractContent(templateElement) {
                var doc = getTemplateContentsOwner(templateElement.ownerDocument);
                var df = unwrap(doc.createDocumentFragment());
                var child;
                while (child = templateElement.firstChild) {
                    df.appendChild(child);
                }
                return df;
            }

            var OriginalHTMLTemplateElement = window.HTMLTemplateElement;

            function HTMLTemplateElement(node) {
                HTMLElement.call(this, node);
                if (!OriginalHTMLTemplateElement) {
                    var content = extractContent(node);
                    contentTable.set(this, wrap(content));
                }
            }

            HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);
            mixin(HTMLTemplateElement.prototype, {
                constructor: HTMLTemplateElement,
                get content() {
                    if (OriginalHTMLTemplateElement) return wrap(unsafeUnwrap(this).content);
                    return contentTable.get(this);
                }
            });
            if (OriginalHTMLTemplateElement) registerWrapper(OriginalHTMLTemplateElement, HTMLTemplateElement);
            scope.wrappers.HTMLTemplateElement = HTMLTemplateElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var registerWrapper = scope.registerWrapper;
            var OriginalHTMLMediaElement = window.HTMLMediaElement;
            if (!OriginalHTMLMediaElement) return;
            function HTMLMediaElement(node) {
                HTMLElement.call(this, node);
            }

            HTMLMediaElement.prototype = Object.create(HTMLElement.prototype);
            registerWrapper(OriginalHTMLMediaElement, HTMLMediaElement, document.createElement("audio"));
            scope.wrappers.HTMLMediaElement = HTMLMediaElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLMediaElement = scope.wrappers.HTMLMediaElement;
            var registerWrapper = scope.registerWrapper;
            var unwrap = scope.unwrap;
            var rewrap = scope.rewrap;
            var OriginalHTMLAudioElement = window.HTMLAudioElement;
            if (!OriginalHTMLAudioElement) return;
            function HTMLAudioElement(node) {
                HTMLMediaElement.call(this, node);
            }

            HTMLAudioElement.prototype = Object.create(HTMLMediaElement.prototype);
            registerWrapper(OriginalHTMLAudioElement, HTMLAudioElement, document.createElement("audio"));
            function Audio(src) {
                if (!(this instanceof Audio)) {
                    throw new TypeError("DOM object constructor cannot be called as a function.");
                }
                var node = unwrap(document.createElement("audio"));
                HTMLMediaElement.call(this, node);
                rewrap(node, this);
                node.setAttribute("preload", "auto");
                if (src !== undefined) node.setAttribute("src", src);
            }

            Audio.prototype = HTMLAudioElement.prototype;
            scope.wrappers.HTMLAudioElement = HTMLAudioElement;
            scope.wrappers.Audio = Audio;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var rewrap = scope.rewrap;
            var unwrap = scope.unwrap;
            var wrap = scope.wrap;
            var OriginalHTMLOptionElement = window.HTMLOptionElement;

            function trimText(s) {
                return s.replace(/\s+/g, " ").trim();
            }

            function HTMLOptionElement(node) {
                HTMLElement.call(this, node);
            }

            HTMLOptionElement.prototype = Object.create(HTMLElement.prototype);
            mixin(HTMLOptionElement.prototype, {
                get text() {
                    return trimText(this.textContent);
                },
                set text(value) {
                    this.textContent = trimText(String(value));
                },
                get form() {
                    return wrap(unwrap(this).form);
                }
            });
            registerWrapper(OriginalHTMLOptionElement, HTMLOptionElement, document.createElement("option"));
            function Option(text, value, defaultSelected, selected) {
                if (!(this instanceof Option)) {
                    throw new TypeError("DOM object constructor cannot be called as a function.");
                }
                var node = unwrap(document.createElement("option"));
                HTMLElement.call(this, node);
                rewrap(node, this);
                if (text !== undefined) node.text = text;
                if (value !== undefined) node.setAttribute("value", value);
                if (defaultSelected === true) node.setAttribute("selected", "");
                node.selected = selected === true;
            }

            Option.prototype = HTMLOptionElement.prototype;
            scope.wrappers.HTMLOptionElement = HTMLOptionElement;
            scope.wrappers.Option = Option;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var unwrap = scope.unwrap;
            var wrap = scope.wrap;
            var OriginalHTMLSelectElement = window.HTMLSelectElement;

            function HTMLSelectElement(node) {
                HTMLElement.call(this, node);
            }

            HTMLSelectElement.prototype = Object.create(HTMLElement.prototype);
            mixin(HTMLSelectElement.prototype, {
                add: function (element, before) {
                    if (typeof before === "object") before = unwrap(before);
                    unwrap(this).add(unwrap(element), before);
                },
                remove: function (indexOrNode) {
                    if (indexOrNode === undefined) {
                        HTMLElement.prototype.remove.call(this);
                        return;
                    }
                    if (typeof indexOrNode === "object") indexOrNode = unwrap(indexOrNode);
                    unwrap(this).remove(indexOrNode);
                },
                get form() {
                    return wrap(unwrap(this).form);
                }
            });
            registerWrapper(OriginalHTMLSelectElement, HTMLSelectElement, document.createElement("select"));
            scope.wrappers.HTMLSelectElement = HTMLSelectElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var unwrap = scope.unwrap;
            var wrap = scope.wrap;
            var wrapHTMLCollection = scope.wrapHTMLCollection;
            var OriginalHTMLTableElement = window.HTMLTableElement;

            function HTMLTableElement(node) {
                HTMLElement.call(this, node);
            }

            HTMLTableElement.prototype = Object.create(HTMLElement.prototype);
            mixin(HTMLTableElement.prototype, {
                get caption() {
                    return wrap(unwrap(this).caption);
                },
                createCaption: function () {
                    return wrap(unwrap(this).createCaption());
                },
                get tHead() {
                    return wrap(unwrap(this).tHead);
                },
                createTHead: function () {
                    return wrap(unwrap(this).createTHead());
                },
                createTFoot: function () {
                    return wrap(unwrap(this).createTFoot());
                },
                get tFoot() {
                    return wrap(unwrap(this).tFoot);
                },
                get tBodies() {
                    return wrapHTMLCollection(unwrap(this).tBodies);
                },
                createTBody: function () {
                    return wrap(unwrap(this).createTBody());
                },
                get rows() {
                    return wrapHTMLCollection(unwrap(this).rows);
                },
                insertRow: function (index) {
                    return wrap(unwrap(this).insertRow(index));
                }
            });
            registerWrapper(OriginalHTMLTableElement, HTMLTableElement, document.createElement("table"));
            scope.wrappers.HTMLTableElement = HTMLTableElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var wrapHTMLCollection = scope.wrapHTMLCollection;
            var unwrap = scope.unwrap;
            var wrap = scope.wrap;
            var OriginalHTMLTableSectionElement = window.HTMLTableSectionElement;

            function HTMLTableSectionElement(node) {
                HTMLElement.call(this, node);
            }

            HTMLTableSectionElement.prototype = Object.create(HTMLElement.prototype);
            mixin(HTMLTableSectionElement.prototype, {
                constructor: HTMLTableSectionElement,
                get rows() {
                    return wrapHTMLCollection(unwrap(this).rows);
                },
                insertRow: function (index) {
                    return wrap(unwrap(this).insertRow(index));
                }
            });
            registerWrapper(OriginalHTMLTableSectionElement, HTMLTableSectionElement, document.createElement("thead"));
            scope.wrappers.HTMLTableSectionElement = HTMLTableSectionElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var wrapHTMLCollection = scope.wrapHTMLCollection;
            var unwrap = scope.unwrap;
            var wrap = scope.wrap;
            var OriginalHTMLTableRowElement = window.HTMLTableRowElement;

            function HTMLTableRowElement(node) {
                HTMLElement.call(this, node);
            }

            HTMLTableRowElement.prototype = Object.create(HTMLElement.prototype);
            mixin(HTMLTableRowElement.prototype, {
                get cells() {
                    return wrapHTMLCollection(unwrap(this).cells);
                },
                insertCell: function (index) {
                    return wrap(unwrap(this).insertCell(index));
                }
            });
            registerWrapper(OriginalHTMLTableRowElement, HTMLTableRowElement, document.createElement("tr"));
            scope.wrappers.HTMLTableRowElement = HTMLTableRowElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLContentElement = scope.wrappers.HTMLContentElement;
            var HTMLElement = scope.wrappers.HTMLElement;
            var HTMLShadowElement = scope.wrappers.HTMLShadowElement;
            var HTMLTemplateElement = scope.wrappers.HTMLTemplateElement;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var OriginalHTMLUnknownElement = window.HTMLUnknownElement;

            function HTMLUnknownElement(node) {
                switch (node.localName) {
                    case "content":
                        return new HTMLContentElement(node);

                    case "shadow":
                        return new HTMLShadowElement(node);

                    case "template":
                        return new HTMLTemplateElement(node);
                }
                HTMLElement.call(this, node);
            }

            HTMLUnknownElement.prototype = Object.create(HTMLElement.prototype);
            registerWrapper(OriginalHTMLUnknownElement, HTMLUnknownElement);
            scope.wrappers.HTMLUnknownElement = HTMLUnknownElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var Element = scope.wrappers.Element;
            var HTMLElement = scope.wrappers.HTMLElement;
            var registerWrapper = scope.registerWrapper;
            var defineWrapGetter = scope.defineWrapGetter;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var wrap = scope.wrap;
            var mixin = scope.mixin;
            var SVG_NS = "http://www.w3.org/2000/svg";
            var OriginalSVGElement = window.SVGElement;
            var svgTitleElement = document.createElementNS(SVG_NS, "title");
            if (!("classList" in svgTitleElement)) {
                var descr = Object.getOwnPropertyDescriptor(Element.prototype, "classList");
                Object.defineProperty(HTMLElement.prototype, "classList", descr);
                delete Element.prototype.classList;
            }
            function SVGElement(node) {
                Element.call(this, node);
            }

            SVGElement.prototype = Object.create(Element.prototype);
            mixin(SVGElement.prototype, {
                get ownerSVGElement() {
                    return wrap(unsafeUnwrap(this).ownerSVGElement);
                }
            });
            registerWrapper(OriginalSVGElement, SVGElement, document.createElementNS(SVG_NS, "title"));
            scope.wrappers.SVGElement = SVGElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var unwrap = scope.unwrap;
            var wrap = scope.wrap;
            var OriginalSVGUseElement = window.SVGUseElement;
            var SVG_NS = "http://www.w3.org/2000/svg";
            var gWrapper = wrap(document.createElementNS(SVG_NS, "g"));
            var useElement = document.createElementNS(SVG_NS, "use");
            var SVGGElement = gWrapper.constructor;
            var parentInterfacePrototype = Object.getPrototypeOf(SVGGElement.prototype);
            var parentInterface = parentInterfacePrototype.constructor;

            function SVGUseElement(impl) {
                parentInterface.call(this, impl);
            }

            SVGUseElement.prototype = Object.create(parentInterfacePrototype);
            if ("instanceRoot" in useElement) {
                mixin(SVGUseElement.prototype, {
                    get instanceRoot() {
                        return wrap(unwrap(this).instanceRoot);
                    },
                    get animatedInstanceRoot() {
                        return wrap(unwrap(this).animatedInstanceRoot);
                    }
                });
            }
            registerWrapper(OriginalSVGUseElement, SVGUseElement, useElement);
            scope.wrappers.SVGUseElement = SVGUseElement;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var EventTarget = scope.wrappers.EventTarget;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var wrap = scope.wrap;
            var OriginalSVGElementInstance = window.SVGElementInstance;
            if (!OriginalSVGElementInstance) return;
            function SVGElementInstance(impl) {
                EventTarget.call(this, impl);
            }

            SVGElementInstance.prototype = Object.create(EventTarget.prototype);
            mixin(SVGElementInstance.prototype, {
                get correspondingElement() {
                    return wrap(unsafeUnwrap(this).correspondingElement);
                },
                get correspondingUseElement() {
                    return wrap(unsafeUnwrap(this).correspondingUseElement);
                },
                get parentNode() {
                    return wrap(unsafeUnwrap(this).parentNode);
                },
                get childNodes() {
                    throw new Error("Not implemented");
                },
                get firstChild() {
                    return wrap(unsafeUnwrap(this).firstChild);
                },
                get lastChild() {
                    return wrap(unsafeUnwrap(this).lastChild);
                },
                get previousSibling() {
                    return wrap(unsafeUnwrap(this).previousSibling);
                },
                get nextSibling() {
                    return wrap(unsafeUnwrap(this).nextSibling);
                }
            });
            registerWrapper(OriginalSVGElementInstance, SVGElementInstance);
            scope.wrappers.SVGElementInstance = SVGElementInstance;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var setWrapper = scope.setWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var unwrap = scope.unwrap;
            var unwrapIfNeeded = scope.unwrapIfNeeded;
            var wrap = scope.wrap;
            var OriginalCanvasRenderingContext2D = window.CanvasRenderingContext2D;

            function CanvasRenderingContext2D(impl) {
                setWrapper(impl, this);
            }

            mixin(CanvasRenderingContext2D.prototype, {
                get canvas() {
                    return wrap(unsafeUnwrap(this).canvas);
                },
                drawImage: function () {
                    arguments[0] = unwrapIfNeeded(arguments[0]);
                    unsafeUnwrap(this).drawImage.apply(unsafeUnwrap(this), arguments);
                },
                createPattern: function () {
                    arguments[0] = unwrap(arguments[0]);
                    return unsafeUnwrap(this).createPattern.apply(unsafeUnwrap(this), arguments);
                }
            });
            registerWrapper(OriginalCanvasRenderingContext2D, CanvasRenderingContext2D, document.createElement("canvas").getContext("2d"));
            scope.wrappers.CanvasRenderingContext2D = CanvasRenderingContext2D;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var setWrapper = scope.setWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var unwrapIfNeeded = scope.unwrapIfNeeded;
            var wrap = scope.wrap;
            var OriginalWebGLRenderingContext = window.WebGLRenderingContext;
            if (!OriginalWebGLRenderingContext) return;
            function WebGLRenderingContext(impl) {
                setWrapper(impl, this);
            }

            mixin(WebGLRenderingContext.prototype, {
                get canvas() {
                    return wrap(unsafeUnwrap(this).canvas);
                },
                texImage2D: function () {
                    arguments[5] = unwrapIfNeeded(arguments[5]);
                    unsafeUnwrap(this).texImage2D.apply(unsafeUnwrap(this), arguments);
                },
                texSubImage2D: function () {
                    arguments[6] = unwrapIfNeeded(arguments[6]);
                    unsafeUnwrap(this).texSubImage2D.apply(unsafeUnwrap(this), arguments);
                }
            });
            var instanceProperties = /WebKit/.test(navigator.userAgent) ? {
                drawingBufferHeight: null,
                drawingBufferWidth: null
            } : {};
            registerWrapper(OriginalWebGLRenderingContext, WebGLRenderingContext, instanceProperties);
            scope.wrappers.WebGLRenderingContext = WebGLRenderingContext;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var Node = scope.wrappers.Node;
            var GetElementsByInterface = scope.GetElementsByInterface;
            var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;
            var ParentNodeInterface = scope.ParentNodeInterface;
            var SelectorsInterface = scope.SelectorsInterface;
            var mixin = scope.mixin;
            var registerObject = scope.registerObject;
            var registerWrapper = scope.registerWrapper;
            var OriginalDocumentFragment = window.DocumentFragment;

            function DocumentFragment(node) {
                Node.call(this, node);
            }

            DocumentFragment.prototype = Object.create(Node.prototype);
            mixin(DocumentFragment.prototype, ParentNodeInterface);
            mixin(DocumentFragment.prototype, SelectorsInterface);
            mixin(DocumentFragment.prototype, GetElementsByInterface);
            mixin(DocumentFragment.prototype, NonElementParentNodeInterface);
            registerWrapper(OriginalDocumentFragment, DocumentFragment, document.createDocumentFragment());
            scope.wrappers.DocumentFragment = DocumentFragment;
            var Comment = registerObject(document.createComment(""));
            scope.wrappers.Comment = Comment;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var DocumentFragment = scope.wrappers.DocumentFragment;
            var TreeScope = scope.TreeScope;
            var elementFromPoint = scope.elementFromPoint;
            var getInnerHTML = scope.getInnerHTML;
            var getTreeScope = scope.getTreeScope;
            var mixin = scope.mixin;
            var rewrap = scope.rewrap;
            var setInnerHTML = scope.setInnerHTML;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var unwrap = scope.unwrap;
            var shadowHostTable = new WeakMap();
            var nextOlderShadowTreeTable = new WeakMap();

            function ShadowRoot(hostWrapper) {
                var node = unwrap(unsafeUnwrap(hostWrapper).ownerDocument.createDocumentFragment());
                DocumentFragment.call(this, node);
                rewrap(node, this);
                var oldShadowRoot = hostWrapper.shadowRoot;
                nextOlderShadowTreeTable.set(this, oldShadowRoot);
                this.treeScope_ = new TreeScope(this, getTreeScope(oldShadowRoot || hostWrapper));
                shadowHostTable.set(this, hostWrapper);
            }

            ShadowRoot.prototype = Object.create(DocumentFragment.prototype);
            mixin(ShadowRoot.prototype, {
                constructor: ShadowRoot,
                get innerHTML() {
                    return getInnerHTML(this);
                },
                set innerHTML(value) {
                    setInnerHTML(this, value);
                    this.invalidateShadowRenderer();
                },
                get olderShadowRoot() {
                    return nextOlderShadowTreeTable.get(this) || null;
                },
                get host() {
                    return shadowHostTable.get(this) || null;
                },
                invalidateShadowRenderer: function () {
                    return shadowHostTable.get(this).invalidateShadowRenderer();
                },
                elementFromPoint: function (x, y) {
                    return elementFromPoint(this, this.ownerDocument, x, y);
                }
            });
            scope.wrappers.ShadowRoot = ShadowRoot;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var registerWrapper = scope.registerWrapper;
            var setWrapper = scope.setWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var unwrap = scope.unwrap;
            var unwrapIfNeeded = scope.unwrapIfNeeded;
            var wrap = scope.wrap;
            var getTreeScope = scope.getTreeScope;
            var OriginalRange = window.Range;
            var ShadowRoot = scope.wrappers.ShadowRoot;

            function getHost(node) {
                var root = getTreeScope(node).root;
                if (root instanceof ShadowRoot) {
                    return root.host;
                }
                return null;
            }

            function hostNodeToShadowNode(refNode, offset) {
                if (refNode.shadowRoot) {
                    offset = Math.min(refNode.childNodes.length - 1, offset);
                    var child = refNode.childNodes[offset];
                    if (child) {
                        var insertionPoint = scope.getDestinationInsertionPoints(child);
                        if (insertionPoint.length > 0) {
                            var parentNode = insertionPoint[0].parentNode;
                            if (parentNode.nodeType == Node.ELEMENT_NODE) {
                                refNode = parentNode;
                            }
                        }
                    }
                }
                return refNode;
            }

            function shadowNodeToHostNode(node) {
                node = wrap(node);
                return getHost(node) || node;
            }

            function Range(impl) {
                setWrapper(impl, this);
            }

            Range.prototype = {
                get startContainer() {
                    return shadowNodeToHostNode(unsafeUnwrap(this).startContainer);
                },
                get endContainer() {
                    return shadowNodeToHostNode(unsafeUnwrap(this).endContainer);
                },
                get commonAncestorContainer() {
                    return shadowNodeToHostNode(unsafeUnwrap(this).commonAncestorContainer);
                },
                setStart: function (refNode, offset) {
                    refNode = hostNodeToShadowNode(refNode, offset);
                    unsafeUnwrap(this).setStart(unwrapIfNeeded(refNode), offset);
                },
                setEnd: function (refNode, offset) {
                    refNode = hostNodeToShadowNode(refNode, offset);
                    unsafeUnwrap(this).setEnd(unwrapIfNeeded(refNode), offset);
                },
                setStartBefore: function (refNode) {
                    unsafeUnwrap(this).setStartBefore(unwrapIfNeeded(refNode));
                },
                setStartAfter: function (refNode) {
                    unsafeUnwrap(this).setStartAfter(unwrapIfNeeded(refNode));
                },
                setEndBefore: function (refNode) {
                    unsafeUnwrap(this).setEndBefore(unwrapIfNeeded(refNode));
                },
                setEndAfter: function (refNode) {
                    unsafeUnwrap(this).setEndAfter(unwrapIfNeeded(refNode));
                },
                selectNode: function (refNode) {
                    unsafeUnwrap(this).selectNode(unwrapIfNeeded(refNode));
                },
                selectNodeContents: function (refNode) {
                    unsafeUnwrap(this).selectNodeContents(unwrapIfNeeded(refNode));
                },
                compareBoundaryPoints: function (how, sourceRange) {
                    return unsafeUnwrap(this).compareBoundaryPoints(how, unwrap(sourceRange));
                },
                extractContents: function () {
                    return wrap(unsafeUnwrap(this).extractContents());
                },
                cloneContents: function () {
                    return wrap(unsafeUnwrap(this).cloneContents());
                },
                insertNode: function (node) {
                    unsafeUnwrap(this).insertNode(unwrapIfNeeded(node));
                },
                surroundContents: function (newParent) {
                    unsafeUnwrap(this).surroundContents(unwrapIfNeeded(newParent));
                },
                cloneRange: function () {
                    return wrap(unsafeUnwrap(this).cloneRange());
                },
                isPointInRange: function (node, offset) {
                    return unsafeUnwrap(this).isPointInRange(unwrapIfNeeded(node), offset);
                },
                comparePoint: function (node, offset) {
                    return unsafeUnwrap(this).comparePoint(unwrapIfNeeded(node), offset);
                },
                intersectsNode: function (node) {
                    return unsafeUnwrap(this).intersectsNode(unwrapIfNeeded(node));
                },
                toString: function () {
                    return unsafeUnwrap(this).toString();
                }
            };
            if (OriginalRange.prototype.createContextualFragment) {
                Range.prototype.createContextualFragment = function (html) {
                    return wrap(unsafeUnwrap(this).createContextualFragment(html));
                };
            }
            registerWrapper(window.Range, Range, document.createRange());
            scope.wrappers.Range = Range;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var Element = scope.wrappers.Element;
            var HTMLContentElement = scope.wrappers.HTMLContentElement;
            var HTMLShadowElement = scope.wrappers.HTMLShadowElement;
            var Node = scope.wrappers.Node;
            var ShadowRoot = scope.wrappers.ShadowRoot;
            var assert = scope.assert;
            var getTreeScope = scope.getTreeScope;
            var mixin = scope.mixin;
            var oneOf = scope.oneOf;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var unwrap = scope.unwrap;
            var wrap = scope.wrap;
            var ArraySplice = scope.ArraySplice;

            function updateWrapperUpAndSideways(wrapper) {
                wrapper.previousSibling_ = wrapper.previousSibling;
                wrapper.nextSibling_ = wrapper.nextSibling;
                wrapper.parentNode_ = wrapper.parentNode;
            }

            function updateWrapperDown(wrapper) {
                wrapper.firstChild_ = wrapper.firstChild;
                wrapper.lastChild_ = wrapper.lastChild;
            }

            function updateAllChildNodes(parentNodeWrapper) {
                assert(parentNodeWrapper instanceof Node);
                for (var childWrapper = parentNodeWrapper.firstChild; childWrapper; childWrapper = childWrapper.nextSibling) {
                    updateWrapperUpAndSideways(childWrapper);
                }
                updateWrapperDown(parentNodeWrapper);
            }

            function insertBefore(parentNodeWrapper, newChildWrapper, refChildWrapper) {
                var parentNode = unwrap(parentNodeWrapper);
                var newChild = unwrap(newChildWrapper);
                var refChild = refChildWrapper ? unwrap(refChildWrapper) : null;
                remove(newChildWrapper);
                updateWrapperUpAndSideways(newChildWrapper);
                if (!refChildWrapper) {
                    parentNodeWrapper.lastChild_ = parentNodeWrapper.lastChild;
                    if (parentNodeWrapper.lastChild === parentNodeWrapper.firstChild) parentNodeWrapper.firstChild_ = parentNodeWrapper.firstChild;
                    var lastChildWrapper = wrap(parentNode.lastChild);
                    if (lastChildWrapper) lastChildWrapper.nextSibling_ = lastChildWrapper.nextSibling;
                } else {
                    if (parentNodeWrapper.firstChild === refChildWrapper) parentNodeWrapper.firstChild_ = refChildWrapper;
                    refChildWrapper.previousSibling_ = refChildWrapper.previousSibling;
                }
                scope.originalInsertBefore.call(parentNode, newChild, refChild);
            }

            function remove(nodeWrapper) {
                var node = unwrap(nodeWrapper);
                var parentNode = node.parentNode;
                if (!parentNode) return;
                var parentNodeWrapper = wrap(parentNode);
                updateWrapperUpAndSideways(nodeWrapper);
                if (nodeWrapper.previousSibling) nodeWrapper.previousSibling.nextSibling_ = nodeWrapper;
                if (nodeWrapper.nextSibling) nodeWrapper.nextSibling.previousSibling_ = nodeWrapper;
                if (parentNodeWrapper.lastChild === nodeWrapper) parentNodeWrapper.lastChild_ = nodeWrapper;
                if (parentNodeWrapper.firstChild === nodeWrapper) parentNodeWrapper.firstChild_ = nodeWrapper;
                scope.originalRemoveChild.call(parentNode, node);
            }

            var distributedNodesTable = new WeakMap();
            var destinationInsertionPointsTable = new WeakMap();
            var rendererForHostTable = new WeakMap();

            function resetDistributedNodes(insertionPoint) {
                distributedNodesTable.set(insertionPoint, []);
            }

            function getDistributedNodes(insertionPoint) {
                var rv = distributedNodesTable.get(insertionPoint);
                if (!rv) distributedNodesTable.set(insertionPoint, rv = []);
                return rv;
            }

            function getChildNodesSnapshot(node) {
                var result = [], i = 0;
                for (var child = node.firstChild; child; child = child.nextSibling) {
                    result[i++] = child;
                }
                return result;
            }

            var request = oneOf(window, ["requestAnimationFrame", "mozRequestAnimationFrame", "webkitRequestAnimationFrame", "setTimeout"]);
            var pendingDirtyRenderers = [];
            var renderTimer;

            function renderAllPending() {
                for (var i = 0; i < pendingDirtyRenderers.length; i++) {
                    var renderer = pendingDirtyRenderers[i];
                    var parentRenderer = renderer.parentRenderer;
                    if (parentRenderer && parentRenderer.dirty) continue;
                    renderer.render();
                }
                pendingDirtyRenderers = [];
            }

            function handleRequestAnimationFrame() {
                renderTimer = null;
                renderAllPending();
            }

            function getRendererForHost(host) {
                var renderer = rendererForHostTable.get(host);
                if (!renderer) {
                    renderer = new ShadowRenderer(host);
                    rendererForHostTable.set(host, renderer);
                }
                return renderer;
            }

            function getShadowRootAncestor(node) {
                var root = getTreeScope(node).root;
                if (root instanceof ShadowRoot) return root;
                return null;
            }

            function getRendererForShadowRoot(shadowRoot) {
                return getRendererForHost(shadowRoot.host);
            }

            var spliceDiff = new ArraySplice();
            spliceDiff.equals = function (renderNode, rawNode) {
                return unwrap(renderNode.node) === rawNode;
            };
            function RenderNode(node) {
                this.skip = false;
                this.node = node;
                this.childNodes = [];
            }

            RenderNode.prototype = {
                append: function (node) {
                    var rv = new RenderNode(node);
                    this.childNodes.push(rv);
                    return rv;
                },
                sync: function (opt_added) {
                    if (this.skip) return;
                    var nodeWrapper = this.node;
                    var newChildren = this.childNodes;
                    var oldChildren = getChildNodesSnapshot(unwrap(nodeWrapper));
                    var added = opt_added || new WeakMap();
                    var splices = spliceDiff.calculateSplices(newChildren, oldChildren);
                    var newIndex = 0, oldIndex = 0;
                    var lastIndex = 0;
                    for (var i = 0; i < splices.length; i++) {
                        var splice = splices[i];
                        for (; lastIndex < splice.index; lastIndex++) {
                            oldIndex++;
                            newChildren[newIndex++].sync(added);
                        }
                        var removedCount = splice.removed.length;
                        for (var j = 0; j < removedCount; j++) {
                            var wrapper = wrap(oldChildren[oldIndex++]);
                            if (!added.get(wrapper)) remove(wrapper);
                        }
                        var addedCount = splice.addedCount;
                        var refNode = oldChildren[oldIndex] && wrap(oldChildren[oldIndex]);
                        for (var j = 0; j < addedCount; j++) {
                            var newChildRenderNode = newChildren[newIndex++];
                            var newChildWrapper = newChildRenderNode.node;
                            insertBefore(nodeWrapper, newChildWrapper, refNode);
                            added.set(newChildWrapper, true);
                            newChildRenderNode.sync(added);
                        }
                        lastIndex += addedCount;
                    }
                    for (var i = lastIndex; i < newChildren.length; i++) {
                        newChildren[i].sync(added);
                    }
                }
            };
            function ShadowRenderer(host) {
                this.host = host;
                this.dirty = false;
                this.invalidateAttributes();
                this.associateNode(host);
            }

            ShadowRenderer.prototype = {
                render: function (opt_renderNode) {
                    if (!this.dirty) return;
                    this.invalidateAttributes();
                    var host = this.host;
                    this.distribution(host);
                    var renderNode = opt_renderNode || new RenderNode(host);
                    this.buildRenderTree(renderNode, host);
                    var topMostRenderer = !opt_renderNode;
                    if (topMostRenderer) renderNode.sync();
                    this.dirty = false;
                },
                get parentRenderer() {
                    return getTreeScope(this.host).renderer;
                },
                invalidate: function () {
                    if (!this.dirty) {
                        this.dirty = true;
                        var parentRenderer = this.parentRenderer;
                        if (parentRenderer) parentRenderer.invalidate();
                        pendingDirtyRenderers.push(this);
                        if (renderTimer) return;
                        renderTimer = window[request](handleRequestAnimationFrame, 0);
                    }
                },
                distribution: function (root) {
                    this.resetAllSubtrees(root);
                    this.distributionResolution(root);
                },
                resetAll: function (node) {
                    if (isInsertionPoint(node)) resetDistributedNodes(node); else resetDestinationInsertionPoints(node);
                    this.resetAllSubtrees(node);
                },
                resetAllSubtrees: function (node) {
                    for (var child = node.firstChild; child; child = child.nextSibling) {
                        this.resetAll(child);
                    }
                    if (node.shadowRoot) this.resetAll(node.shadowRoot);
                    if (node.olderShadowRoot) this.resetAll(node.olderShadowRoot);
                },
                distributionResolution: function (node) {
                    if (isShadowHost(node)) {
                        var shadowHost = node;
                        var pool = poolPopulation(shadowHost);
                        var shadowTrees = getShadowTrees(shadowHost);
                        for (var i = 0; i < shadowTrees.length; i++) {
                            this.poolDistribution(shadowTrees[i], pool);
                        }
                        for (var i = shadowTrees.length - 1; i >= 0; i--) {
                            var shadowTree = shadowTrees[i];
                            var shadow = getShadowInsertionPoint(shadowTree);
                            if (shadow) {
                                var olderShadowRoot = shadowTree.olderShadowRoot;
                                if (olderShadowRoot) {
                                    pool = poolPopulation(olderShadowRoot);
                                }
                                for (var j = 0; j < pool.length; j++) {
                                    destributeNodeInto(pool[j], shadow);
                                }
                            }
                            this.distributionResolution(shadowTree);
                        }
                    }
                    for (var child = node.firstChild; child; child = child.nextSibling) {
                        this.distributionResolution(child);
                    }
                },
                poolDistribution: function (node, pool) {
                    if (node instanceof HTMLShadowElement) return;
                    if (node instanceof HTMLContentElement) {
                        var content = node;
                        this.updateDependentAttributes(content.getAttribute("select"));
                        var anyDistributed = false;
                        for (var i = 0; i < pool.length; i++) {
                            var node = pool[i];
                            if (!node) continue;
                            if (matches(node, content)) {
                                destributeNodeInto(node, content);
                                pool[i] = undefined;
                                anyDistributed = true;
                            }
                        }
                        if (!anyDistributed) {
                            for (var child = content.firstChild; child; child = child.nextSibling) {
                                destributeNodeInto(child, content);
                            }
                        }
                        return;
                    }
                    for (var child = node.firstChild; child; child = child.nextSibling) {
                        this.poolDistribution(child, pool);
                    }
                },
                buildRenderTree: function (renderNode, node) {
                    var children = this.compose(node);
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        var childRenderNode = renderNode.append(child);
                        this.buildRenderTree(childRenderNode, child);
                    }
                    if (isShadowHost(node)) {
                        var renderer = getRendererForHost(node);
                        renderer.dirty = false;
                    }
                },
                compose: function (node) {
                    var children = [];
                    var p = node.shadowRoot || node;
                    for (var child = p.firstChild; child; child = child.nextSibling) {
                        if (isInsertionPoint(child)) {
                            this.associateNode(p);
                            var distributedNodes = getDistributedNodes(child);
                            for (var j = 0; j < distributedNodes.length; j++) {
                                var distributedNode = distributedNodes[j];
                                if (isFinalDestination(child, distributedNode)) children.push(distributedNode);
                            }
                        } else {
                            children.push(child);
                        }
                    }
                    return children;
                },
                invalidateAttributes: function () {
                    this.attributes = Object.create(null);
                },
                updateDependentAttributes: function (selector) {
                    if (!selector) return;
                    var attributes = this.attributes;
                    if (/\.\w+/.test(selector)) attributes["class"] = true;
                    if (/#\w+/.test(selector)) attributes["id"] = true;
                    selector.replace(/\[\s*([^\s=\|~\]]+)/g, function (_, name) {
                        attributes[name] = true;
                    });
                },
                dependsOnAttribute: function (name) {
                    return this.attributes[name];
                },
                associateNode: function (node) {
                    unsafeUnwrap(node).polymerShadowRenderer_ = this;
                }
            };
            function poolPopulation(node) {
                var pool = [];
                for (var child = node.firstChild; child; child = child.nextSibling) {
                    if (isInsertionPoint(child)) {
                        pool.push.apply(pool, getDistributedNodes(child));
                    } else {
                        pool.push(child);
                    }
                }
                return pool;
            }

            function getShadowInsertionPoint(node) {
                if (node instanceof HTMLShadowElement) return node;
                if (node instanceof HTMLContentElement) return null;
                for (var child = node.firstChild; child; child = child.nextSibling) {
                    var res = getShadowInsertionPoint(child);
                    if (res) return res;
                }
                return null;
            }

            function destributeNodeInto(child, insertionPoint) {
                getDistributedNodes(insertionPoint).push(child);
                var points = destinationInsertionPointsTable.get(child);
                if (!points) destinationInsertionPointsTable.set(child, [insertionPoint]); else points.push(insertionPoint);
            }

            function getDestinationInsertionPoints(node) {
                return destinationInsertionPointsTable.get(node);
            }

            function resetDestinationInsertionPoints(node) {
                destinationInsertionPointsTable.set(node, undefined);
            }

            var selectorStartCharRe = /^(:not\()?[*.#[a-zA-Z_|]/;

            function matches(node, contentElement) {
                var select = contentElement.getAttribute("select");
                if (!select) return true;
                select = select.trim();
                if (!select) return true;
                if (!(node instanceof Element)) return false;
                if (!selectorStartCharRe.test(select)) return false;
                try {
                    return node.matches(select);
                } catch (ex) {
                    return false;
                }
            }

            function isFinalDestination(insertionPoint, node) {
                var points = getDestinationInsertionPoints(node);
                return points && points[points.length - 1] === insertionPoint;
            }

            function isInsertionPoint(node) {
                return node instanceof HTMLContentElement || node instanceof HTMLShadowElement;
            }

            function isShadowHost(shadowHost) {
                return shadowHost.shadowRoot;
            }

            function getShadowTrees(host) {
                var trees = [];
                for (var tree = host.shadowRoot; tree; tree = tree.olderShadowRoot) {
                    trees.push(tree);
                }
                return trees;
            }

            function render(host) {
                new ShadowRenderer(host).render();
            }

            Node.prototype.invalidateShadowRenderer = function (force) {
                var renderer = unsafeUnwrap(this).polymerShadowRenderer_;
                if (renderer) {
                    renderer.invalidate();
                    return true;
                }
                return false;
            };
            HTMLContentElement.prototype.getDistributedNodes = HTMLShadowElement.prototype.getDistributedNodes = function () {
                renderAllPending();
                return getDistributedNodes(this);
            };
            Element.prototype.getDestinationInsertionPoints = function () {
                renderAllPending();
                return getDestinationInsertionPoints(this) || [];
            };
            HTMLContentElement.prototype.nodeIsInserted_ = HTMLShadowElement.prototype.nodeIsInserted_ = function () {
                this.invalidateShadowRenderer();
                var shadowRoot = getShadowRootAncestor(this);
                var renderer;
                if (shadowRoot) renderer = getRendererForShadowRoot(shadowRoot);
                unsafeUnwrap(this).polymerShadowRenderer_ = renderer;
                if (renderer) renderer.invalidate();
            };
            scope.getRendererForHost = getRendererForHost;
            scope.getShadowTrees = getShadowTrees;
            scope.renderAllPending = renderAllPending;
            scope.getDestinationInsertionPoints = getDestinationInsertionPoints;
            scope.visual = {
                insertBefore: insertBefore,
                remove: remove
            };
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var HTMLElement = scope.wrappers.HTMLElement;
            var assert = scope.assert;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var unwrap = scope.unwrap;
            var wrap = scope.wrap;
            var elementsWithFormProperty = ["HTMLButtonElement", "HTMLFieldSetElement", "HTMLInputElement", "HTMLKeygenElement", "HTMLLabelElement", "HTMLLegendElement", "HTMLObjectElement", "HTMLOutputElement", "HTMLTextAreaElement"];

            function createWrapperConstructor(name) {
                if (!window[name]) return;
                assert(!scope.wrappers[name]);
                var GeneratedWrapper = function (node) {
                    HTMLElement.call(this, node);
                };
                GeneratedWrapper.prototype = Object.create(HTMLElement.prototype);
                mixin(GeneratedWrapper.prototype, {
                    get form() {
                        return wrap(unwrap(this).form);
                    }
                });
                registerWrapper(window[name], GeneratedWrapper, document.createElement(name.slice(4, -7)));
                scope.wrappers[name] = GeneratedWrapper;
            }

            elementsWithFormProperty.forEach(createWrapperConstructor);
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var registerWrapper = scope.registerWrapper;
            var setWrapper = scope.setWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var unwrap = scope.unwrap;
            var unwrapIfNeeded = scope.unwrapIfNeeded;
            var wrap = scope.wrap;
            var OriginalSelection = window.Selection;

            function Selection(impl) {
                setWrapper(impl, this);
            }

            Selection.prototype = {
                get anchorNode() {
                    return wrap(unsafeUnwrap(this).anchorNode);
                },
                get focusNode() {
                    return wrap(unsafeUnwrap(this).focusNode);
                },
                addRange: function (range) {
                    unsafeUnwrap(this).addRange(unwrapIfNeeded(range));
                },
                collapse: function (node, index) {
                    unsafeUnwrap(this).collapse(unwrapIfNeeded(node), index);
                },
                containsNode: function (node, allowPartial) {
                    return unsafeUnwrap(this).containsNode(unwrapIfNeeded(node), allowPartial);
                },
                getRangeAt: function (index) {
                    return wrap(unsafeUnwrap(this).getRangeAt(index));
                },
                removeRange: function (range) {
                    unsafeUnwrap(this).removeRange(unwrap(range));
                },
                selectAllChildren: function (node) {
                    unsafeUnwrap(this).selectAllChildren(unwrapIfNeeded(node));
                },
                toString: function () {
                    return unsafeUnwrap(this).toString();
                }
            };
            if (OriginalSelection.prototype.extend) {
                Selection.prototype.extend = function (node, offset) {
                    unsafeUnwrap(this).extend(unwrapIfNeeded(node), offset);
                };
            }
            registerWrapper(window.Selection, Selection, window.getSelection());
            scope.wrappers.Selection = Selection;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var registerWrapper = scope.registerWrapper;
            var setWrapper = scope.setWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var unwrapIfNeeded = scope.unwrapIfNeeded;
            var wrap = scope.wrap;
            var OriginalTreeWalker = window.TreeWalker;

            function TreeWalker(impl) {
                setWrapper(impl, this);
            }

            TreeWalker.prototype = {
                get root() {
                    return wrap(unsafeUnwrap(this).root);
                },
                get currentNode() {
                    return wrap(unsafeUnwrap(this).currentNode);
                },
                set currentNode(node) {
                    unsafeUnwrap(this).currentNode = unwrapIfNeeded(node);
                },
                get filter() {
                    return unsafeUnwrap(this).filter;
                },
                parentNode: function () {
                    return wrap(unsafeUnwrap(this).parentNode());
                },
                firstChild: function () {
                    return wrap(unsafeUnwrap(this).firstChild());
                },
                lastChild: function () {
                    return wrap(unsafeUnwrap(this).lastChild());
                },
                previousSibling: function () {
                    return wrap(unsafeUnwrap(this).previousSibling());
                },
                previousNode: function () {
                    return wrap(unsafeUnwrap(this).previousNode());
                },
                nextNode: function () {
                    return wrap(unsafeUnwrap(this).nextNode());
                }
            };
            registerWrapper(OriginalTreeWalker, TreeWalker);
            scope.wrappers.TreeWalker = TreeWalker;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var GetElementsByInterface = scope.GetElementsByInterface;
            var Node = scope.wrappers.Node;
            var ParentNodeInterface = scope.ParentNodeInterface;
            var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;
            var Selection = scope.wrappers.Selection;
            var SelectorsInterface = scope.SelectorsInterface;
            var ShadowRoot = scope.wrappers.ShadowRoot;
            var TreeScope = scope.TreeScope;
            var cloneNode = scope.cloneNode;
            var defineWrapGetter = scope.defineWrapGetter;
            var elementFromPoint = scope.elementFromPoint;
            var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;
            var matchesNames = scope.matchesNames;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var renderAllPending = scope.renderAllPending;
            var rewrap = scope.rewrap;
            var setWrapper = scope.setWrapper;
            var unsafeUnwrap = scope.unsafeUnwrap;
            var unwrap = scope.unwrap;
            var wrap = scope.wrap;
            var wrapEventTargetMethods = scope.wrapEventTargetMethods;
            var wrapNodeList = scope.wrapNodeList;
            var implementationTable = new WeakMap();

            function Document(node) {
                Node.call(this, node);
                this.treeScope_ = new TreeScope(this, null);
            }

            Document.prototype = Object.create(Node.prototype);
            defineWrapGetter(Document, "documentElement");
            defineWrapGetter(Document, "body");
            defineWrapGetter(Document, "head");
            function wrapMethod(name) {
                var original = document[name];
                Document.prototype[name] = function () {
                    return wrap(original.apply(unsafeUnwrap(this), arguments));
                };
            }

            ["createComment", "createDocumentFragment", "createElement", "createElementNS", "createEvent", "createEventNS", "createRange", "createTextNode"].forEach(wrapMethod);
            var originalAdoptNode = document.adoptNode;

            function adoptNodeNoRemove(node, doc) {
                originalAdoptNode.call(unsafeUnwrap(doc), unwrap(node));
                adoptSubtree(node, doc);
            }

            function adoptSubtree(node, doc) {
                if (node.shadowRoot) doc.adoptNode(node.shadowRoot);
                if (node instanceof ShadowRoot) adoptOlderShadowRoots(node, doc);
                for (var child = node.firstChild; child; child = child.nextSibling) {
                    adoptSubtree(child, doc);
                }
            }

            function adoptOlderShadowRoots(shadowRoot, doc) {
                var oldShadowRoot = shadowRoot.olderShadowRoot;
                if (oldShadowRoot) doc.adoptNode(oldShadowRoot);
            }

            var originalGetSelection = document.getSelection;
            mixin(Document.prototype, {
                adoptNode: function (node) {
                    if (node.parentNode) node.parentNode.removeChild(node);
                    adoptNodeNoRemove(node, this);
                    return node;
                },
                elementFromPoint: function (x, y) {
                    return elementFromPoint(this, this, x, y);
                },
                importNode: function (node, deep) {
                    return cloneNode(node, deep, unsafeUnwrap(this));
                },
                getSelection: function () {
                    renderAllPending();
                    return new Selection(originalGetSelection.call(unwrap(this)));
                },
                getElementsByName: function (name) {
                    return SelectorsInterface.querySelectorAll.call(this, "[name=" + JSON.stringify(String(name)) + "]");
                }
            });
            var originalCreateTreeWalker = document.createTreeWalker;
            var TreeWalkerWrapper = scope.wrappers.TreeWalker;
            Document.prototype.createTreeWalker = function (root, whatToShow, filter, expandEntityReferences) {
                var newFilter = null;
                if (filter) {
                    if (filter.acceptNode && typeof filter.acceptNode === "function") {
                        newFilter = {
                            acceptNode: function (node) {
                                return filter.acceptNode(wrap(node));
                            }
                        };
                    } else if (typeof filter === "function") {
                        newFilter = function (node) {
                            return filter(wrap(node));
                        };
                    }
                }
                return new TreeWalkerWrapper(originalCreateTreeWalker.call(unwrap(this), unwrap(root), whatToShow, newFilter, expandEntityReferences));
            };
            if (document.registerElement) {
                var originalRegisterElement = document.registerElement;
                Document.prototype.registerElement = function (tagName, object) {
                    var prototype, extendsOption;
                    if (object !== undefined) {
                        prototype = object.prototype;
                        extendsOption = object.extends;
                    }
                    if (!prototype) prototype = Object.create(HTMLElement.prototype);
                    if (scope.nativePrototypeTable.get(prototype)) {
                        throw new Error("NotSupportedError");
                    }
                    var proto = Object.getPrototypeOf(prototype);
                    var nativePrototype;
                    var prototypes = [];
                    while (proto) {
                        nativePrototype = scope.nativePrototypeTable.get(proto);
                        if (nativePrototype) break;
                        prototypes.push(proto);
                        proto = Object.getPrototypeOf(proto);
                    }
                    if (!nativePrototype) {
                        throw new Error("NotSupportedError");
                    }
                    var newPrototype = Object.create(nativePrototype);
                    for (var i = prototypes.length - 1; i >= 0; i--) {
                        newPrototype = Object.create(newPrototype);
                    }
                    ["createdCallback", "attachedCallback", "detachedCallback", "attributeChangedCallback"].forEach(function (name) {
                        var f = prototype[name];
                        if (!f) return;
                        newPrototype[name] = function () {
                            if (!(wrap(this) instanceof CustomElementConstructor)) {
                                rewrap(this);
                            }
                            f.apply(wrap(this), arguments);
                        };
                    });
                    var p = {
                        prototype: newPrototype
                    };
                    if (extendsOption) p.extends = extendsOption;
                    function CustomElementConstructor(node) {
                        if (!node) {
                            if (extendsOption) {
                                return document.createElement(extendsOption, tagName);
                            } else {
                                return document.createElement(tagName);
                            }
                        }
                        setWrapper(node, this);
                    }

                    CustomElementConstructor.prototype = prototype;
                    CustomElementConstructor.prototype.constructor = CustomElementConstructor;
                    scope.constructorTable.set(newPrototype, CustomElementConstructor);
                    scope.nativePrototypeTable.set(prototype, newPrototype);
                    var nativeConstructor = originalRegisterElement.call(unwrap(this), tagName, p);
                    return CustomElementConstructor;
                };
                forwardMethodsToWrapper([window.HTMLDocument || window.Document], ["registerElement"]);
            }
            forwardMethodsToWrapper([window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement, window.HTMLHtmlElement], ["appendChild", "compareDocumentPosition", "contains", "getElementsByClassName", "getElementsByTagName", "getElementsByTagNameNS", "insertBefore", "querySelector", "querySelectorAll", "removeChild", "replaceChild"]);
            forwardMethodsToWrapper([window.HTMLBodyElement, window.HTMLHeadElement, window.HTMLHtmlElement], matchesNames);
            forwardMethodsToWrapper([window.HTMLDocument || window.Document], ["adoptNode", "importNode", "contains", "createComment", "createDocumentFragment", "createElement", "createElementNS", "createEvent", "createEventNS", "createRange", "createTextNode", "createTreeWalker", "elementFromPoint", "getElementById", "getElementsByName", "getSelection"]);
            mixin(Document.prototype, GetElementsByInterface);
            mixin(Document.prototype, ParentNodeInterface);
            mixin(Document.prototype, SelectorsInterface);
            mixin(Document.prototype, NonElementParentNodeInterface);
            mixin(Document.prototype, {
                get implementation() {
                    var implementation = implementationTable.get(this);
                    if (implementation) return implementation;
                    implementation = new DOMImplementation(unwrap(this).implementation);
                    implementationTable.set(this, implementation);
                    return implementation;
                },
                get defaultView() {
                    return wrap(unwrap(this).defaultView);
                }
            });
            registerWrapper(window.Document, Document, document.implementation.createHTMLDocument(""));
            if (window.HTMLDocument) registerWrapper(window.HTMLDocument, Document);
            wrapEventTargetMethods([window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement]);
            function DOMImplementation(impl) {
                setWrapper(impl, this);
            }

            var originalCreateDocument = document.implementation.createDocument;
            DOMImplementation.prototype.createDocument = function () {
                arguments[2] = unwrap(arguments[2]);
                return wrap(originalCreateDocument.apply(unsafeUnwrap(this), arguments));
            };
            function wrapImplMethod(constructor, name) {
                var original = document.implementation[name];
                constructor.prototype[name] = function () {
                    return wrap(original.apply(unsafeUnwrap(this), arguments));
                };
            }

            function forwardImplMethod(constructor, name) {
                var original = document.implementation[name];
                constructor.prototype[name] = function () {
                    return original.apply(unsafeUnwrap(this), arguments);
                };
            }

            wrapImplMethod(DOMImplementation, "createDocumentType");
            wrapImplMethod(DOMImplementation, "createHTMLDocument");
            forwardImplMethod(DOMImplementation, "hasFeature");
            registerWrapper(window.DOMImplementation, DOMImplementation);
            forwardMethodsToWrapper([window.DOMImplementation], ["createDocument", "createDocumentType", "createHTMLDocument", "hasFeature"]);
            scope.adoptNodeNoRemove = adoptNodeNoRemove;
            scope.wrappers.DOMImplementation = DOMImplementation;
            scope.wrappers.Document = Document;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var EventTarget = scope.wrappers.EventTarget;
            var Selection = scope.wrappers.Selection;
            var mixin = scope.mixin;
            var registerWrapper = scope.registerWrapper;
            var renderAllPending = scope.renderAllPending;
            var unwrap = scope.unwrap;
            var unwrapIfNeeded = scope.unwrapIfNeeded;
            var wrap = scope.wrap;
            var OriginalWindow = window.Window;
            var originalGetComputedStyle = window.getComputedStyle;
            var originalGetDefaultComputedStyle = window.getDefaultComputedStyle;
            var originalGetSelection = window.getSelection;

            function Window(impl) {
                EventTarget.call(this, impl);
            }

            Window.prototype = Object.create(EventTarget.prototype);
            OriginalWindow.prototype.getComputedStyle = function (el, pseudo) {
                return wrap(this || window).getComputedStyle(unwrapIfNeeded(el), pseudo);
            };
            if (originalGetDefaultComputedStyle) {
                OriginalWindow.prototype.getDefaultComputedStyle = function (el, pseudo) {
                    return wrap(this || window).getDefaultComputedStyle(unwrapIfNeeded(el), pseudo);
                };
            }
            OriginalWindow.prototype.getSelection = function () {
                return wrap(this || window).getSelection();
            };
            delete window.getComputedStyle;
            delete window.getDefaultComputedStyle;
            delete window.getSelection;
            ["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function (name) {
                OriginalWindow.prototype[name] = function () {
                    var w = wrap(this || window);
                    return w[name].apply(w, arguments);
                };
                delete window[name];
            });
            mixin(Window.prototype, {
                getComputedStyle: function (el, pseudo) {
                    renderAllPending();
                    return originalGetComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);
                },
                getSelection: function () {
                    renderAllPending();
                    return new Selection(originalGetSelection.call(unwrap(this)));
                },
                get document() {
                    return wrap(unwrap(this).document);
                }
            });
            if (originalGetDefaultComputedStyle) {
                Window.prototype.getDefaultComputedStyle = function (el, pseudo) {
                    renderAllPending();
                    return originalGetDefaultComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);
                };
            }
            registerWrapper(OriginalWindow, Window, window);
            scope.wrappers.Window = Window;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var unwrap = scope.unwrap;
            var OriginalDataTransfer = window.DataTransfer || window.Clipboard;
            var OriginalDataTransferSetDragImage = OriginalDataTransfer.prototype.setDragImage;
            if (OriginalDataTransferSetDragImage) {
                OriginalDataTransfer.prototype.setDragImage = function (image, x, y) {
                    OriginalDataTransferSetDragImage.call(this, unwrap(image), x, y);
                };
            }
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var registerWrapper = scope.registerWrapper;
            var setWrapper = scope.setWrapper;
            var unwrap = scope.unwrap;
            var OriginalFormData = window.FormData;
            if (!OriginalFormData) return;
            function FormData(formElement) {
                var impl;
                if (formElement instanceof OriginalFormData) {
                    impl = formElement;
                } else {
                    impl = new OriginalFormData(formElement && unwrap(formElement));
                }
                setWrapper(impl, this);
            }

            registerWrapper(OriginalFormData, FormData, new OriginalFormData());
            scope.wrappers.FormData = FormData;
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var unwrapIfNeeded = scope.unwrapIfNeeded;
            var originalSend = XMLHttpRequest.prototype.send;
            XMLHttpRequest.prototype.send = function (obj) {
                return originalSend.call(this, unwrapIfNeeded(obj));
            };
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            "use strict";
            var isWrapperFor = scope.isWrapperFor;
            var elements = {
                a: "HTMLAnchorElement",
                area: "HTMLAreaElement",
                audio: "HTMLAudioElement",
                base: "HTMLBaseElement",
                body: "HTMLBodyElement",
                br: "HTMLBRElement",
                button: "HTMLButtonElement",
                canvas: "HTMLCanvasElement",
                caption: "HTMLTableCaptionElement",
                col: "HTMLTableColElement",
                content: "HTMLContentElement",
                data: "HTMLDataElement",
                datalist: "HTMLDataListElement",
                del: "HTMLModElement",
                dir: "HTMLDirectoryElement",
                div: "HTMLDivElement",
                dl: "HTMLDListElement",
                embed: "HTMLEmbedElement",
                fieldset: "HTMLFieldSetElement",
                font: "HTMLFontElement",
                form: "HTMLFormElement",
                frame: "HTMLFrameElement",
                frameset: "HTMLFrameSetElement",
                h1: "HTMLHeadingElement",
                head: "HTMLHeadElement",
                hr: "HTMLHRElement",
                html: "HTMLHtmlElement",
                iframe: "HTMLIFrameElement",
                img: "HTMLImageElement",
                input: "HTMLInputElement",
                keygen: "HTMLKeygenElement",
                label: "HTMLLabelElement",
                legend: "HTMLLegendElement",
                li: "HTMLLIElement",
                link: "HTMLLinkElement",
                map: "HTMLMapElement",
                marquee: "HTMLMarqueeElement",
                menu: "HTMLMenuElement",
                menuitem: "HTMLMenuItemElement",
                meta: "HTMLMetaElement",
                meter: "HTMLMeterElement",
                object: "HTMLObjectElement",
                ol: "HTMLOListElement",
                optgroup: "HTMLOptGroupElement",
                option: "HTMLOptionElement",
                output: "HTMLOutputElement",
                p: "HTMLParagraphElement",
                param: "HTMLParamElement",
                pre: "HTMLPreElement",
                progress: "HTMLProgressElement",
                q: "HTMLQuoteElement",
                script: "HTMLScriptElement",
                select: "HTMLSelectElement",
                shadow: "HTMLShadowElement",
                source: "HTMLSourceElement",
                span: "HTMLSpanElement",
                style: "HTMLStyleElement",
                table: "HTMLTableElement",
                tbody: "HTMLTableSectionElement",
                template: "HTMLTemplateElement",
                textarea: "HTMLTextAreaElement",
                thead: "HTMLTableSectionElement",
                time: "HTMLTimeElement",
                title: "HTMLTitleElement",
                tr: "HTMLTableRowElement",
                track: "HTMLTrackElement",
                ul: "HTMLUListElement",
                video: "HTMLVideoElement"
            };

            function overrideConstructor(tagName) {
                var nativeConstructorName = elements[tagName];
                var nativeConstructor = window[nativeConstructorName];
                if (!nativeConstructor) return;
                var element = document.createElement(tagName);
                var wrapperConstructor = element.constructor;
                window[nativeConstructorName] = wrapperConstructor;
            }

            Object.keys(elements).forEach(overrideConstructor);
            Object.getOwnPropertyNames(scope.wrappers).forEach(function (name) {
                window[name] = scope.wrappers[name];
            });
        })(window.ShadowDOMPolyfill);
        (function (scope) {
            var ShadowCSS = {
                strictStyling: false,
                registry: {},
                shimStyling: function (root, name, extendsName) {
                    var scopeStyles = this.prepareRoot(root, name, extendsName);
                    var typeExtension = this.isTypeExtension(extendsName);
                    var scopeSelector = this.makeScopeSelector(name, typeExtension);
                    var cssText = stylesToCssText(scopeStyles, true);
                    cssText = this.scopeCssText(cssText, scopeSelector);
                    if (root) {
                        root.shimmedStyle = cssText;
                    }
                    this.addCssToDocument(cssText, name);
                },
                shimStyle: function (style, selector) {
                    return this.shimCssText(style.textContent, selector);
                },
                shimCssText: function (cssText, selector) {
                    cssText = this.insertDirectives(cssText);
                    return this.scopeCssText(cssText, selector);
                },
                makeScopeSelector: function (name, typeExtension) {
                    if (name) {
                        return typeExtension ? "[is=" + name + "]" : name;
                    }
                    return "";
                },
                isTypeExtension: function (extendsName) {
                    return extendsName && extendsName.indexOf("-") < 0;
                },
                prepareRoot: function (root, name, extendsName) {
                    var def = this.registerRoot(root, name, extendsName);
                    this.replaceTextInStyles(def.rootStyles, this.insertDirectives);
                    this.removeStyles(root, def.rootStyles);
                    if (this.strictStyling) {
                        this.applyScopeToContent(root, name);
                    }
                    return def.scopeStyles;
                },
                removeStyles: function (root, styles) {
                    for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
                        s.parentNode.removeChild(s);
                    }
                },
                registerRoot: function (root, name, extendsName) {
                    var def = this.registry[name] = {
                        root: root,
                        name: name,
                        extendsName: extendsName
                    };
                    var styles = this.findStyles(root);
                    def.rootStyles = styles;
                    def.scopeStyles = def.rootStyles;
                    var extendee = this.registry[def.extendsName];
                    if (extendee) {
                        def.scopeStyles = extendee.scopeStyles.concat(def.scopeStyles);
                    }
                    return def;
                },
                findStyles: function (root) {
                    if (!root) {
                        return [];
                    }
                    var styles = root.querySelectorAll("style");
                    return Array.prototype.filter.call(styles, function (s) {
                        return !s.hasAttribute(NO_SHIM_ATTRIBUTE);
                    });
                },
                applyScopeToContent: function (root, name) {
                    if (root) {
                        Array.prototype.forEach.call(root.querySelectorAll("*"), function (node) {
                            node.setAttribute(name, "");
                        });
                        Array.prototype.forEach.call(root.querySelectorAll("template"), function (template) {
                            this.applyScopeToContent(template.content, name);
                        }, this);
                    }
                },
                insertDirectives: function (cssText) {
                    cssText = this.insertPolyfillDirectivesInCssText(cssText);
                    return this.insertPolyfillRulesInCssText(cssText);
                },
                insertPolyfillDirectivesInCssText: function (cssText) {
                    cssText = cssText.replace(cssCommentNextSelectorRe, function (match, p1) {
                        return p1.slice(0, -2) + "{";
                    });
                    return cssText.replace(cssContentNextSelectorRe, function (match, p1) {
                        return p1 + " {";
                    });
                },
                insertPolyfillRulesInCssText: function (cssText) {
                    cssText = cssText.replace(cssCommentRuleRe, function (match, p1) {
                        return p1.slice(0, -1);
                    });
                    return cssText.replace(cssContentRuleRe, function (match, p1, p2, p3) {
                        var rule = match.replace(p1, "").replace(p2, "");
                        return p3 + rule;
                    });
                },
                scopeCssText: function (cssText, scopeSelector) {
                    var unscoped = this.extractUnscopedRulesFromCssText(cssText);
                    cssText = this.insertPolyfillHostInCssText(cssText);
                    cssText = this.convertColonHost(cssText);
                    cssText = this.convertColonHostContext(cssText);
                    cssText = this.convertShadowDOMSelectors(cssText);
                    if (scopeSelector) {
                        var self = this, cssText;
                        withCssRules(cssText, function (rules) {
                            cssText = self.scopeRules(rules, scopeSelector);
                        });
                    }
                    cssText = cssText + "\n" + unscoped;
                    return cssText.trim();
                },
                extractUnscopedRulesFromCssText: function (cssText) {
                    var r = "", m;
                    while (m = cssCommentUnscopedRuleRe.exec(cssText)) {
                        r += m[1].slice(0, -1) + "\n\n";
                    }
                    while (m = cssContentUnscopedRuleRe.exec(cssText)) {
                        r += m[0].replace(m[2], "").replace(m[1], m[3]) + "\n\n";
                    }
                    return r;
                },
                convertColonHost: function (cssText) {
                    return this.convertColonRule(cssText, cssColonHostRe, this.colonHostPartReplacer);
                },
                convertColonHostContext: function (cssText) {
                    return this.convertColonRule(cssText, cssColonHostContextRe, this.colonHostContextPartReplacer);
                },
                convertColonRule: function (cssText, regExp, partReplacer) {
                    return cssText.replace(regExp, function (m, p1, p2, p3) {
                        p1 = polyfillHostNoCombinator;
                        if (p2) {
                            var parts = p2.split(","), r = [];
                            for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
                                p = p.trim();
                                r.push(partReplacer(p1, p, p3));
                            }
                            return r.join(",");
                        } else {
                            return p1 + p3;
                        }
                    });
                },
                colonHostContextPartReplacer: function (host, part, suffix) {
                    if (part.match(polyfillHost)) {
                        return this.colonHostPartReplacer(host, part, suffix);
                    } else {
                        return host + part + suffix + ", " + part + " " + host + suffix;
                    }
                },
                colonHostPartReplacer: function (host, part, suffix) {
                    return host + part.replace(polyfillHost, "") + suffix;
                },
                convertShadowDOMSelectors: function (cssText) {
                    for (var i = 0; i < shadowDOMSelectorsRe.length; i++) {
                        cssText = cssText.replace(shadowDOMSelectorsRe[i], " ");
                    }
                    return cssText;
                },
                scopeRules: function (cssRules, scopeSelector) {
                    var cssText = "";
                    if (cssRules) {
                        Array.prototype.forEach.call(cssRules, function (rule) {
                            if (rule.selectorText && (rule.style && rule.style.cssText !== undefined)) {
                                cssText += this.scopeSelector(rule.selectorText, scopeSelector, this.strictStyling) + " {\n	";
                                cssText += this.propertiesFromRule(rule) + "\n}\n\n";
                            } else if (rule.type === CSSRule.MEDIA_RULE) {
                                cssText += "@media " + rule.media.mediaText + " {\n";
                                cssText += this.scopeRules(rule.cssRules, scopeSelector);
                                cssText += "\n}\n\n";
                            } else {
                                try {
                                    if (rule.cssText) {
                                        cssText += rule.cssText + "\n\n";
                                    }
                                } catch (x) {
                                    if (rule.type === CSSRule.KEYFRAMES_RULE && rule.cssRules) {
                                        cssText += this.ieSafeCssTextFromKeyFrameRule(rule);
                                    }
                                }
                            }
                        }, this);
                    }
                    return cssText;
                },
                ieSafeCssTextFromKeyFrameRule: function (rule) {
                    var cssText = "@keyframes " + rule.name + " {";
                    Array.prototype.forEach.call(rule.cssRules, function (rule) {
                        cssText += " " + rule.keyText + " {" + rule.style.cssText + "}";
                    });
                    cssText += " }";
                    return cssText;
                },
                scopeSelector: function (selector, scopeSelector, strict) {
                    var r = [], parts = selector.split(",");
                    parts.forEach(function (p) {
                        p = p.trim();
                        if (this.selectorNeedsScoping(p, scopeSelector)) {
                            p = strict && !p.match(polyfillHostNoCombinator) ? this.applyStrictSelectorScope(p, scopeSelector) : this.applySelectorScope(p, scopeSelector);
                        }
                        r.push(p);
                    }, this);
                    return r.join(", ");
                },
                selectorNeedsScoping: function (selector, scopeSelector) {
                    if (Array.isArray(scopeSelector)) {
                        return true;
                    }
                    var re = this.makeScopeMatcher(scopeSelector);
                    return !selector.match(re);
                },
                makeScopeMatcher: function (scopeSelector) {
                    scopeSelector = scopeSelector.replace(/\[/g, "\\[").replace(/\]/g, "\\]");
                    return new RegExp("^(" + scopeSelector + ")" + selectorReSuffix, "m");
                },
                applySelectorScope: function (selector, selectorScope) {
                    return Array.isArray(selectorScope) ? this.applySelectorScopeList(selector, selectorScope) : this.applySimpleSelectorScope(selector, selectorScope);
                },
                applySelectorScopeList: function (selector, scopeSelectorList) {
                    var r = [];
                    for (var i = 0, s; s = scopeSelectorList[i]; i++) {
                        r.push(this.applySimpleSelectorScope(selector, s));
                    }
                    return r.join(", ");
                },
                applySimpleSelectorScope: function (selector, scopeSelector) {
                    if (selector.match(polyfillHostRe)) {
                        selector = selector.replace(polyfillHostNoCombinator, scopeSelector);
                        return selector.replace(polyfillHostRe, scopeSelector + " ");
                    } else {
                        return scopeSelector + " " + selector;
                    }
                },
                applyStrictSelectorScope: function (selector, scopeSelector) {
                    scopeSelector = scopeSelector.replace(/\[is=([^\]]*)\]/g, "$1");
                    var splits = [" ", ">", "+", "~"], scoped = selector, attrName = "[" + scopeSelector + "]";
                    splits.forEach(function (sep) {
                        var parts = scoped.split(sep);
                        scoped = parts.map(function (p) {
                            var t = p.trim().replace(polyfillHostRe, "");
                            if (t && splits.indexOf(t) < 0 && t.indexOf(attrName) < 0) {
                                p = t.replace(/([^:]*)(:*)(.*)/, "$1" + attrName + "$2$3");
                            }
                            return p;
                        }).join(sep);
                    });
                    return scoped;
                },
                insertPolyfillHostInCssText: function (selector) {
                    return selector.replace(colonHostContextRe, polyfillHostContext).replace(colonHostRe, polyfillHost);
                },
                propertiesFromRule: function (rule) {
                    var cssText = rule.style.cssText;
                    if (rule.style.content && !rule.style.content.match(/['"]+|attr/)) {
                        cssText = cssText.replace(/content:[^;]*;/g, "content: '" + rule.style.content + "';");
                    }
                    var style = rule.style;
                    for (var i in style) {
                        if (style[i] === "initial") {
                            cssText += i + ": initial; ";
                        }
                    }
                    return cssText;
                },
                replaceTextInStyles: function (styles, action) {
                    if (styles && action) {
                        if (!(styles instanceof Array)) {
                            styles = [styles];
                        }
                        Array.prototype.forEach.call(styles, function (s) {
                            s.textContent = action.call(this, s.textContent);
                        }, this);
                    }
                },
                addCssToDocument: function (cssText, name) {
                    if (cssText.match("@import")) {
                        addOwnSheet(cssText, name);
                    } else {
                        addCssToDocument(cssText);
                    }
                }
            };
            var selectorRe = /([^{]*)({[\s\S]*?})/gim, cssCommentRe = /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim, cssCommentNextSelectorRe = /\/\*\s*@polyfill ([^*]*\*+([^\/*][^*]*\*+)*\/)([^{]*?){/gim, cssContentNextSelectorRe = /polyfill-next-selector[^}]*content\:[\s]*?['"](.*?)['"][;\s]*}([^{]*?){/gim, cssCommentRuleRe = /\/\*\s@polyfill-rule([^*]*\*+([^\/*][^*]*\*+)*)\//gim, cssContentRuleRe = /(polyfill-rule)[^}]*(content\:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim, cssCommentUnscopedRuleRe = /\/\*\s@polyfill-unscoped-rule([^*]*\*+([^\/*][^*]*\*+)*)\//gim, cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content\:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim, cssPseudoRe = /::(x-[^\s{,(]*)/gim, cssPartRe = /::part\(([^)]*)\)/gim, polyfillHost = "-shadowcsshost", polyfillHostContext = "-shadowcsscontext", parenSuffix = ")(?:\\((" + "(?:\\([^)(]*\\)|[^)(]*)+?" + ")\\))?([^,{]*)";
            var cssColonHostRe = new RegExp("(" + polyfillHost + parenSuffix, "gim"), cssColonHostContextRe = new RegExp("(" + polyfillHostContext + parenSuffix, "gim"), selectorReSuffix = "([>\\s~+[.,{:][\\s\\S]*)?$", colonHostRe = /\:host/gim, colonHostContextRe = /\:host-context/gim, polyfillHostNoCombinator = polyfillHost + "-no-combinator", polyfillHostRe = new RegExp(polyfillHost, "gim"), polyfillHostContextRe = new RegExp(polyfillHostContext, "gim"), shadowDOMSelectorsRe = [/>>>/g, /::shadow/g, /::content/g, /\/deep\//g, /\/shadow\//g, /\/shadow-deep\//g, /\^\^/g, /\^/g];

            function stylesToCssText(styles, preserveComments) {
                var cssText = "";
                Array.prototype.forEach.call(styles, function (s) {
                    cssText += s.textContent + "\n\n";
                });
                if (!preserveComments) {
                    cssText = cssText.replace(cssCommentRe, "");
                }
                return cssText;
            }

            function cssTextToStyle(cssText) {
                var style = document.createElement("style");
                style.textContent = cssText;
                return style;
            }

            function cssToRules(cssText) {
                var style = cssTextToStyle(cssText);
                document.head.appendChild(style);
                var rules = [];
                if (style.sheet) {
                    try {
                        rules = style.sheet.cssRules;
                    } catch (e) {
                    }
                } else {
                    console.warn("sheet not found", style);
                }
                style.parentNode.removeChild(style);
                return rules;
            }

            var frame = document.createElement("iframe");
            frame.style.display = "none";
            function initFrame() {
                frame.initialized = true;
                document.body.appendChild(frame);
                var doc = frame.contentDocument;
                var base = doc.createElement("base");
                base.href = document.baseURI;
                doc.head.appendChild(base);
            }

            function inFrame(fn) {
                if (!frame.initialized) {
                    initFrame();
                }
                document.body.appendChild(frame);
                fn(frame.contentDocument);
                document.body.removeChild(frame);
            }

            var isChrome = navigator.userAgent.match("Chrome");

            function withCssRules(cssText, callback) {
                if (!callback) {
                    return;
                }
                var rules;
                if (cssText.match("@import") && isChrome) {
                    var style = cssTextToStyle(cssText);
                    inFrame(function (doc) {
                        doc.head.appendChild(style.impl);
                        rules = Array.prototype.slice.call(style.sheet.cssRules, 0);
                        callback(rules);
                    });
                } else {
                    rules = cssToRules(cssText);
                    callback(rules);
                }
            }

            function rulesToCss(cssRules) {
                for (var i = 0, css = []; i < cssRules.length; i++) {
                    css.push(cssRules[i].cssText);
                }
                return css.join("\n\n");
            }

            function addCssToDocument(cssText) {
                if (cssText) {
                    getSheet().appendChild(document.createTextNode(cssText));
                }
            }

            function addOwnSheet(cssText, name) {
                var style = cssTextToStyle(cssText);
                style.setAttribute(name, "");
                style.setAttribute(SHIMMED_ATTRIBUTE, "");
                document.head.appendChild(style);
            }

            var SHIM_ATTRIBUTE = "shim-shadowdom";
            var SHIMMED_ATTRIBUTE = "shim-shadowdom-css";
            var NO_SHIM_ATTRIBUTE = "no-shim";
            var sheet;

            function getSheet() {
                if (!sheet) {
                    sheet = document.createElement("style");
                    sheet.setAttribute(SHIMMED_ATTRIBUTE, "");
                    sheet[SHIMMED_ATTRIBUTE] = true;
                }
                return sheet;
            }

            if (window.ShadowDOMPolyfill) {
                addCssToDocument("style { display: none !important; }\n");
                var doc = ShadowDOMPolyfill.wrap(document);
                var head = doc.querySelector("head");
                head.insertBefore(getSheet(), head.childNodes[0]);
                document.addEventListener("DOMContentLoaded", function () {
                    var urlResolver = scope.urlResolver;
                    if (window.HTMLImports && !HTMLImports.useNative) {
                        var SHIM_SHEET_SELECTOR = "link[rel=stylesheet]" + "[" + SHIM_ATTRIBUTE + "]";
                        var SHIM_STYLE_SELECTOR = "style[" + SHIM_ATTRIBUTE + "]";
                        HTMLImports.importer.documentPreloadSelectors += "," + SHIM_SHEET_SELECTOR;
                        HTMLImports.importer.importsPreloadSelectors += "," + SHIM_SHEET_SELECTOR;
                        HTMLImports.parser.documentSelectors = [HTMLImports.parser.documentSelectors, SHIM_SHEET_SELECTOR, SHIM_STYLE_SELECTOR].join(",");
                        var originalParseGeneric = HTMLImports.parser.parseGeneric;
                        HTMLImports.parser.parseGeneric = function (elt) {
                            if (elt[SHIMMED_ATTRIBUTE]) {
                                return;
                            }
                            var style = elt.__importElement || elt;
                            if (!style.hasAttribute(SHIM_ATTRIBUTE)) {
                                originalParseGeneric.call(this, elt);
                                return;
                            }
                            if (elt.__resource) {
                                style = elt.ownerDocument.createElement("style");
                                style.textContent = elt.__resource;
                            }
                            HTMLImports.path.resolveUrlsInStyle(style, elt.href);
                            style.textContent = ShadowCSS.shimStyle(style);
                            style.removeAttribute(SHIM_ATTRIBUTE, "");
                            style.setAttribute(SHIMMED_ATTRIBUTE, "");
                            style[SHIMMED_ATTRIBUTE] = true;
                            if (style.parentNode !== head) {
                                if (elt.parentNode === head) {
                                    head.replaceChild(style, elt);
                                } else {
                                    this.addElementToDocument(style);
                                }
                            }
                            style.__importParsed = true;
                            this.markParsingComplete(elt);
                            this.parseNext();
                        };
                        var hasResource = HTMLImports.parser.hasResource;
                        HTMLImports.parser.hasResource = function (node) {
                            if (node.localName === "link" && node.rel === "stylesheet" && node.hasAttribute(SHIM_ATTRIBUTE)) {
                                return node.__resource;
                            } else {
                                return hasResource.call(this, node);
                            }
                        };
                    }
                });
            }
            scope.ShadowCSS = ShadowCSS;
        })(window.WebComponents);
    }

    (function (scope) {
        if (window.ShadowDOMPolyfill) {
            window.wrap = ShadowDOMPolyfill.wrapIfNeeded;
            window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;
        } else {
            window.wrap = window.unwrap = function (n) {
                return n;
            };
        }
    })(window.WebComponents);

    (function (scope) {
        "use strict";
        var hasWorkingUrl = false;
        if (!scope.forceJURL) {
            try {
                var u = new URL("b", "http://a");
                u.pathname = "c%20d";
                hasWorkingUrl = u.href === "http://a/c%20d";
            } catch (e) {
            }
        }
        if (hasWorkingUrl) return;
        var relative = Object.create(null);
        relative["ftp"] = 21;
        relative["file"] = 0;
        relative["gopher"] = 70;
        relative["http"] = 80;
        relative["https"] = 443;
        relative["ws"] = 80;
        relative["wss"] = 443;
        var relativePathDotMapping = Object.create(null);
        relativePathDotMapping["%2e"] = ".";
        relativePathDotMapping[".%2e"] = "..";
        relativePathDotMapping["%2e."] = "..";
        relativePathDotMapping["%2e%2e"] = "..";
        function isRelativeScheme(scheme) {
            return relative[scheme] !== undefined;
        }

        function invalid() {
            clear.call(this);
            this._isInvalid = true;
        }

        function IDNAToASCII(h) {
            if ("" == h) {
                invalid.call(this);
            }
            return h.toLowerCase();
        }

        function percentEscape(c) {
            var unicode = c.charCodeAt(0);
            if (unicode > 32 && unicode < 127 && [34, 35, 60, 62, 63, 96].indexOf(unicode) == -1) {
                return c;
            }
            return encodeURIComponent(c);
        }

        function percentEscapeQuery(c) {
            var unicode = c.charCodeAt(0);
            if (unicode > 32 && unicode < 127 && [34, 35, 60, 62, 96].indexOf(unicode) == -1) {
                return c;
            }
            return encodeURIComponent(c);
        }

        var EOF = undefined, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\+\-\.]/;

        function parse(input, stateOverride, base) {
            function err(message) {
                errors.push(message);
            }

            var state = stateOverride || "scheme start", cursor = 0, buffer = "", seenAt = false, seenBracket = false, errors = [];
            loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {
                var c = input[cursor];
                switch (state) {
                    case "scheme start":
                        if (c && ALPHA.test(c)) {
                            buffer += c.toLowerCase();
                            state = "scheme";
                        } else if (!stateOverride) {
                            buffer = "";
                            state = "no scheme";
                            continue;
                        } else {
                            err("Invalid scheme.");
                            break loop;
                        }
                        break;

                    case "scheme":
                        if (c && ALPHANUMERIC.test(c)) {
                            buffer += c.toLowerCase();
                        } else if (":" == c) {
                            this._scheme = buffer;
                            buffer = "";
                            if (stateOverride) {
                                break loop;
                            }
                            if (isRelativeScheme(this._scheme)) {
                                this._isRelative = true;
                            }
                            if ("file" == this._scheme) {
                                state = "relative";
                            } else if (this._isRelative && base && base._scheme == this._scheme) {
                                state = "relative or authority";
                            } else if (this._isRelative) {
                                state = "authority first slash";
                            } else {
                                state = "scheme data";
                            }
                        } else if (!stateOverride) {
                            buffer = "";
                            cursor = 0;
                            state = "no scheme";
                            continue;
                        } else if (EOF == c) {
                            break loop;
                        } else {
                            err("Code point not allowed in scheme: " + c);
                            break loop;
                        }
                        break;

                    case "scheme data":
                        if ("?" == c) {
                            this._query = "?";
                            state = "query";
                        } else if ("#" == c) {
                            this._fragment = "#";
                            state = "fragment";
                        } else {
                            if (EOF != c && "	" != c && "\n" != c && "\r" != c) {
                                this._schemeData += percentEscape(c);
                            }
                        }
                        break;

                    case "no scheme":
                        if (!base || !isRelativeScheme(base._scheme)) {
                            err("Missing scheme.");
                            invalid.call(this);
                        } else {
                            state = "relative";
                            continue;
                        }
                        break;

                    case "relative or authority":
                        if ("/" == c && "/" == input[cursor + 1]) {
                            state = "authority ignore slashes";
                        } else {
                            err("Expected /, got: " + c);
                            state = "relative";
                            continue;
                        }
                        break;

                    case "relative":
                        this._isRelative = true;
                        if ("file" != this._scheme) this._scheme = base._scheme;
                        if (EOF == c) {
                            this._host = base._host;
                            this._port = base._port;
                            this._path = base._path.slice();
                            this._query = base._query;
                            this._username = base._username;
                            this._password = base._password;
                            break loop;
                        } else if ("/" == c || "\\" == c) {
                            if ("\\" == c) err("\\ is an invalid code point.");
                            state = "relative slash";
                        } else if ("?" == c) {
                            this._host = base._host;
                            this._port = base._port;
                            this._path = base._path.slice();
                            this._query = "?";
                            this._username = base._username;
                            this._password = base._password;
                            state = "query";
                        } else if ("#" == c) {
                            this._host = base._host;
                            this._port = base._port;
                            this._path = base._path.slice();
                            this._query = base._query;
                            this._fragment = "#";
                            this._username = base._username;
                            this._password = base._password;
                            state = "fragment";
                        } else {
                            var nextC = input[cursor + 1];
                            var nextNextC = input[cursor + 2];
                            if ("file" != this._scheme || !ALPHA.test(c) || nextC != ":" && nextC != "|" || EOF != nextNextC && "/" != nextNextC && "\\" != nextNextC && "?" != nextNextC && "#" != nextNextC) {
                                this._host = base._host;
                                this._port = base._port;
                                this._username = base._username;
                                this._password = base._password;
                                this._path = base._path.slice();
                                this._path.pop();
                            }
                            state = "relative path";
                            continue;
                        }
                        break;

                    case "relative slash":
                        if ("/" == c || "\\" == c) {
                            if ("\\" == c) {
                                err("\\ is an invalid code point.");
                            }
                            if ("file" == this._scheme) {
                                state = "file host";
                            } else {
                                state = "authority ignore slashes";
                            }
                        } else {
                            if ("file" != this._scheme) {
                                this._host = base._host;
                                this._port = base._port;
                                this._username = base._username;
                                this._password = base._password;
                            }
                            state = "relative path";
                            continue;
                        }
                        break;

                    case "authority first slash":
                        if ("/" == c) {
                            state = "authority second slash";
                        } else {
                            err("Expected '/', got: " + c);
                            state = "authority ignore slashes";
                            continue;
                        }
                        break;

                    case "authority second slash":
                        state = "authority ignore slashes";
                        if ("/" != c) {
                            err("Expected '/', got: " + c);
                            continue;
                        }
                        break;

                    case "authority ignore slashes":
                        if ("/" != c && "\\" != c) {
                            state = "authority";
                            continue;
                        } else {
                            err("Expected authority, got: " + c);
                        }
                        break;

                    case "authority":
                        if ("@" == c) {
                            if (seenAt) {
                                err("@ already seen.");
                                buffer += "%40";
                            }
                            seenAt = true;
                            for (var i = 0; i < buffer.length; i++) {
                                var cp = buffer[i];
                                if ("	" == cp || "\n" == cp || "\r" == cp) {
                                    err("Invalid whitespace in authority.");
                                    continue;
                                }
                                if (":" == cp && null === this._password) {
                                    this._password = "";
                                    continue;
                                }
                                var tempC = percentEscape(cp);
                                null !== this._password ? this._password += tempC : this._username += tempC;
                            }
                            buffer = "";
                        } else if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c) {
                            cursor -= buffer.length;
                            buffer = "";
                            state = "host";
                            continue;
                        } else {
                            buffer += c;
                        }
                        break;

                    case "file host":
                        if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c) {
                            if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == ":" || buffer[1] == "|")) {
                                state = "relative path";
                            } else if (buffer.length == 0) {
                                state = "relative path start";
                            } else {
                                this._host = IDNAToASCII.call(this, buffer);
                                buffer = "";
                                state = "relative path start";
                            }
                            continue;
                        } else if ("	" == c || "\n" == c || "\r" == c) {
                            err("Invalid whitespace in file host.");
                        } else {
                            buffer += c;
                        }
                        break;

                    case "host":
                    case "hostname":
                        if (":" == c && !seenBracket) {
                            this._host = IDNAToASCII.call(this, buffer);
                            buffer = "";
                            state = "port";
                            if ("hostname" == stateOverride) {
                                break loop;
                            }
                        } else if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c) {
                            this._host = IDNAToASCII.call(this, buffer);
                            buffer = "";
                            state = "relative path start";
                            if (stateOverride) {
                                break loop;
                            }
                            continue;
                        } else if ("	" != c && "\n" != c && "\r" != c) {
                            if ("[" == c) {
                                seenBracket = true;
                            } else if ("]" == c) {
                                seenBracket = false;
                            }
                            buffer += c;
                        } else {
                            err("Invalid code point in host/hostname: " + c);
                        }
                        break;

                    case "port":
                        if (/[0-9]/.test(c)) {
                            buffer += c;
                        } else if (EOF == c || "/" == c || "\\" == c || "?" == c || "#" == c || stateOverride) {
                            if ("" != buffer) {
                                var temp = parseInt(buffer, 10);
                                if (temp != relative[this._scheme]) {
                                    this._port = temp + "";
                                }
                                buffer = "";
                            }
                            if (stateOverride) {
                                break loop;
                            }
                            state = "relative path start";
                            continue;
                        } else if ("	" == c || "\n" == c || "\r" == c) {
                            err("Invalid code point in port: " + c);
                        } else {
                            invalid.call(this);
                        }
                        break;

                    case "relative path start":
                        if ("\\" == c) err("'\\' not allowed in path.");
                        state = "relative path";
                        if ("/" != c && "\\" != c) {
                            continue;
                        }
                        break;

                    case "relative path":
                        if (EOF == c || "/" == c || "\\" == c || !stateOverride && ("?" == c || "#" == c)) {
                            if ("\\" == c) {
                                err("\\ not allowed in relative path.");
                            }
                            var tmp;
                            if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {
                                buffer = tmp;
                            }
                            if (".." == buffer) {
                                this._path.pop();
                                if ("/" != c && "\\" != c) {
                                    this._path.push("");
                                }
                            } else if ("." == buffer && "/" != c && "\\" != c) {
                                this._path.push("");
                            } else if ("." != buffer) {
                                if ("file" == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == "|") {
                                    buffer = buffer[0] + ":";
                                }
                                this._path.push(buffer);
                            }
                            buffer = "";
                            if ("?" == c) {
                                this._query = "?";
                                state = "query";
                            } else if ("#" == c) {
                                this._fragment = "#";
                                state = "fragment";
                            }
                        } else if ("	" != c && "\n" != c && "\r" != c) {
                            buffer += percentEscape(c);
                        }
                        break;

                    case "query":
                        if (!stateOverride && "#" == c) {
                            this._fragment = "#";
                            state = "fragment";
                        } else if (EOF != c && "	" != c && "\n" != c && "\r" != c) {
                            this._query += percentEscapeQuery(c);
                        }
                        break;

                    case "fragment":
                        if (EOF != c && "	" != c && "\n" != c && "\r" != c) {
                            this._fragment += c;
                        }
                        break;
                }
                cursor++;
            }
        }

        function clear() {
            this._scheme = "";
            this._schemeData = "";
            this._username = "";
            this._password = null;
            this._host = "";
            this._port = "";
            this._path = [];
            this._query = "";
            this._fragment = "";
            this._isInvalid = false;
            this._isRelative = false;
        }

        function jURL(url, base) {
            if (base !== undefined && !(base instanceof jURL)) base = new jURL(String(base));
            this._url = url;
            clear.call(this);
            var input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, "");
            parse.call(this, input, null, base);
        }

        jURL.prototype = {
            toString: function () {
                return this.href;
            },
            get href() {
                if (this._isInvalid) return this._url;
                var authority = "";
                if ("" != this._username || null != this._password) {
                    authority = this._username + (null != this._password ? ":" + this._password : "") + "@";
                }
                return this.protocol + (this._isRelative ? "//" + authority + this.host : "") + this.pathname + this._query + this._fragment;
            },
            set href(href) {
                clear.call(this);
                parse.call(this, href);
            },
            get protocol() {
                return this._scheme + ":";
            },
            set protocol(protocol) {
                if (this._isInvalid) return;
                parse.call(this, protocol + ":", "scheme start");
            },
            get host() {
                return this._isInvalid ? "" : this._port ? this._host + ":" + this._port : this._host;
            },
            set host(host) {
                if (this._isInvalid || !this._isRelative) return;
                parse.call(this, host, "host");
            },
            get hostname() {
                return this._host;
            },
            set hostname(hostname) {
                if (this._isInvalid || !this._isRelative) return;
                parse.call(this, hostname, "hostname");
            },
            get port() {
                return this._port;
            },
            set port(port) {
                if (this._isInvalid || !this._isRelative) return;
                parse.call(this, port, "port");
            },
            get pathname() {
                return this._isInvalid ? "" : this._isRelative ? "/" + this._path.join("/") : this._schemeData;
            },
            set pathname(pathname) {
                if (this._isInvalid || !this._isRelative) return;
                this._path = [];
                parse.call(this, pathname, "relative path start");
            },
            get search() {
                return this._isInvalid || !this._query || "?" == this._query ? "" : this._query;
            },
            set search(search) {
                if (this._isInvalid || !this._isRelative) return;
                this._query = "?";
                if ("?" == search[0]) search = search.slice(1);
                parse.call(this, search, "query");
            },
            get hash() {
                return this._isInvalid || !this._fragment || "#" == this._fragment ? "" : this._fragment;
            },
            set hash(hash) {
                if (this._isInvalid) return;
                this._fragment = "#";
                if ("#" == hash[0]) hash = hash.slice(1);
                parse.call(this, hash, "fragment");
            },
            get origin() {
                var host;
                if (this._isInvalid || !this._scheme) {
                    return "";
                }
                switch (this._scheme) {
                    case "data":
                    case "file":
                    case "javascript":
                    case "mailto":
                        return "null";
                }
                host = this.host;
                if (!host) {
                    return "";
                }
                return this._scheme + "://" + host;
            }
        };
        var OriginalURL = scope.URL;
        if (OriginalURL) {
            jURL.createObjectURL = function (blob) {
                return OriginalURL.createObjectURL.apply(OriginalURL, arguments);
            };
            jURL.revokeObjectURL = function (url) {
                OriginalURL.revokeObjectURL(url);
            };
        }
        scope.URL = jURL;
    })(self);

    (function (global) {
        if (global.JsMutationObserver) {
            return;
        }
        var registrationsTable = new WeakMap();
        var setImmediate;
        if (/Trident|Edge/.test(navigator.userAgent)) {
            setImmediate = setTimeout;
        } else if (window.setImmediate) {
            setImmediate = window.setImmediate;
        } else {
            var setImmediateQueue = [];
            var sentinel = String(Math.random());
            window.addEventListener("message", function (e) {
                if (e.data === sentinel) {
                    var queue = setImmediateQueue;
                    setImmediateQueue = [];
                    queue.forEach(function (func) {
                        func();
                    });
                }
            });
            setImmediate = function (func) {
                setImmediateQueue.push(func);
                window.postMessage(sentinel, "*");
            };
        }
        var isScheduled = false;
        var scheduledObservers = [];

        function scheduleCallback(observer) {
            scheduledObservers.push(observer);
            if (!isScheduled) {
                isScheduled = true;
                setImmediate(dispatchCallbacks);
            }
        }

        function wrapIfNeeded(node) {
            return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
        }

        function dispatchCallbacks() {
            isScheduled = false;
            var observers = scheduledObservers;
            scheduledObservers = [];
            observers.sort(function (o1, o2) {
                return o1.uid_ - o2.uid_;
            });
            var anyNonEmpty = false;
            observers.forEach(function (observer) {
                var queue = observer.takeRecords();
                removeTransientObserversFor(observer);
                if (queue.length) {
                    observer.callback_(queue, observer);
                    anyNonEmpty = true;
                }
            });
            if (anyNonEmpty) dispatchCallbacks();
        }

        function removeTransientObserversFor(observer) {
            observer.nodes_.forEach(function (node) {
                var registrations = registrationsTable.get(node);
                if (!registrations) return;
                registrations.forEach(function (registration) {
                    if (registration.observer === observer) registration.removeTransientObservers();
                });
            });
        }

        function forEachAncestorAndObserverEnqueueRecord(target, callback) {
            for (var node = target; node; node = node.parentNode) {
                var registrations = registrationsTable.get(node);
                if (registrations) {
                    for (var j = 0; j < registrations.length; j++) {
                        var registration = registrations[j];
                        var options = registration.options;
                        if (node !== target && !options.subtree) continue;
                        var record = callback(options);
                        if (record) registration.enqueue(record);
                    }
                }
            }
        }

        var uidCounter = 0;

        function JsMutationObserver(callback) {
            this.callback_ = callback;
            this.nodes_ = [];
            this.records_ = [];
            this.uid_ = ++uidCounter;
        }

        JsMutationObserver.prototype = {
            observe: function (target, options) {
                target = wrapIfNeeded(target);
                if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
                    throw new SyntaxError();
                }
                var registrations = registrationsTable.get(target);
                if (!registrations) registrationsTable.set(target, registrations = []);
                var registration;
                for (var i = 0; i < registrations.length; i++) {
                    if (registrations[i].observer === this) {
                        registration = registrations[i];
                        registration.removeListeners();
                        registration.options = options;
                        break;
                    }
                }
                if (!registration) {
                    registration = new Registration(this, target, options);
                    registrations.push(registration);
                    this.nodes_.push(target);
                }
                registration.addListeners();
            },
            disconnect: function () {
                this.nodes_.forEach(function (node) {
                    var registrations = registrationsTable.get(node);
                    for (var i = 0; i < registrations.length; i++) {
                        var registration = registrations[i];
                        if (registration.observer === this) {
                            registration.removeListeners();
                            registrations.splice(i, 1);
                            break;
                        }
                    }
                }, this);
                this.records_ = [];
            },
            takeRecords: function () {
                var copyOfRecords = this.records_;
                this.records_ = [];
                return copyOfRecords;
            }
        };
        function MutationRecord(type, target) {
            this.type = type;
            this.target = target;
            this.addedNodes = [];
            this.removedNodes = [];
            this.previousSibling = null;
            this.nextSibling = null;
            this.attributeName = null;
            this.attributeNamespace = null;
            this.oldValue = null;
        }

        function copyMutationRecord(original) {
            var record = new MutationRecord(original.type, original.target);
            record.addedNodes = original.addedNodes.slice();
            record.removedNodes = original.removedNodes.slice();
            record.previousSibling = original.previousSibling;
            record.nextSibling = original.nextSibling;
            record.attributeName = original.attributeName;
            record.attributeNamespace = original.attributeNamespace;
            record.oldValue = original.oldValue;
            return record;
        }

        var currentRecord, recordWithOldValue;

        function getRecord(type, target) {
            return currentRecord = new MutationRecord(type, target);
        }

        function getRecordWithOldValue(oldValue) {
            if (recordWithOldValue) return recordWithOldValue;
            recordWithOldValue = copyMutationRecord(currentRecord);
            recordWithOldValue.oldValue = oldValue;
            return recordWithOldValue;
        }

        function clearRecords() {
            currentRecord = recordWithOldValue = undefined;
        }

        function recordRepresentsCurrentMutation(record) {
            return record === recordWithOldValue || record === currentRecord;
        }

        function selectRecord(lastRecord, newRecord) {
            if (lastRecord === newRecord) return lastRecord;
            if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
            return null;
        }

        function Registration(observer, target, options) {
            this.observer = observer;
            this.target = target;
            this.options = options;
            this.transientObservedNodes = [];
        }

        Registration.prototype = {
            enqueue: function (record) {
                var records = this.observer.records_;
                var length = records.length;
                if (records.length > 0) {
                    var lastRecord = records[length - 1];
                    var recordToReplaceLast = selectRecord(lastRecord, record);
                    if (recordToReplaceLast) {
                        records[length - 1] = recordToReplaceLast;
                        return;
                    }
                } else {
                    scheduleCallback(this.observer);
                }
                records[length] = record;
            },
            addListeners: function () {
                this.addListeners_(this.target);
            },
            addListeners_: function (node) {
                var options = this.options;
                if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
                if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
                if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
                if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
            },
            removeListeners: function () {
                this.removeListeners_(this.target);
            },
            removeListeners_: function (node) {
                var options = this.options;
                if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
                if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
                if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
                if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
            },
            addTransientObserver: function (node) {
                if (node === this.target) return;
                this.addListeners_(node);
                this.transientObservedNodes.push(node);
                var registrations = registrationsTable.get(node);
                if (!registrations) registrationsTable.set(node, registrations = []);
                registrations.push(this);
            },
            removeTransientObservers: function () {
                var transientObservedNodes = this.transientObservedNodes;
                this.transientObservedNodes = [];
                transientObservedNodes.forEach(function (node) {
                    this.removeListeners_(node);
                    var registrations = registrationsTable.get(node);
                    for (var i = 0; i < registrations.length; i++) {
                        if (registrations[i] === this) {
                            registrations.splice(i, 1);
                            break;
                        }
                    }
                }, this);
            },
            handleEvent: function (e) {
                e.stopImmediatePropagation();
                switch (e.type) {
                    case "DOMAttrModified":
                        var name = e.attrName;
                        var namespace = e.relatedNode.namespaceURI;
                        var target = e.target;
                        var record = new getRecord("attributes", target);
                        record.attributeName = name;
                        record.attributeNamespace = namespace;
                        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
                        forEachAncestorAndObserverEnqueueRecord(target, function (options) {
                            if (!options.attributes) return;
                            if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
                                return;
                            }
                            if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
                            return record;
                        });
                        break;

                    case "DOMCharacterDataModified":
                        var target = e.target;
                        var record = getRecord("characterData", target);
                        var oldValue = e.prevValue;
                        forEachAncestorAndObserverEnqueueRecord(target, function (options) {
                            if (!options.characterData) return;
                            if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
                            return record;
                        });
                        break;

                    case "DOMNodeRemoved":
                        this.addTransientObserver(e.target);

                    case "DOMNodeInserted":
                        var changedNode = e.target;
                        var addedNodes, removedNodes;
                        if (e.type === "DOMNodeInserted") {
                            addedNodes = [changedNode];
                            removedNodes = [];
                        } else {
                            addedNodes = [];
                            removedNodes = [changedNode];
                        }
                        var previousSibling = changedNode.previousSibling;
                        var nextSibling = changedNode.nextSibling;
                        var record = getRecord("childList", e.target.parentNode);
                        record.addedNodes = addedNodes;
                        record.removedNodes = removedNodes;
                        record.previousSibling = previousSibling;
                        record.nextSibling = nextSibling;
                        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function (options) {
                            if (!options.childList) return;
                            return record;
                        });
                }
                clearRecords();
            }
        };
        global.JsMutationObserver = JsMutationObserver;
        if (!global.MutationObserver) {
            global.MutationObserver = JsMutationObserver;
            JsMutationObserver._isPolyfilled = true;
        }
    })(self);

    window.HTMLImports = window.HTMLImports || {
                flags: {}
            };

    (function (scope) {
        var IMPORT_LINK_TYPE = "import";
        var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement("link"));
        var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);
        var wrap = function (node) {
            return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;
        };
        var rootDocument = wrap(document);
        var currentScriptDescriptor = {
            get: function () {
                var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== "complete" ? document.scripts[document.scripts.length - 1] : null);
                return wrap(script);
            },
            configurable: true
        };
        Object.defineProperty(document, "_currentScript", currentScriptDescriptor);
        Object.defineProperty(rootDocument, "_currentScript", currentScriptDescriptor);
        var isIE = /Trident/.test(navigator.userAgent);

        function whenReady(callback, doc) {
            doc = doc || rootDocument;
            whenDocumentReady(function () {
                watchImportsLoad(callback, doc);
            }, doc);
        }

        var requiredReadyState = isIE ? "complete" : "interactive";
        var READY_EVENT = "readystatechange";

        function isDocumentReady(doc) {
            return doc.readyState === "complete" || doc.readyState === requiredReadyState;
        }

        function whenDocumentReady(callback, doc) {
            if (!isDocumentReady(doc)) {
                var checkReady = function () {
                    if (doc.readyState === "complete" || doc.readyState === requiredReadyState) {
                        doc.removeEventListener(READY_EVENT, checkReady);
                        whenDocumentReady(callback, doc);
                    }
                };
                doc.addEventListener(READY_EVENT, checkReady);
            } else if (callback) {
                callback();
            }
        }

        function markTargetLoaded(event) {
            event.target.__loaded = true;
        }

        function watchImportsLoad(callback, doc) {
            var imports = doc.querySelectorAll("link[rel=import]");
            var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];

            function checkDone() {
                if (parsedCount == importCount && callback) {
                    callback({
                        allImports: imports,
                        loadedImports: newImports,
                        errorImports: errorImports
                    });
                }
            }

            function loadedImport(e) {
                markTargetLoaded(e);
                newImports.push(this);
                parsedCount++;
                checkDone();
            }

            function errorLoadingImport(e) {
                errorImports.push(this);
                parsedCount++;
                checkDone();
            }

            if (importCount) {
                for (var i = 0, imp; i < importCount && (imp = imports[i]); i++) {
                    if (isImportLoaded(imp)) {
                        parsedCount++;
                        checkDone();
                    } else {
                        imp.addEventListener("load", loadedImport);
                        imp.addEventListener("error", errorLoadingImport);
                    }
                }
            } else {
                checkDone();
            }
        }

        function isImportLoaded(link) {
            return useNative ? link.__loaded || link.import && link.import.readyState !== "loading" : link.__importParsed;
        }

        if (useNative) {
            new MutationObserver(function (mxns) {
                for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {
                    if (m.addedNodes) {
                        handleImports(m.addedNodes);
                    }
                }
            }).observe(document.head, {
                childList: true
            });
            function handleImports(nodes) {
                for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
                    if (isImport(n)) {
                        handleImport(n);
                    }
                }
            }

            function isImport(element) {
                return element.localName === "link" && element.rel === "import";
            }

            function handleImport(element) {
                var loaded = element.import;
                if (loaded) {
                    markTargetLoaded({
                        target: element
                    });
                } else {
                    element.addEventListener("load", markTargetLoaded);
                    element.addEventListener("error", markTargetLoaded);
                }
            }

            (function () {
                if (document.readyState === "loading") {
                    var imports = document.querySelectorAll("link[rel=import]");
                    for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {
                        handleImport(imp);
                    }
                }
            })();
        }
        whenReady(function (detail) {
            window.HTMLImports.ready = true;
            window.HTMLImports.readyTime = new Date().getTime();
            var evt = rootDocument.createEvent("CustomEvent");
            evt.initCustomEvent("HTMLImportsLoaded", true, true, detail);
            rootDocument.dispatchEvent(evt);
        });
        scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
        scope.useNative = useNative;
        scope.rootDocument = rootDocument;
        scope.whenReady = whenReady;
        scope.isIE = isIE;
    })(window.HTMLImports);

    (function (scope) {
        var modules = [];
        var addModule = function (module) {
            modules.push(module);
        };
        var initializeModules = function () {
            modules.forEach(function (module) {
                module(scope);
            });
        };
        scope.addModule = addModule;
        scope.initializeModules = initializeModules;
    })(window.HTMLImports);

    window.HTMLImports.addModule(function (scope) {
        var CSS_URL_REGEXP = /(url\()([^)]*)(\))/g;
        var CSS_IMPORT_REGEXP = /(@import[\s]+(?!url\())([^;]*)(;)/g;
        var path = {
            resolveUrlsInStyle: function (style, linkUrl) {
                var doc = style.ownerDocument;
                var resolver = doc.createElement("a");
                style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);
                return style;
            },
            resolveUrlsInCssText: function (cssText, linkUrl, urlObj) {
                var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);
                r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);
                return r;
            },
            replaceUrls: function (text, urlObj, linkUrl, regexp) {
                return text.replace(regexp, function (m, pre, url, post) {
                    var urlPath = url.replace(/["']/g, "");
                    if (linkUrl) {
                        urlPath = new URL(urlPath, linkUrl).href;
                    }
                    urlObj.href = urlPath;
                    urlPath = urlObj.href;
                    return pre + "'" + urlPath + "'" + post;
                });
            }
        };
        scope.path = path;
    });

    window.HTMLImports.addModule(function (scope) {
        var xhr = {
            async: true,
            ok: function (request) {
                return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;
            },
            load: function (url, next, nextContext) {
                var request = new XMLHttpRequest();
                if (scope.flags.debug || scope.flags.bust) {
                    url += "?" + Math.random();
                }
                request.open("GET", url, xhr.async);
                request.addEventListener("readystatechange", function (e) {
                    if (request.readyState === 4) {
                        var locationHeader = request.getResponseHeader("Location");
                        var redirectedUrl = null;
                        if (locationHeader) {
                            var redirectedUrl = locationHeader.substr(0, 1) === "/" ? location.origin + locationHeader : locationHeader;
                        }
                        next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);
                    }
                });
                request.send();
                return request;
            },
            loadDocument: function (url, next, nextContext) {
                this.load(url, next, nextContext).responseType = "document";
            }
        };
        scope.xhr = xhr;
    });

    window.HTMLImports.addModule(function (scope) {
        var xhr = scope.xhr;
        var flags = scope.flags;
        var Loader = function (onLoad, onComplete) {
            this.cache = {};
            this.onload = onLoad;
            this.oncomplete = onComplete;
            this.inflight = 0;
            this.pending = {};
        };
        Loader.prototype = {
            addNodes: function (nodes) {
                this.inflight += nodes.length;
                for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
                    this.require(n);
                }
                this.checkDone();
            },
            addNode: function (node) {
                this.inflight++;
                this.require(node);
                this.checkDone();
            },
            require: function (elt) {
                var url = elt.src || elt.href;
                elt.__nodeUrl = url;
                if (!this.dedupe(url, elt)) {
                    this.fetch(url, elt);
                }
            },
            dedupe: function (url, elt) {
                if (this.pending[url]) {
                    this.pending[url].push(elt);
                    return true;
                }
                var resource;
                if (this.cache[url]) {
                    this.onload(url, elt, this.cache[url]);
                    this.tail();
                    return true;
                }
                this.pending[url] = [elt];
                return false;
            },
            fetch: function (url, elt) {
                flags.load && console.log("fetch", url, elt);
                if (!url) {
                    setTimeout(function () {
                        this.receive(url, elt, {
                            error: "href must be specified"
                        }, null);
                    }.bind(this), 0);
                } else if (url.match(/^data:/)) {
                    var pieces = url.split(",");
                    var header = pieces[0];
                    var body = pieces[1];
                    if (header.indexOf(";base64") > -1) {
                        body = atob(body);
                    } else {
                        body = decodeURIComponent(body);
                    }
                    setTimeout(function () {
                        this.receive(url, elt, null, body);
                    }.bind(this), 0);
                } else {
                    var receiveXhr = function (err, resource, redirectedUrl) {
                        this.receive(url, elt, err, resource, redirectedUrl);
                    }.bind(this);
                    xhr.load(url, receiveXhr);
                }
            },
            receive: function (url, elt, err, resource, redirectedUrl) {
                this.cache[url] = resource;
                var $p = this.pending[url];
                for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
                    this.onload(url, p, resource, err, redirectedUrl);
                    this.tail();
                }
                this.pending[url] = null;
            },
            tail: function () {
                --this.inflight;
                this.checkDone();
            },
            checkDone: function () {
                if (!this.inflight) {
                    this.oncomplete();
                }
            }
        };
        scope.Loader = Loader;
    });

    window.HTMLImports.addModule(function (scope) {
        var Observer = function (addCallback) {
            this.addCallback = addCallback;
            this.mo = new MutationObserver(this.handler.bind(this));
        };
        Observer.prototype = {
            handler: function (mutations) {
                for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {
                    if (m.type === "childList" && m.addedNodes.length) {
                        this.addedNodes(m.addedNodes);
                    }
                }
            },
            addedNodes: function (nodes) {
                if (this.addCallback) {
                    this.addCallback(nodes);
                }
                for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {
                    if (n.children && n.children.length) {
                        this.addedNodes(n.children);
                    }
                }
            },
            observe: function (root) {
                this.mo.observe(root, {
                    childList: true,
                    subtree: true
                });
            }
        };
        scope.Observer = Observer;
    });

    window.HTMLImports.addModule(function (scope) {
        var path = scope.path;
        var rootDocument = scope.rootDocument;
        var flags = scope.flags;
        var isIE = scope.isIE;
        var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
        var IMPORT_SELECTOR = "link[rel=" + IMPORT_LINK_TYPE + "]";
        var importParser = {
            documentSelectors: IMPORT_SELECTOR,
            importsSelectors: [IMPORT_SELECTOR, "link[rel=stylesheet]:not([type])", "style:not([type])", "script:not([type])", 'script[type="application/javascript"]', 'script[type="text/javascript"]'].join(","),
            map: {
                link: "parseLink",
                script: "parseScript",
                style: "parseStyle"
            },
            dynamicElements: [],
            parseNext: function () {
                var next = this.nextToParse();
                if (next) {
                    this.parse(next);
                }
            },
            parse: function (elt) {
                if (this.isParsed(elt)) {
                    flags.parse && console.log("[%s] is already parsed", elt.localName);
                    return;
                }
                var fn = this[this.map[elt.localName]];
                if (fn) {
                    this.markParsing(elt);
                    fn.call(this, elt);
                }
            },
            parseDynamic: function (elt, quiet) {
                this.dynamicElements.push(elt);
                if (!quiet) {
                    this.parseNext();
                }
            },
            markParsing: function (elt) {
                flags.parse && console.log("parsing", elt);
                this.parsingElement = elt;
            },
            markParsingComplete: function (elt) {
                elt.__importParsed = true;
                this.markDynamicParsingComplete(elt);
                if (elt.__importElement) {
                    elt.__importElement.__importParsed = true;
                    this.markDynamicParsingComplete(elt.__importElement);
                }
                this.parsingElement = null;
                flags.parse && console.log("completed", elt);
            },
            markDynamicParsingComplete: function (elt) {
                var i = this.dynamicElements.indexOf(elt);
                if (i >= 0) {
                    this.dynamicElements.splice(i, 1);
                }
            },
            parseImport: function (elt) {
                elt.import = elt.__doc;
                if (window.HTMLImports.__importsParsingHook) {
                    window.HTMLImports.__importsParsingHook(elt);
                }
                if (elt.import) {
                    elt.import.__importParsed = true;
                }
                this.markParsingComplete(elt);
                if (elt.__resource && !elt.__error) {
                    elt.dispatchEvent(new CustomEvent("load", {
                        bubbles: false
                    }));
                } else {
                    elt.dispatchEvent(new CustomEvent("error", {
                        bubbles: false
                    }));
                }
                if (elt.__pending) {
                    var fn;
                    while (elt.__pending.length) {
                        fn = elt.__pending.shift();
                        if (fn) {
                            fn({
                                target: elt
                            });
                        }
                    }
                }
                this.parseNext();
            },
            parseLink: function (linkElt) {
                if (nodeIsImport(linkElt)) {
                    this.parseImport(linkElt);
                } else {
                    linkElt.href = linkElt.href;
                    this.parseGeneric(linkElt);
                }
            },
            parseStyle: function (elt) {
                var src = elt;
                elt = cloneStyle(elt);
                src.__appliedElement = elt;
                elt.__importElement = src;
                this.parseGeneric(elt);
            },
            parseGeneric: function (elt) {
                this.trackElement(elt);
                this.addElementToDocument(elt);
            },
            rootImportForElement: function (elt) {
                var n = elt;
                while (n.ownerDocument.__importLink) {
                    n = n.ownerDocument.__importLink;
                }
                return n;
            },
            addElementToDocument: function (elt) {
                var port = this.rootImportForElement(elt.__importElement || elt);
                port.parentNode.insertBefore(elt, port);
            },
            trackElement: function (elt, callback) {
                var self = this;
                var done = function (e) {
                    elt.removeEventListener("load", done);
                    elt.removeEventListener("error", done);
                    if (callback) {
                        callback(e);
                    }
                    self.markParsingComplete(elt);
                    self.parseNext();
                };
                elt.addEventListener("load", done);
                elt.addEventListener("error", done);
                if (isIE && elt.localName === "style") {
                    var fakeLoad = false;
                    if (elt.textContent.indexOf("@import") == -1) {
                        fakeLoad = true;
                    } else if (elt.sheet) {
                        fakeLoad = true;
                        var csr = elt.sheet.cssRules;
                        var len = csr ? csr.length : 0;
                        for (var i = 0, r; i < len && (r = csr[i]); i++) {
                            if (r.type === CSSRule.IMPORT_RULE) {
                                fakeLoad = fakeLoad && Boolean(r.styleSheet);
                            }
                        }
                    }
                    if (fakeLoad) {
                        setTimeout(function () {
                            elt.dispatchEvent(new CustomEvent("load", {
                                bubbles: false
                            }));
                        });
                    }
                }
            },
            parseScript: function (scriptElt) {
                var script = document.createElement("script");
                script.__importElement = scriptElt;
                script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);
                scope.currentScript = scriptElt;
                this.trackElement(script, function (e) {
                    if (script.parentNode) {
                        script.parentNode.removeChild(script);
                    }
                    scope.currentScript = null;
                });
                this.addElementToDocument(script);
            },
            nextToParse: function () {
                this._mayParse = [];
                return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());
            },
            nextToParseInDoc: function (doc, link) {
                if (doc && this._mayParse.indexOf(doc) < 0) {
                    this._mayParse.push(doc);
                    var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));
                    for (var i = 0, l = nodes.length, p = 0, n; i < l && (n = nodes[i]); i++) {
                        if (!this.isParsed(n)) {
                            if (this.hasResource(n)) {
                                return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;
                            } else {
                                return;
                            }
                        }
                    }
                }
                return link;
            },
            nextToParseDynamic: function () {
                return this.dynamicElements[0];
            },
            parseSelectorsForNode: function (node) {
                var doc = node.ownerDocument || node;
                return doc === rootDocument ? this.documentSelectors : this.importsSelectors;
            },
            isParsed: function (node) {
                return node.__importParsed;
            },
            needsDynamicParsing: function (elt) {
                return this.dynamicElements.indexOf(elt) >= 0;
            },
            hasResource: function (node) {
                if (nodeIsImport(node) && node.__doc === undefined) {
                    return false;
                }
                return true;
            }
        };

        function nodeIsImport(elt) {
            return elt.localName === "link" && elt.rel === IMPORT_LINK_TYPE;
        }

        function generateScriptDataUrl(script) {
            var scriptContent = generateScriptContent(script);
            return "data:text/javascript;charset=utf-8," + encodeURIComponent(scriptContent);
        }

        function generateScriptContent(script) {
            return script.textContent + generateSourceMapHint(script);
        }

        function generateSourceMapHint(script) {
            var owner = script.ownerDocument;
            owner.__importedScripts = owner.__importedScripts || 0;
            var moniker = script.ownerDocument.baseURI;
            var num = owner.__importedScripts ? "-" + owner.__importedScripts : "";
            owner.__importedScripts++;
            return "\n//# sourceURL=" + moniker + num + ".js\n";
        }

        function cloneStyle(style) {
            var clone = style.ownerDocument.createElement("style");
            clone.textContent = style.textContent;
            path.resolveUrlsInStyle(clone);
            return clone;
        }

        scope.parser = importParser;
        scope.IMPORT_SELECTOR = IMPORT_SELECTOR;
    });

    window.HTMLImports.addModule(function (scope) {
        var flags = scope.flags;
        var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
        var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;
        var rootDocument = scope.rootDocument;
        var Loader = scope.Loader;
        var Observer = scope.Observer;
        var parser = scope.parser;
        var importer = {
            documents: {},
            documentPreloadSelectors: IMPORT_SELECTOR,
            importsPreloadSelectors: [IMPORT_SELECTOR].join(","),
            loadNode: function (node) {
                importLoader.addNode(node);
            },
            loadSubtree: function (parent) {
                var nodes = this.marshalNodes(parent);
                importLoader.addNodes(nodes);
            },
            marshalNodes: function (parent) {
                return parent.querySelectorAll(this.loadSelectorsForNode(parent));
            },
            loadSelectorsForNode: function (node) {
                var doc = node.ownerDocument || node;
                return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;
            },
            loaded: function (url, elt, resource, err, redirectedUrl) {
                flags.load && console.log("loaded", url, elt);
                elt.__resource = resource;
                elt.__error = err;
                if (isImportLink(elt)) {
                    var doc = this.documents[url];
                    if (doc === undefined) {
                        doc = err ? null : makeDocument(resource, redirectedUrl || url);
                        if (doc) {
                            doc.__importLink = elt;
                            this.bootDocument(doc);
                        }
                        this.documents[url] = doc;
                    }
                    elt.__doc = doc;
                }
                parser.parseNext();
            },
            bootDocument: function (doc) {
                this.loadSubtree(doc);
                this.observer.observe(doc);
                parser.parseNext();
            },
            loadedAll: function () {
                parser.parseNext();
            }
        };
        var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));
        importer.observer = new Observer();
        function isImportLink(elt) {
            return isLinkRel(elt, IMPORT_LINK_TYPE);
        }

        function isLinkRel(elt, rel) {
            return elt.localName === "link" && elt.getAttribute("rel") === rel;
        }

        function hasBaseURIAccessor(doc) {
            return !!Object.getOwnPropertyDescriptor(doc, "baseURI");
        }

        function makeDocument(resource, url) {
            var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);
            doc._URL = url;
            var base = doc.createElement("base");
            base.setAttribute("href", url);
            if (!doc.baseURI && !hasBaseURIAccessor(doc)) {
                Object.defineProperty(doc, "baseURI", {
                    value: url
                });
            }
            var meta = doc.createElement("meta");
            meta.setAttribute("charset", "utf-8");
            doc.head.appendChild(meta);
            doc.head.appendChild(base);
            doc.body.innerHTML = resource;
            if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {
                HTMLTemplateElement.bootstrap(doc);
            }
            return doc;
        }

        if (!document.baseURI) {
            var baseURIDescriptor = {
                get: function () {
                    var base = document.querySelector("base");
                    return base ? base.href : window.location.href;
                },
                configurable: true
            };
            Object.defineProperty(document, "baseURI", baseURIDescriptor);
            Object.defineProperty(rootDocument, "baseURI", baseURIDescriptor);
        }
        scope.importer = importer;
        scope.importLoader = importLoader;
    });

    window.HTMLImports.addModule(function (scope) {
        var parser = scope.parser;
        var importer = scope.importer;
        var dynamic = {
            added: function (nodes) {
                var owner, parsed, loading;
                for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
                    if (!owner) {
                        owner = n.ownerDocument;
                        parsed = parser.isParsed(owner);
                    }
                    loading = this.shouldLoadNode(n);
                    if (loading) {
                        importer.loadNode(n);
                    }
                    if (this.shouldParseNode(n) && parsed) {
                        parser.parseDynamic(n, loading);
                    }
                }
            },
            shouldLoadNode: function (node) {
                return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));
            },
            shouldParseNode: function (node) {
                return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));
            }
        };
        importer.observer.addCallback = dynamic.added.bind(dynamic);
        var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;
    });

    (function (scope) {
        var initializeModules = scope.initializeModules;
        var isIE = scope.isIE;
        if (scope.useNative) {
            return;
        }
        if (!window.CustomEvent || isIE && typeof window.CustomEvent !== "function") {
            window.CustomEvent = function (inType, params) {
                params = params || {};
                var e = document.createEvent("CustomEvent");
                e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
                e.preventDefault = function () {
                    Object.defineProperty(this, "defaultPrevented", {
                        get: function () {
                            return true;
                        }
                    });
                };
                return e;
            };
            window.CustomEvent.prototype = window.Event.prototype;
        }
        initializeModules();
        var rootDocument = scope.rootDocument;

        function bootstrap() {
            window.HTMLImports.importer.bootDocument(rootDocument);
        }

        if (document.readyState === "complete" || document.readyState === "interactive" && !window.attachEvent) {
            bootstrap();
        } else {
            document.addEventListener("DOMContentLoaded", bootstrap);
        }
    })(window.HTMLImports);

    window.CustomElements = window.CustomElements || {
                flags: {}
            };

    (function (scope) {
        var flags = scope.flags;
        var modules = [];
        var addModule = function (module) {
            modules.push(module);
        };
        var initializeModules = function () {
            modules.forEach(function (module) {
                module(scope);
            });
        };
        scope.addModule = addModule;
        scope.initializeModules = initializeModules;
        scope.hasNative = Boolean(document.registerElement);
        scope.isIE = /Trident/.test(navigator.userAgent);
        scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);
    })(window.CustomElements);

    window.CustomElements.addModule(function (scope) {
        var IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : "none";

        function forSubtree(node, cb) {
            findAllElements(node, function (e) {
                if (cb(e)) {
                    return true;
                }
                forRoots(e, cb);
            });
            forRoots(node, cb);
        }

        function findAllElements(node, find, data) {
            var e = node.firstElementChild;
            if (!e) {
                e = node.firstChild;
                while (e && e.nodeType !== Node.ELEMENT_NODE) {
                    e = e.nextSibling;
                }
            }
            while (e) {
                if (find(e, data) !== true) {
                    findAllElements(e, find, data);
                }
                e = e.nextElementSibling;
            }
            return null;
        }

        function forRoots(node, cb) {
            var root = node.shadowRoot;
            while (root) {
                forSubtree(root, cb);
                root = root.olderShadowRoot;
            }
        }

        function forDocumentTree(doc, cb) {
            _forDocumentTree(doc, cb, []);
        }

        function _forDocumentTree(doc, cb, processingDocuments) {
            doc = window.wrap(doc);
            if (processingDocuments.indexOf(doc) >= 0) {
                return;
            }
            processingDocuments.push(doc);
            var imports = doc.querySelectorAll("link[rel=" + IMPORT_LINK_TYPE + "]");
            for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {
                if (n.import) {
                    _forDocumentTree(n.import, cb, processingDocuments);
                }
            }
            cb(doc);
        }

        scope.forDocumentTree = forDocumentTree;
        scope.forSubtree = forSubtree;
    });

    window.CustomElements.addModule(function (scope) {
        var flags = scope.flags;
        var forSubtree = scope.forSubtree;
        var forDocumentTree = scope.forDocumentTree;

        function addedNode(node, isAttached) {
            return added(node, isAttached) || addedSubtree(node, isAttached);
        }

        function added(node, isAttached) {
            if (scope.upgrade(node, isAttached)) {
                return true;
            }
            if (isAttached) {
                attached(node);
            }
        }

        function addedSubtree(node, isAttached) {
            forSubtree(node, function (e) {
                if (added(e, isAttached)) {
                    return true;
                }
            });
        }

        var hasThrottledAttached = window.MutationObserver._isPolyfilled && flags["throttle-attached"];
        scope.hasPolyfillMutations = hasThrottledAttached;
        scope.hasThrottledAttached = hasThrottledAttached;
        var isPendingMutations = false;
        var pendingMutations = [];

        function deferMutation(fn) {
            pendingMutations.push(fn);
            if (!isPendingMutations) {
                isPendingMutations = true;
                setTimeout(takeMutations);
            }
        }

        function takeMutations() {
            isPendingMutations = false;
            var $p = pendingMutations;
            for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
                p();
            }
            pendingMutations = [];
        }

        function attached(element) {
            if (hasThrottledAttached) {
                deferMutation(function () {
                    _attached(element);
                });
            } else {
                _attached(element);
            }
        }

        function _attached(element) {
            if (element.__upgraded__ && !element.__attached) {
                element.__attached = true;
                if (element.attachedCallback) {
                    element.attachedCallback();
                }
            }
        }

        function detachedNode(node) {
            detached(node);
            forSubtree(node, function (e) {
                detached(e);
            });
        }

        function detached(element) {
            if (hasThrottledAttached) {
                deferMutation(function () {
                    _detached(element);
                });
            } else {
                _detached(element);
            }
        }

        function _detached(element) {
            if (element.__upgraded__ && element.__attached) {
                element.__attached = false;
                if (element.detachedCallback) {
                    element.detachedCallback();
                }
            }
        }

        function inDocument(element) {
            var p = element;
            var doc = window.wrap(document);
            while (p) {
                if (p == doc) {
                    return true;
                }
                p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;
            }
        }

        function watchShadow(node) {
            if (node.shadowRoot && !node.shadowRoot.__watched) {
                flags.dom && console.log("watching shadow-root for: ", node.localName);
                var root = node.shadowRoot;
                while (root) {
                    observe(root);
                    root = root.olderShadowRoot;
                }
            }
        }

        function handler(root, mutations) {
            if (flags.dom) {
                var mx = mutations[0];
                if (mx && mx.type === "childList" && mx.addedNodes) {
                    if (mx.addedNodes) {
                        var d = mx.addedNodes[0];
                        while (d && d !== document && !d.host) {
                            d = d.parentNode;
                        }
                        var u = d && (d.URL || d._URL || d.host && d.host.localName) || "";
                        u = u.split("/?").shift().split("/").pop();
                    }
                }
                console.group("mutations (%d) [%s]", mutations.length, u || "");
            }
            var isAttached = inDocument(root);
            mutations.forEach(function (mx) {
                if (mx.type === "childList") {
                    forEach(mx.addedNodes, function (n) {
                        if (!n.localName) {
                            return;
                        }
                        addedNode(n, isAttached);
                    });
                    forEach(mx.removedNodes, function (n) {
                        if (!n.localName) {
                            return;
                        }
                        detachedNode(n);
                    });
                }
            });
            flags.dom && console.groupEnd();
        }

        function takeRecords(node) {
            node = window.wrap(node);
            if (!node) {
                node = window.wrap(document);
            }
            while (node.parentNode) {
                node = node.parentNode;
            }
            var observer = node.__observer;
            if (observer) {
                handler(node, observer.takeRecords());
                takeMutations();
            }
        }

        var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);

        function observe(inRoot) {
            if (inRoot.__observer) {
                return;
            }
            var observer = new MutationObserver(handler.bind(this, inRoot));
            observer.observe(inRoot, {
                childList: true,
                subtree: true
            });
            inRoot.__observer = observer;
        }

        function upgradeDocument(doc) {
            doc = window.wrap(doc);
            flags.dom && console.group("upgradeDocument: ", doc.baseURI.split("/").pop());
            var isMainDocument = doc === window.wrap(document);
            addedNode(doc, isMainDocument);
            observe(doc);
            flags.dom && console.groupEnd();
        }

        function upgradeDocumentTree(doc) {
            forDocumentTree(doc, upgradeDocument);
        }

        var originalCreateShadowRoot = Element.prototype.createShadowRoot;
        if (originalCreateShadowRoot) {
            Element.prototype.createShadowRoot = function () {
                var root = originalCreateShadowRoot.call(this);
                window.CustomElements.watchShadow(this);
                return root;
            };
        }
        scope.watchShadow = watchShadow;
        scope.upgradeDocumentTree = upgradeDocumentTree;
        scope.upgradeDocument = upgradeDocument;
        scope.upgradeSubtree = addedSubtree;
        scope.upgradeAll = addedNode;
        scope.attached = attached;
        scope.takeRecords = takeRecords;
    });

    window.CustomElements.addModule(function (scope) {
        var flags = scope.flags;

        function upgrade(node, isAttached) {
            if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
                var is = node.getAttribute("is");
                var definition = scope.getRegisteredDefinition(node.localName) || scope.getRegisteredDefinition(is);
                if (definition) {
                    if (is && definition.tag == node.localName || !is && !definition.extends) {
                        return upgradeWithDefinition(node, definition, isAttached);
                    }
                }
            }
        }

        function upgradeWithDefinition(element, definition, isAttached) {
            flags.upgrade && console.group("upgrade:", element.localName);
            if (definition.is) {
                element.setAttribute("is", definition.is);
            }
            implementPrototype(element, definition);
            element.__upgraded__ = true;
            created(element);
            if (isAttached) {
                scope.attached(element);
            }
            scope.upgradeSubtree(element, isAttached);
            flags.upgrade && console.groupEnd();
            return element;
        }

        function implementPrototype(element, definition) {
            if (Object.__proto__) {
                element.__proto__ = definition.prototype;
            } else {
                customMixin(element, definition.prototype, definition.native);
                element.__proto__ = definition.prototype;
            }
        }

        function customMixin(inTarget, inSrc, inNative) {
            var used = {};
            var p = inSrc;
            while (p !== inNative && p !== HTMLElement.prototype) {
                var keys = Object.getOwnPropertyNames(p);
                for (var i = 0, k; k = keys[i]; i++) {
                    if (!used[k]) {
                        Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));
                        used[k] = 1;
                    }
                }
                p = Object.getPrototypeOf(p);
            }
        }

        function created(element) {
            if (element.createdCallback) {
                element.createdCallback();
            }
        }

        scope.upgrade = upgrade;
        scope.upgradeWithDefinition = upgradeWithDefinition;
        scope.implementPrototype = implementPrototype;
    });

    window.CustomElements.addModule(function (scope) {
        var isIE = scope.isIE;
        var upgradeDocumentTree = scope.upgradeDocumentTree;
        var upgradeAll = scope.upgradeAll;
        var upgradeWithDefinition = scope.upgradeWithDefinition;
        var implementPrototype = scope.implementPrototype;
        var useNative = scope.useNative;

        function register(name, options) {
            var definition = options || {};
            if (!name) {
                throw new Error("document.registerElement: first argument `name` must not be empty");
            }
            if (name.indexOf("-") < 0) {
                throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(name) + "'.");
            }
            if (isReservedTag(name)) {
                throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(name) + "'. The type name is invalid.");
            }
            if (getRegisteredDefinition(name)) {
                throw new Error("DuplicateDefinitionError: a type with name '" + String(name) + "' is already registered");
            }
            if (!definition.prototype) {
                definition.prototype = Object.create(HTMLElement.prototype);
            }
            definition.__name = name.toLowerCase();
            definition.lifecycle = definition.lifecycle || {};
            definition.ancestry = ancestry(definition.extends);
            resolveTagName(definition);
            resolvePrototypeChain(definition);
            overrideAttributeApi(definition.prototype);
            registerDefinition(definition.__name, definition);
            definition.ctor = generateConstructor(definition);
            definition.ctor.prototype = definition.prototype;
            definition.prototype.constructor = definition.ctor;
            if (scope.ready) {
                upgradeDocumentTree(document);
            }
            return definition.ctor;
        }

        function overrideAttributeApi(prototype) {
            if (prototype.setAttribute._polyfilled) {
                return;
            }
            var setAttribute = prototype.setAttribute;
            prototype.setAttribute = function (name, value) {
                changeAttribute.call(this, name, value, setAttribute);
            };
            var removeAttribute = prototype.removeAttribute;
            prototype.removeAttribute = function (name) {
                changeAttribute.call(this, name, null, removeAttribute);
            };
            prototype.setAttribute._polyfilled = true;
        }

        function changeAttribute(name, value, operation) {
            name = name.toLowerCase();
            var oldValue = this.getAttribute(name);
            operation.apply(this, arguments);
            var newValue = this.getAttribute(name);
            if (this.attributeChangedCallback && newValue !== oldValue) {
                this.attributeChangedCallback(name, oldValue, newValue);
            }
        }

        function isReservedTag(name) {
            for (var i = 0; i < reservedTagList.length; i++) {
                if (name === reservedTagList[i]) {
                    return true;
                }
            }
        }

        var reservedTagList = ["annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph"];

        function ancestry(extnds) {
            var extendee = getRegisteredDefinition(extnds);
            if (extendee) {
                return ancestry(extendee.extends).concat([extendee]);
            }
            return [];
        }

        function resolveTagName(definition) {
            var baseTag = definition.extends;
            for (var i = 0, a; a = definition.ancestry[i]; i++) {
                baseTag = a.is && a.tag;
            }
            definition.tag = baseTag || definition.__name;
            if (baseTag) {
                definition.is = definition.__name;
            }
        }

        function resolvePrototypeChain(definition) {
            if (!Object.__proto__) {
                var nativePrototype = HTMLElement.prototype;
                if (definition.is) {
                    var inst = document.createElement(definition.tag);
                    nativePrototype = Object.getPrototypeOf(inst);
                }
                var proto = definition.prototype, ancestor;
                var foundPrototype = false;
                while (proto) {
                    if (proto == nativePrototype) {
                        foundPrototype = true;
                    }
                    ancestor = Object.getPrototypeOf(proto);
                    if (ancestor) {
                        proto.__proto__ = ancestor;
                    }
                    proto = ancestor;
                }
                if (!foundPrototype) {
                    console.warn(definition.tag + " prototype not found in prototype chain for " + definition.is);
                }
                definition.native = nativePrototype;
            }
        }

        function instantiate(definition) {
            return upgradeWithDefinition(domCreateElement(definition.tag), definition);
        }

        var registry = {};

        function getRegisteredDefinition(name) {
            if (name) {
                return registry[name.toLowerCase()];
            }
        }

        function registerDefinition(name, definition) {
            registry[name] = definition;
        }

        function generateConstructor(definition) {
            return function () {
                return instantiate(definition);
            };
        }

        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";

        function createElementNS(namespace, tag, typeExtension) {
            if (namespace === HTML_NAMESPACE) {
                return createElement(tag, typeExtension);
            } else {
                return domCreateElementNS(namespace, tag);
            }
        }

        function createElement(tag, typeExtension) {
            if (tag) {
                tag = tag.toLowerCase();
            }
            if (typeExtension) {
                typeExtension = typeExtension.toLowerCase();
            }
            var definition = getRegisteredDefinition(typeExtension || tag);
            if (definition) {
                if (tag == definition.tag && typeExtension == definition.is) {
                    return new definition.ctor();
                }
                if (!typeExtension && !definition.is) {
                    return new definition.ctor();
                }
            }
            var element;
            if (typeExtension) {
                element = createElement(tag);
                element.setAttribute("is", typeExtension);
                return element;
            }
            element = domCreateElement(tag);
            if (tag.indexOf("-") >= 0) {
                implementPrototype(element, HTMLElement);
            }
            return element;
        }

        var domCreateElement = document.createElement.bind(document);
        var domCreateElementNS = document.createElementNS.bind(document);
        var isInstance;
        if (!Object.__proto__ && !useNative) {
            isInstance = function (obj, ctor) {
                if (obj instanceof ctor) {
                    return true;
                }
                var p = obj;
                while (p) {
                    if (p === ctor.prototype) {
                        return true;
                    }
                    p = p.__proto__;
                }
                return false;
            };
        } else {
            isInstance = function (obj, base) {
                return obj instanceof base;
            };
        }
        function wrapDomMethodToForceUpgrade(obj, methodName) {
            var orig = obj[methodName];
            obj[methodName] = function () {
                var n = orig.apply(this, arguments);
                upgradeAll(n);
                return n;
            };
        }

        wrapDomMethodToForceUpgrade(Node.prototype, "cloneNode");
        wrapDomMethodToForceUpgrade(document, "importNode");
        if (isIE) {
            (function () {
                var importNode = document.importNode;
                document.importNode = function () {
                    var n = importNode.apply(document, arguments);
                    if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {
                        var f = document.createDocumentFragment();
                        f.appendChild(n);
                        return f;
                    } else {
                        return n;
                    }
                };
            })();
        }
        document.registerElement = register;
        document.createElement = createElement;
        document.createElementNS = createElementNS;
        scope.registry = registry;
        scope.instanceof = isInstance;
        scope.reservedTagList = reservedTagList;
        scope.getRegisteredDefinition = getRegisteredDefinition;
        document.register = document.registerElement;
    });

    (function (scope) {
        var useNative = scope.useNative;
        var initializeModules = scope.initializeModules;
        var isIE = scope.isIE;
        if (useNative) {
            var nop = function () {
            };
            scope.watchShadow = nop;
            scope.upgrade = nop;
            scope.upgradeAll = nop;
            scope.upgradeDocumentTree = nop;
            scope.upgradeSubtree = nop;
            scope.takeRecords = nop;
            scope.instanceof = function (obj, base) {
                return obj instanceof base;
            };
        } else {
            initializeModules();
        }
        var upgradeDocumentTree = scope.upgradeDocumentTree;
        var upgradeDocument = scope.upgradeDocument;
        if (!window.wrap) {
            if (window.ShadowDOMPolyfill) {
                window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;
                window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;
            } else {
                window.wrap = window.unwrap = function (node) {
                    return node;
                };
            }
        }
        if (window.HTMLImports) {
            window.HTMLImports.__importsParsingHook = function (elt) {
                if (elt.import) {
                    upgradeDocument(wrap(elt.import));
                }
            };
        }
        function bootstrap() {
            upgradeDocumentTree(window.wrap(document));
            window.CustomElements.ready = true;
            var requestAnimationFrame = window.requestAnimationFrame || function (f) {
                        setTimeout(f, 16);
                    };
            requestAnimationFrame(function () {
                setTimeout(function () {
                    window.CustomElements.readyTime = Date.now();
                    if (window.HTMLImports) {
                        window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;
                    }
                    document.dispatchEvent(new CustomEvent("WebComponentsReady", {
                        bubbles: true
                    }));
                });
            });
        }

        if (!window.CustomEvent || isIE && typeof window.CustomEvent !== "function") {
            window.CustomEvent = function (inType, params) {
                params = params || {};
                var e = document.createEvent("CustomEvent");
                e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
                e.preventDefault = function () {
                    Object.defineProperty(this, "defaultPrevented", {
                        get: function () {
                            return true;
                        }
                    });
                };
                return e;
            };
            window.CustomEvent.prototype = window.Event.prototype;
        }
        if (document.readyState === "complete" || scope.flags.eager) {
            bootstrap();
        } else if (document.readyState === "interactive" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {
            bootstrap();
        } else {
            var loadEvent = window.HTMLImports && !window.HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
            window.addEventListener(loadEvent, bootstrap);
        }
    })(window.CustomElements);

    (function (scope) {
        if (!Function.prototype.bind) {
            Function.prototype.bind = function (scope) {
                var self = this;
                var args = Array.prototype.slice.call(arguments, 1);
                return function () {
                    var args2 = args.slice();
                    args2.push.apply(args2, arguments);
                    return self.apply(scope, args2);
                };
            };
        }
    })(window.WebComponents);

    (function (scope) {
        "use strict";
        if (!window.performance) {
            var start = Date.now();
            window.performance = {
                now: function () {
                    return Date.now() - start;
                }
            };
        }
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function () {
                var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
                return nativeRaf ? function (callback) {
                    return nativeRaf(function () {
                        callback(performance.now());
                    });
                } : function (callback) {
                    return window.setTimeout(callback, 1e3 / 60);
                };
            }();
        }
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = function () {
                return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function (id) {
                            clearTimeout(id);
                        };
            }();
        }
    })(window.WebComponents);

    (function (scope) {
        var style = document.createElement("style");
        style.textContent = "" + "body {" + "transition: opacity ease-in 0.2s;" + " } \n" + "body[unresolved] {" + "opacity: 0; display: block; overflow: hidden; position: relative;" + " } \n";
        var head = document.querySelector("head");
        head.insertBefore(style, head.firstChild);
    })(window.WebComponents);

    (function (scope) {
        window.Platform = scope;
    })(window.WebComponents);</script>
    <script>(function () {
        function resolve() {
            document.body.removeAttribute('unresolved');
        }

        if (window.WebComponents) {
            addEventListener('WebComponentsReady', resolve);
        } else {
            if (document.readyState === 'interactive' || document.readyState === 'complete') {
                resolve();
            } else {
                addEventListener('DOMContentLoaded', resolve);
            }
        }
    }());
    window.Polymer = {
        Settings: function () {
            var user = window.Polymer || {};
            location.search.slice(1).split('&').forEach(function (o) {
                o = o.split('=');
                o[0] && (user[o[0]] = o[1] || true);
            });
            var wantShadow = user.dom === 'shadow';
            var hasShadow = Boolean(Element.prototype.createShadowRoot);
            var nativeShadow = hasShadow && !window.ShadowDOMPolyfill;
            var useShadow = wantShadow && hasShadow;
            var hasNativeImports = Boolean('import' in document.createElement('link'));
            var useNativeImports = hasNativeImports;
            var useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
            return {
                wantShadow: wantShadow,
                hasShadow: hasShadow,
                nativeShadow: nativeShadow,
                useShadow: useShadow,
                useNativeShadow: useShadow && nativeShadow,
                useNativeImports: useNativeImports,
                useNativeCustomElements: useNativeCustomElements
            };
        }()
    };
    (function () {
        var userPolymer = window.Polymer;
        window.Polymer = function (prototype) {
            if (typeof prototype === 'function') {
                prototype = prototype.prototype;
            }
            if (!prototype) {
                prototype = {};
            }
            var factory = desugar(prototype);
            prototype = factory.prototype;
            var options = {prototype: prototype};
            if (prototype.extends) {
                options.extends = prototype.extends;
            }
            Polymer.telemetry._registrate(prototype);
            document.registerElement(prototype.is, options);
            return factory;
        };
        var desugar = function (prototype) {
            var base = Polymer.Base;
            if (prototype.extends) {
                base = Polymer.Base._getExtendedPrototype(prototype.extends);
            }
            prototype = Polymer.Base.chainObject(prototype, base);
            prototype.registerCallback();
            return prototype.constructor;
        };
        window.Polymer = Polymer;
        if (userPolymer) {
            for (var i in userPolymer) {
                Polymer[i] = userPolymer[i];
            }
        }
        Polymer.Class = desugar;
    }());
    Polymer.telemetry = {
        registrations: [],
        _regLog: function (prototype) {
            console.log('[' + prototype.is + ']: registered');
        },
        _registrate: function (prototype) {
            this.registrations.push(prototype);
            Polymer.log && this._regLog(prototype);
        },
        dumpRegistrations: function () {
            this.registrations.forEach(this._regLog);
        }
    };
    Object.defineProperty(window, 'currentImport', {
        enumerable: true,
        configurable: true,
        get: function () {
            return (document._currentScript || document.currentScript).ownerDocument;
        }
    });
    Polymer.RenderStatus = {
        _ready: false,
        _callbacks: [],
        whenReady: function (cb) {
            if (this._ready) {
                cb();
            } else {
                this._callbacks.push(cb);
            }
        },
        _makeReady: function () {
            this._ready = true;
            this._callbacks.forEach(function (cb) {
                cb();
            });
            this._callbacks = [];
        },
        _catchFirstRender: function () {
            requestAnimationFrame(function () {
                Polymer.RenderStatus._makeReady();
            });
        }
    };
    if (window.HTMLImports) {
        HTMLImports.whenReady(function () {
            Polymer.RenderStatus._catchFirstRender();
        });
    } else {
        Polymer.RenderStatus._catchFirstRender();
    }
    Polymer.ImportStatus = Polymer.RenderStatus;
    Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;
    Polymer.Base = {
        __isPolymerInstance__: true,
        _addFeature: function (feature) {
            this.extend(this, feature);
        },
        registerCallback: function () {
            this._desugarBehaviors();
            this._doBehavior('beforeRegister');
            this._registerFeatures();
            this._doBehavior('registered');
        },
        createdCallback: function () {
            Polymer.telemetry.instanceCount++;
            this.root = this;
            this._doBehavior('created');
            this._initFeatures();
        },
        attachedCallback: function () {
            Polymer.RenderStatus.whenReady(function () {
                this.isAttached = true;
                this._doBehavior('attached');
            }.bind(this));
        },
        detachedCallback: function () {
            this.isAttached = false;
            this._doBehavior('detached');
        },
        attributeChangedCallback: function (name) {
            this._attributeChangedImpl(name);
            this._doBehavior('attributeChanged', arguments);
        },
        _attributeChangedImpl: function (name) {
            this._setAttributeToProperty(this, name);
        },
        extend: function (prototype, api) {
            if (prototype && api) {
                Object.getOwnPropertyNames(api).forEach(function (n) {
                    this.copyOwnProperty(n, api, prototype);
                }, this);
            }
            return prototype || api;
        },
        mixin: function (target, source) {
            for (var i in source) {
                target[i] = source[i];
            }
            return target;
        },
        copyOwnProperty: function (name, source, target) {
            var pd = Object.getOwnPropertyDescriptor(source, name);
            if (pd) {
                Object.defineProperty(target, name, pd);
            }
        },
        _log: console.log.apply.bind(console.log, console),
        _warn: console.warn.apply.bind(console.warn, console),
        _error: console.error.apply.bind(console.error, console),
        _logf: function () {
            return this._logPrefix.concat([this.is]).concat(Array.prototype.slice.call(arguments, 0));
        }
    };
    Polymer.Base._logPrefix = function () {
        var color = window.chrome || /firefox/i.test(navigator.userAgent);
        return color ? [
            '%c[%s::%s]:',
            'font-weight: bold; background-color:#EEEE00;'
        ] : ['[%s::%s]:'];
    }();
    Polymer.Base.chainObject = function (object, inherited) {
        if (object && inherited && object !== inherited) {
            if (!Object.__proto__) {
                object = Polymer.Base.extend(Object.create(inherited), object);
            }
            object.__proto__ = inherited;
        }
        return object;
    };
    Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
    if (window.CustomElements) {
        Polymer.instanceof = CustomElements.instanceof;
    } else {
        Polymer.instanceof = function (obj, ctor) {
            return obj instanceof ctor;
        };
    }
    Polymer.isInstance = function (obj) {
        return Boolean(obj && obj.__isPolymerInstance__);
    };
    Polymer.telemetry.instanceCount = 0;
    (function () {
        var modules = {};
        var lcModules = {};
        var findModule = function (id) {
            return modules[id] || lcModules[id.toLowerCase()];
        };
        var DomModule = function () {
            return document.createElement('dom-module');
        };
        DomModule.prototype = Object.create(HTMLElement.prototype);
        Polymer.Base.extend(DomModule.prototype, {
            constructor: DomModule,
            createdCallback: function () {
                this.register();
            },
            register: function (id) {
                var id = id || this.id || this.getAttribute('name') || this.getAttribute('is');
                if (id) {
                    this.id = id;
                    modules[id] = this;
                    lcModules[id.toLowerCase()] = this;
                }
            },
            import: function (id, selector) {
                if (id) {
                    var m = findModule(id);
                    if (!m) {
                        forceDocumentUpgrade();
                        m = findModule(id);
                    }
                    if (m && selector) {
                        m = m.querySelector(selector);
                    }
                    return m;
                }
            }
        });
        var cePolyfill = window.CustomElements && !CustomElements.useNative;
        document.registerElement('dom-module', DomModule);
        function forceDocumentUpgrade() {
            if (cePolyfill) {
                var script = document._currentScript || document.currentScript;
                var doc = script && script.ownerDocument || document;
                if (doc) {
                    CustomElements.upgradeAll(doc);
                }
            }
        }
    }());
    Polymer.Base._addFeature({
        _prepIs: function () {
            if (!this.is) {
                var module = (document._currentScript || document.currentScript).parentNode;
                if (module.localName === 'dom-module') {
                    var id = module.id || module.getAttribute('name') || module.getAttribute('is');
                    this.is = id;
                }
            }
            if (this.is) {
                this.is = this.is.toLowerCase();
            }
        }
    });
    Polymer.Base._addFeature({
        behaviors: [],
        _desugarBehaviors: function () {
            if (this.behaviors.length) {
                this.behaviors = this._desugarSomeBehaviors(this.behaviors);
            }
        },
        _desugarSomeBehaviors: function (behaviors) {
            behaviors = this._flattenBehaviorsList(behaviors);
            for (var i = behaviors.length - 1; i >= 0; i--) {
                this._mixinBehavior(behaviors[i]);
            }
            return behaviors;
        },
        _flattenBehaviorsList: function (behaviors) {
            var flat = [];
            behaviors.forEach(function (b) {
                if (b instanceof Array) {
                    flat = flat.concat(this._flattenBehaviorsList(b));
                } else if (b) {
                    flat.push(b);
                } else {
                    this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
                }
            }, this);
            return flat;
        },
        _mixinBehavior: function (b) {
            Object.getOwnPropertyNames(b).forEach(function (n) {
                switch (n) {
                    case 'hostAttributes':
                    case 'registered':
                    case 'properties':
                    case 'observers':
                    case 'listeners':
                    case 'created':
                    case 'attached':
                    case 'detached':
                    case 'attributeChanged':
                    case 'configure':
                    case 'ready':
                        break;
                    default:
                        if (!this.hasOwnProperty(n)) {
                            this.copyOwnProperty(n, b, this);
                        }
                        break;
                }
            }, this);
        },
        _prepBehaviors: function () {
            this._prepFlattenedBehaviors(this.behaviors);
        },
        _prepFlattenedBehaviors: function (behaviors) {
            for (var i = 0, l = behaviors.length; i < l; i++) {
                this._prepBehavior(behaviors[i]);
            }
            this._prepBehavior(this);
        },
        _doBehavior: function (name, args) {
            this.behaviors.forEach(function (b) {
                this._invokeBehavior(b, name, args);
            }, this);
            this._invokeBehavior(this, name, args);
        },
        _invokeBehavior: function (b, name, args) {
            var fn = b[name];
            if (fn) {
                fn.apply(this, args || Polymer.nar);
            }
        },
        _marshalBehaviors: function () {
            this.behaviors.forEach(function (b) {
                this._marshalBehavior(b);
            }, this);
            this._marshalBehavior(this);
        }
    });
    Polymer.Base._addFeature({
        _getExtendedPrototype: function (tag) {
            return this._getExtendedNativePrototype(tag);
        },
        _nativePrototypes: {},
        _getExtendedNativePrototype: function (tag) {
            var p = this._nativePrototypes[tag];
            if (!p) {
                var np = this.getNativePrototype(tag);
                p = this.extend(Object.create(np), Polymer.Base);
                this._nativePrototypes[tag] = p;
            }
            return p;
        },
        getNativePrototype: function (tag) {
            return Object.getPrototypeOf(document.createElement(tag));
        }
    });
    Polymer.Base._addFeature({
        _prepConstructor: function () {
            this._factoryArgs = this.extends ? [
                this.extends,
                this.is
            ] : [this.is];
            var ctor = function () {
                return this._factory(arguments);
            };
            if (this.hasOwnProperty('extends')) {
                ctor.extends = this.extends;
            }
            Object.defineProperty(this, 'constructor', {
                value: ctor,
                writable: true,
                configurable: true
            });
            ctor.prototype = this;
        },
        _factory: function (args) {
            var elt = document.createElement.apply(document, this._factoryArgs);
            if (this.factoryImpl) {
                this.factoryImpl.apply(elt, args);
            }
            return elt;
        }
    });
    Polymer.nob = Object.create(null);
    Polymer.Base._addFeature({
        properties: {},
        getPropertyInfo: function (property) {
            var info = this._getPropertyInfo(property, this.properties);
            if (!info) {
                this.behaviors.some(function (b) {
                    return info = this._getPropertyInfo(property, b.properties);
                }, this);
            }
            return info || Polymer.nob;
        },
        _getPropertyInfo: function (property, properties) {
            var p = properties && properties[property];
            if (typeof p === 'function') {
                p = properties[property] = {type: p};
            }
            if (p) {
                p.defined = true;
            }
            return p;
        }
    });
    Polymer.CaseMap = {
        _caseMap: {},
        dashToCamelCase: function (dash) {
            var mapped = Polymer.CaseMap._caseMap[dash];
            if (mapped) {
                return mapped;
            }
            if (dash.indexOf('-') < 0) {
                return Polymer.CaseMap._caseMap[dash] = dash;
            }
            return Polymer.CaseMap._caseMap[dash] = dash.replace(/-([a-z])/g, function (m) {
                return m[1].toUpperCase();
            });
        },
        camelToDashCase: function (camel) {
            var mapped = Polymer.CaseMap._caseMap[camel];
            if (mapped) {
                return mapped;
            }
            return Polymer.CaseMap._caseMap[camel] = camel.replace(/([a-z][A-Z])/g, function (g) {
                return g[0] + '-' + g[1].toLowerCase();
            });
        }
    };
    Polymer.Base._addFeature({
        _prepAttributes: function () {
            this._aggregatedAttributes = {};
        },
        _addHostAttributes: function (attributes) {
            if (attributes) {
                this.mixin(this._aggregatedAttributes, attributes);
            }
        },
        _marshalHostAttributes: function () {
            this._applyAttributes(this, this._aggregatedAttributes);
        },
        _applyAttributes: function (node, attr$) {
            for (var n in attr$) {
                if (!this.hasAttribute(n) && n !== 'class') {
                    this.serializeValueToAttribute(attr$[n], n, this);
                }
            }
        },
        _marshalAttributes: function () {
            this._takeAttributesToModel(this);
        },
        _takeAttributesToModel: function (model) {
            for (var i = 0, l = this.attributes.length; i < l; i++) {
                this._setAttributeToProperty(model, this.attributes[i].name);
            }
        },
        _setAttributeToProperty: function (model, attrName) {
            if (!this._serializing) {
                var propName = Polymer.CaseMap.dashToCamelCase(attrName);
                var info = this.getPropertyInfo(propName);
                if (info.defined || this._propertyEffects && this._propertyEffects[propName]) {
                    var val = this.getAttribute(attrName);
                    model[propName] = this.deserialize(val, info.type);
                }
            }
        },
        _serializing: false,
        reflectPropertyToAttribute: function (name) {
            this._serializing = true;
            this.serializeValueToAttribute(this[name], Polymer.CaseMap.camelToDashCase(name));
            this._serializing = false;
        },
        serializeValueToAttribute: function (value, attribute, node) {
            var str = this.serialize(value);
            (node || this)[str === undefined ? 'removeAttribute' : 'setAttribute'](attribute, str);
        },
        deserialize: function (value, type) {
            switch (type) {
                case Number:
                    value = Number(value);
                    break;
                case Boolean:
                    value = value !== null;
                    break;
                case Object:
                    try {
                        value = JSON.parse(value);
                    } catch (x) {
                    }
                    break;
                case Array:
                    try {
                        value = JSON.parse(value);
                    } catch (x) {
                        value = null;
                        console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
                    }
                    break;
                case Date:
                    value = new Date(value);
                    break;
                case String:
                default:
                    break;
            }
            return value;
        },
        serialize: function (value) {
            switch (typeof value) {
                case 'boolean':
                    return value ? '' : undefined;
                case 'object':
                    if (value instanceof Date) {
                        return value;
                    } else if (value) {
                        try {
                            return JSON.stringify(value);
                        } catch (x) {
                            return '';
                        }
                    }
                default:
                    return value != null ? value : undefined;
            }
        }
    });
    Polymer.Base._addFeature({
        _setupDebouncers: function () {
            this._debouncers = {};
        },
        debounce: function (jobName, callback, wait) {
            return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
        },
        isDebouncerActive: function (jobName) {
            var debouncer = this._debouncers[jobName];
            return debouncer && debouncer.finish;
        },
        flushDebouncer: function (jobName) {
            var debouncer = this._debouncers[jobName];
            if (debouncer) {
                debouncer.complete();
            }
        },
        cancelDebouncer: function (jobName) {
            var debouncer = this._debouncers[jobName];
            if (debouncer) {
                debouncer.stop();
            }
        }
    });
    Polymer.version = '1.2.0';
    Polymer.Base._addFeature({
        _registerFeatures: function () {
            this._prepIs();
            this._prepAttributes();
            this._prepBehaviors();
            this._prepConstructor();
        },
        _prepBehavior: function (b) {
            this._addHostAttributes(b.hostAttributes);
        },
        _marshalBehavior: function (b) {
        },
        _initFeatures: function () {
            this._marshalHostAttributes();
            this._setupDebouncers();
            this._marshalBehaviors();
        }
    });</script>

    <script>Polymer.Base._addFeature({
        _prepTemplate: function () {
            this._template = this._template || Polymer.DomModule.import(this.is, 'template');
            if (this._template && this._template.hasAttribute('is')) {
                this._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));
            }
            if (this._template && !this._template.content && HTMLTemplateElement.bootstrap) {
                HTMLTemplateElement.decorate(this._template);
                HTMLTemplateElement.bootstrap(this._template.content);
            }
        },
        _stampTemplate: function () {
            if (this._template) {
                this.root = this.instanceTemplate(this._template);
            }
        },
        instanceTemplate: function (template) {
            var dom = document.importNode(template._content || template.content, true);
            return dom;
        }
    });
    (function () {
        var baseAttachedCallback = Polymer.Base.attachedCallback;
        Polymer.Base._addFeature({
            _hostStack: [],
            ready: function () {
            },
            _pushHost: function (host) {
                this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
                if (host && host._clients) {
                    host._clients.push(this);
                }
                this._beginHost();
            },
            _beginHost: function () {
                Polymer.Base._hostStack.push(this);
                if (!this._clients) {
                    this._clients = [];
                }
            },
            _popHost: function () {
                Polymer.Base._hostStack.pop();
            },
            _tryReady: function () {
                if (this._canReady()) {
                    this._ready();
                }
            },
            _canReady: function () {
                return !this.dataHost || this.dataHost._clientsReadied;
            },
            _ready: function () {
                this._beforeClientsReady();
                this._setupRoot();
                this._readyClients();
                this._afterClientsReady();
                this._readySelf();
            },
            _readyClients: function () {
                this._beginDistribute();
                var c$ = this._clients;
                for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
                    c._ready();
                }
                this._finishDistribute();
                this._clientsReadied = true;
                this._clients = null;
            },
            _readySelf: function () {
                this._doBehavior('ready');
                this._readied = true;
                if (this._attachedPending) {
                    this._attachedPending = false;
                    this.attachedCallback();
                }
            },
            _beforeClientsReady: function () {
            },
            _afterClientsReady: function () {
            },
            _beforeAttached: function () {
            },
            attachedCallback: function () {
                if (this._readied) {
                    this._beforeAttached();
                    baseAttachedCallback.call(this);
                } else {
                    this._attachedPending = true;
                }
            }
        });
    }());
    Polymer.ArraySplice = function () {
        function newSplice(index, removed, addedCount) {
            return {
                index: index,
                removed: removed,
                addedCount: addedCount
            };
        }

        var EDIT_LEAVE = 0;
        var EDIT_UPDATE = 1;
        var EDIT_ADD = 2;
        var EDIT_DELETE = 3;

        function ArraySplice() {
        }

        ArraySplice.prototype = {
            calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
                var rowCount = oldEnd - oldStart + 1;
                var columnCount = currentEnd - currentStart + 1;
                var distances = new Array(rowCount);
                for (var i = 0; i < rowCount; i++) {
                    distances[i] = new Array(columnCount);
                    distances[i][0] = i;
                }
                for (var j = 0; j < columnCount; j++)
                    distances[0][j] = j;
                for (var i = 1; i < rowCount; i++) {
                    for (var j = 1; j < columnCount; j++) {
                        if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
                            distances[i][j] = distances[i - 1][j - 1];
                        else {
                            var north = distances[i - 1][j] + 1;
                            var west = distances[i][j - 1] + 1;
                            distances[i][j] = north < west ? north : west;
                        }
                    }
                }
                return distances;
            },
            spliceOperationsFromEditDistances: function (distances) {
                var i = distances.length - 1;
                var j = distances[0].length - 1;
                var current = distances[i][j];
                var edits = [];
                while (i > 0 || j > 0) {
                    if (i == 0) {
                        edits.push(EDIT_ADD);
                        j--;
                        continue;
                    }
                    if (j == 0) {
                        edits.push(EDIT_DELETE);
                        i--;
                        continue;
                    }
                    var northWest = distances[i - 1][j - 1];
                    var west = distances[i - 1][j];
                    var north = distances[i][j - 1];
                    var min;
                    if (west < north)
                        min = west < northWest ? west : northWest;
                    else
                        min = north < northWest ? north : northWest;
                    if (min == northWest) {
                        if (northWest == current) {
                            edits.push(EDIT_LEAVE);
                        } else {
                            edits.push(EDIT_UPDATE);
                            current = northWest;
                        }
                        i--;
                        j--;
                    } else if (min == west) {
                        edits.push(EDIT_DELETE);
                        i--;
                        current = west;
                    } else {
                        edits.push(EDIT_ADD);
                        j--;
                        current = north;
                    }
                }
                edits.reverse();
                return edits;
            },
            calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
                var prefixCount = 0;
                var suffixCount = 0;
                var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
                if (currentStart == 0 && oldStart == 0)
                    prefixCount = this.sharedPrefix(current, old, minLength);
                if (currentEnd == current.length && oldEnd == old.length)
                    suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
                currentStart += prefixCount;
                oldStart += prefixCount;
                currentEnd -= suffixCount;
                oldEnd -= suffixCount;
                if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
                    return [];
                if (currentStart == currentEnd) {
                    var splice = newSplice(currentStart, [], 0);
                    while (oldStart < oldEnd)
                        splice.removed.push(old[oldStart++]);
                    return [splice];
                } else if (oldStart == oldEnd)
                    return [newSplice(currentStart, [], currentEnd - currentStart)];
                var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
                var splice = undefined;
                var splices = [];
                var index = currentStart;
                var oldIndex = oldStart;
                for (var i = 0; i < ops.length; i++) {
                    switch (ops[i]) {
                        case EDIT_LEAVE:
                            if (splice) {
                                splices.push(splice);
                                splice = undefined;
                            }
                            index++;
                            oldIndex++;
                            break;
                        case EDIT_UPDATE:
                            if (!splice)
                                splice = newSplice(index, [], 0);
                            splice.addedCount++;
                            index++;
                            splice.removed.push(old[oldIndex]);
                            oldIndex++;
                            break;
                        case EDIT_ADD:
                            if (!splice)
                                splice = newSplice(index, [], 0);
                            splice.addedCount++;
                            index++;
                            break;
                        case EDIT_DELETE:
                            if (!splice)
                                splice = newSplice(index, [], 0);
                            splice.removed.push(old[oldIndex]);
                            oldIndex++;
                            break;
                    }
                }
                if (splice) {
                    splices.push(splice);
                }
                return splices;
            },
            sharedPrefix: function (current, old, searchLength) {
                for (var i = 0; i < searchLength; i++)
                    if (!this.equals(current[i], old[i]))
                        return i;
                return searchLength;
            },
            sharedSuffix: function (current, old, searchLength) {
                var index1 = current.length;
                var index2 = old.length;
                var count = 0;
                while (count < searchLength && this.equals(current[--index1], old[--index2]))
                    count++;
                return count;
            },
            calculateSplices: function (current, previous) {
                return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
            },
            equals: function (currentValue, previousValue) {
                return currentValue === previousValue;
            }
        };
        return new ArraySplice();
    }();
    Polymer.domInnerHTML = function () {
        var escapeAttrRegExp = /[&\u00A0"]/g;
        var escapeDataRegExp = /[&\u00A0<>]/g;

        function escapeReplace(c) {
            switch (c) {
                case '&':
                    return '&amp;';
                case '<':
                    return '&lt;';
                case '>':
                    return '&gt;';
                case '"':
                    return '&quot;';
                case '\xA0':
                    return '&nbsp;';
            }
        }

        function escapeAttr(s) {
            return s.replace(escapeAttrRegExp, escapeReplace);
        }

        function escapeData(s) {
            return s.replace(escapeDataRegExp, escapeReplace);
        }

        function makeSet(arr) {
            var set = {};
            for (var i = 0; i < arr.length; i++) {
                set[arr[i]] = true;
            }
            return set;
        }

        var voidElements = makeSet([
            'area',
            'base',
            'br',
            'col',
            'command',
            'embed',
            'hr',
            'img',
            'input',
            'keygen',
            'link',
            'meta',
            'param',
            'source',
            'track',
            'wbr'
        ]);
        var plaintextParents = makeSet([
            'style',
            'script',
            'xmp',
            'iframe',
            'noembed',
            'noframes',
            'plaintext',
            'noscript'
        ]);

        function getOuterHTML(node, parentNode, composed) {
            switch (node.nodeType) {
                case Node.ELEMENT_NODE:
                    var tagName = node.localName;
                    var s = '<' + tagName;
                    var attrs = node.attributes;
                    for (var i = 0, attr; attr = attrs[i]; i++) {
                        s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
                    }
                    s += '>';
                    if (voidElements[tagName]) {
                        return s;
                    }
                    return s + getInnerHTML(node, composed) + '</' + tagName + '>';
                case Node.TEXT_NODE:
                    var data = node.data;
                    if (parentNode && plaintextParents[parentNode.localName]) {
                        return data;
                    }
                    return escapeData(data);
                case Node.COMMENT_NODE:
                    return '<!--' + node.data + '-->';
                default:
                    console.error(node);
                    throw new Error('not implemented');
            }
        }

        function getInnerHTML(node, composed) {
            if (node instanceof HTMLTemplateElement)
                node = node.content;
            var s = '';
            var c$ = Polymer.dom(node).childNodes;
            c$ = composed ? node._composedChildren : c$;
            for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
                s += getOuterHTML(child, node, composed);
            }
            return s;
        }

        return {getInnerHTML: getInnerHTML};
    }();
    Polymer.DomApi = function () {
        'use strict';
        var Settings = Polymer.Settings;
        var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
        var nativeInsertBefore = Element.prototype.insertBefore;
        var nativeRemoveChild = Element.prototype.removeChild;
        var nativeAppendChild = Element.prototype.appendChild;
        var nativeCloneNode = Element.prototype.cloneNode;
        var nativeImportNode = Document.prototype.importNode;
        var DomApi = function (node) {
            this.node = node;
            if (this.patch) {
                this.patch();
            }
        };
        if (window.wrap && Settings.useShadow && !Settings.useNativeShadow) {
            DomApi = function (node) {
                this.node = wrap(node);
                if (this.patch) {
                    this.patch();
                }
            };
        }
        DomApi.prototype = {
            flush: function () {
                Polymer.dom.flush();
            },
            _lazyDistribute: function (host) {
                if (host.shadyRoot && host.shadyRoot._distributionClean) {
                    host.shadyRoot._distributionClean = false;
                    Polymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));
                }
            },
            appendChild: function (node) {
                return this._addNode(node);
            },
            insertBefore: function (node, ref_node) {
                return this._addNode(node, ref_node);
            },
            _addNode: function (node, ref_node) {
                this._removeNodeFromParent(node);
                var addedInsertionPoint;
                var root = this.getOwnerRoot();
                if (root) {
                    addedInsertionPoint = this._maybeAddInsertionPoint(node, this.node);
                }
                if (this._nodeHasLogicalChildren(this.node)) {
                    if (ref_node) {
                        var children = this.childNodes;
                        var index = children.indexOf(ref_node);
                        if (index < 0) {
                            throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
                        }
                    }
                    this._addLogicalInfo(node, this.node, index);
                }
                this._addNodeToHost(node);
                if (!this._maybeDistribute(node, this.node) && !this._tryRemoveUndistributedNode(node)) {
                    if (ref_node) {
                        ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
                    }
                    var container = this.node._isShadyRoot ? this.node.host : this.node;
                    addToComposedParent(container, node, ref_node);
                    if (ref_node) {
                        nativeInsertBefore.call(container, node, ref_node);
                    } else {
                        nativeAppendChild.call(container, node);
                    }
                }
                if (addedInsertionPoint) {
                    this._updateInsertionPoints(root.host);
                }
                this.notifyObserver();
                return node;
            },
            removeChild: function (node) {
                if (factory(node).parentNode !== this.node) {
                    console.warn('The node to be removed is not a child of this node', node);
                }
                this._removeNodeFromHost(node);
                if (!this._maybeDistribute(node, this.node)) {
                    var container = this.node._isShadyRoot ? this.node.host : this.node;
                    if (container === node.parentNode) {
                        removeFromComposedParent(container, node);
                        nativeRemoveChild.call(container, node);
                    }
                }
                this.notifyObserver();
                return node;
            },
            replaceChild: function (node, ref_node) {
                this.insertBefore(node, ref_node);
                this.removeChild(ref_node);
                return node;
            },
            _hasCachedOwnerRoot: function (node) {
                return Boolean(node._ownerShadyRoot !== undefined);
            },
            getOwnerRoot: function () {
                return this._ownerShadyRootForNode(this.node);
            },
            _ownerShadyRootForNode: function (node) {
                if (!node) {
                    return;
                }
                if (node._ownerShadyRoot === undefined) {
                    var root;
                    if (node._isShadyRoot) {
                        root = node;
                    } else {
                        var parent = Polymer.dom(node).parentNode;
                        if (parent) {
                            root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
                        } else {
                            root = null;
                        }
                    }
                    node._ownerShadyRoot = root;
                }
                return node._ownerShadyRoot;
            },
            _maybeDistribute: function (node, parent) {
                var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && Polymer.dom(node).querySelector(CONTENT);
                var wrappedContent = fragContent && Polymer.dom(fragContent).parentNode.nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
                var hasContent = fragContent || node.localName === CONTENT;
                if (hasContent) {
                    var root = this._ownerShadyRootForNode(parent);
                    if (root) {
                        var host = root.host;
                        this._lazyDistribute(host);
                    }
                }
                var parentNeedsDist = this._parentNeedsDistribution(parent);
                if (parentNeedsDist) {
                    this._lazyDistribute(parent);
                }
                return parentNeedsDist || hasContent && !wrappedContent;
            },
            _maybeAddInsertionPoint: function (node, parent) {
                var added;
                if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
                    var c$ = factory(node).querySelectorAll(CONTENT);
                    for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
                        np = factory(n).parentNode;
                        if (np === node) {
                            np = parent;
                        }
                        na = this._maybeAddInsertionPoint(n, np);
                        added = added || na;
                    }
                } else if (node.localName === CONTENT) {
                    saveLightChildrenIfNeeded(parent);
                    saveLightChildrenIfNeeded(node);
                    added = true;
                }
                return added;
            },
            _tryRemoveUndistributedNode: function (node) {
                if (this.node.shadyRoot) {
                    var parent = getComposedParent(node);
                    if (parent) {
                        nativeRemoveChild.call(parent, node);
                    }
                    return true;
                }
            },
            _updateInsertionPoints: function (host) {
                var i$ = host.shadyRoot._insertionPoints = factory(host.shadyRoot).querySelectorAll(CONTENT);
                for (var i = 0, c; i < i$.length; i++) {
                    c = i$[i];
                    saveLightChildrenIfNeeded(c);
                    saveLightChildrenIfNeeded(factory(c).parentNode);
                }
            },
            _nodeHasLogicalChildren: function (node) {
                return Boolean(node._lightChildren !== undefined);
            },
            _parentNeedsDistribution: function (parent) {
                return parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot);
            },
            _removeNodeFromParent: function (node) {
                var parent = node._lightParent || node.parentNode;
                if (parent && hasDomApi(parent)) {
                    factory(parent).notifyObserver();
                }
                this._removeNodeFromHost(node, true);
            },
            _removeNodeFromHost: function (node, ensureComposedRemoval) {
                var hostNeedsDist;
                var root;
                var parent = node._lightParent;
                if (parent) {
                    factory(node)._distributeParent();
                    root = this._ownerShadyRootForNode(node);
                    if (root) {
                        root.host._elementRemove(node);
                        hostNeedsDist = this._removeDistributedChildren(root, node);
                    }
                    this._removeLogicalInfo(node, parent);
                }
                this._removeOwnerShadyRoot(node);
                if (root && hostNeedsDist) {
                    this._updateInsertionPoints(root.host);
                    this._lazyDistribute(root.host);
                } else if (ensureComposedRemoval) {
                    removeFromComposedParent(getComposedParent(node), node);
                }
            },
            _removeDistributedChildren: function (root, container) {
                var hostNeedsDist;
                var ip$ = root._insertionPoints;
                for (var i = 0; i < ip$.length; i++) {
                    var content = ip$[i];
                    if (this._contains(container, content)) {
                        var dc$ = factory(content).getDistributedNodes();
                        for (var j = 0; j < dc$.length; j++) {
                            hostNeedsDist = true;
                            var node = dc$[j];
                            var parent = node.parentNode;
                            if (parent) {
                                removeFromComposedParent(parent, node);
                                nativeRemoveChild.call(parent, node);
                            }
                        }
                    }
                }
                return hostNeedsDist;
            },
            _contains: function (container, node) {
                while (node) {
                    if (node == container) {
                        return true;
                    }
                    node = factory(node).parentNode;
                }
            },
            _addNodeToHost: function (node) {
                var root = this.getOwnerRoot();
                if (root) {
                    root.host._elementAdd(node);
                }
            },
            _addLogicalInfo: function (node, container, index) {
                var children = factory(container).childNodes;
                index = index === undefined ? children.length : index;
                if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                    var c$ = Array.prototype.slice.call(node.childNodes);
                    for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
                        children.splice(index++, 0, n);
                        n._lightParent = container;
                    }
                } else {
                    children.splice(index, 0, node);
                    node._lightParent = container;
                }
            },
            _removeLogicalInfo: function (node, container) {
                var children = factory(container).childNodes;
                var index = children.indexOf(node);
                if (index < 0 || container !== node._lightParent) {
                    throw Error('The node to be removed is not a child of this node');
                }
                children.splice(index, 1);
                node._lightParent = null;
            },
            _removeOwnerShadyRoot: function (node) {
                if (this._hasCachedOwnerRoot(node)) {
                    var c$ = factory(node).childNodes;
                    for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
                        this._removeOwnerShadyRoot(n);
                    }
                }
                node._ownerShadyRoot = undefined;
            },
            _firstComposedNode: function (content) {
                var n$ = factory(content).getDistributedNodes();
                for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
                    p$ = factory(n).getDestinationInsertionPoints();
                    if (p$[p$.length - 1] === content) {
                        return n;
                    }
                }
            },
            querySelector: function (selector) {
                return this.querySelectorAll(selector)[0];
            },
            querySelectorAll: function (selector) {
                return this._query(function (n) {
                    return matchesSelector.call(n, selector);
                }, this.node);
            },
            _query: function (matcher, node) {
                node = node || this.node;
                var list = [];
                this._queryElements(factory(node).childNodes, matcher, list);
                return list;
            },
            _queryElements: function (elements, matcher, list) {
                for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
                    if (c.nodeType === Node.ELEMENT_NODE) {
                        this._queryElement(c, matcher, list);
                    }
                }
            },
            _queryElement: function (node, matcher, list) {
                if (matcher(node)) {
                    list.push(node);
                }
                this._queryElements(factory(node).childNodes, matcher, list);
            },
            getDestinationInsertionPoints: function () {
                return this.node._destinationInsertionPoints || [];
            },
            getDistributedNodes: function () {
                return this.node._distributedNodes || [];
            },
            queryDistributedElements: function (selector) {
                var c$ = this.getEffectiveChildNodes();
                var list = [];
                for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
                    if (c.nodeType === Node.ELEMENT_NODE && matchesSelector.call(c, selector)) {
                        list.push(c);
                    }
                }
                return list;
            },
            getEffectiveChildNodes: function () {
                var list = [];
                var c$ = this.childNodes;
                for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
                    if (c.localName === CONTENT) {
                        var d$ = factory(c).getDistributedNodes();
                        for (var j = 0; j < d$.length; j++) {
                            list.push(d$[j]);
                        }
                    } else {
                        list.push(c);
                    }
                }
                return list;
            },
            _clear: function () {
                while (this.childNodes.length) {
                    this.removeChild(this.childNodes[0]);
                }
            },
            setAttribute: function (name, value) {
                this.node.setAttribute(name, value);
                this._distributeParent();
            },
            removeAttribute: function (name) {
                this.node.removeAttribute(name);
                this._distributeParent();
            },
            _distributeParent: function () {
                if (this._parentNeedsDistribution(this.parentNode)) {
                    this._lazyDistribute(this.parentNode);
                }
            },
            cloneNode: function (deep) {
                var n = nativeCloneNode.call(this.node, false);
                if (deep) {
                    var c$ = this.childNodes;
                    var d = factory(n);
                    for (var i = 0, nc; i < c$.length; i++) {
                        nc = factory(c$[i]).cloneNode(true);
                        d.appendChild(nc);
                    }
                }
                return n;
            },
            importNode: function (externalNode, deep) {
                var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
                var n = nativeImportNode.call(doc, externalNode, false);
                if (deep) {
                    var c$ = factory(externalNode).childNodes;
                    var d = factory(n);
                    for (var i = 0, nc; i < c$.length; i++) {
                        nc = factory(doc).importNode(c$[i], true);
                        d.appendChild(nc);
                    }
                }
                return n;
            },
            observeNodes: function (callback) {
                if (callback) {
                    if (!this.observer) {
                        this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);
                    }
                    return this.observer.addListener(callback);
                }
            },
            unobserveNodes: function (handle) {
                if (this.observer) {
                    this.observer.removeListener(handle);
                }
            },
            notifyObserver: function () {
                if (this.observer) {
                    this.observer.notify();
                }
            }
        };
        if (!Settings.useShadow) {
            Object.defineProperties(DomApi.prototype, {
                childNodes: {
                    get: function () {
                        var c$ = getLightChildren(this.node);
                        return Array.isArray(c$) ? c$ : Array.prototype.slice.call(c$);
                    },
                    configurable: true
                },
                children: {
                    get: function () {
                        return Array.prototype.filter.call(this.childNodes, function (n) {
                            return n.nodeType === Node.ELEMENT_NODE;
                        });
                    },
                    configurable: true
                },
                parentNode: {
                    get: function () {
                        return this.node._lightParent || getComposedParent(this.node);
                    },
                    configurable: true
                },
                firstChild: {
                    get: function () {
                        return this.childNodes[0];
                    },
                    configurable: true
                },
                lastChild: {
                    get: function () {
                        var c$ = this.childNodes;
                        return c$[c$.length - 1];
                    },
                    configurable: true
                },
                nextSibling: {
                    get: function () {
                        var c$ = this.parentNode && factory(this.parentNode).childNodes;
                        if (c$) {
                            return c$[Array.prototype.indexOf.call(c$, this.node) + 1];
                        }
                    },
                    configurable: true
                },
                previousSibling: {
                    get: function () {
                        var c$ = this.parentNode && factory(this.parentNode).childNodes;
                        if (c$) {
                            return c$[Array.prototype.indexOf.call(c$, this.node) - 1];
                        }
                    },
                    configurable: true
                },
                firstElementChild: {
                    get: function () {
                        return this.children[0];
                    },
                    configurable: true
                },
                lastElementChild: {
                    get: function () {
                        var c$ = this.children;
                        return c$[c$.length - 1];
                    },
                    configurable: true
                },
                nextElementSibling: {
                    get: function () {
                        var c$ = this.parentNode && factory(this.parentNode).children;
                        if (c$) {
                            return c$[Array.prototype.indexOf.call(c$, this.node) + 1];
                        }
                    },
                    configurable: true
                },
                previousElementSibling: {
                    get: function () {
                        var c$ = this.parentNode && factory(this.parentNode).children;
                        if (c$) {
                            return c$[Array.prototype.indexOf.call(c$, this.node) - 1];
                        }
                    },
                    configurable: true
                },
                textContent: {
                    get: function () {
                        var nt = this.node.nodeType;
                        if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
                            return this.node.textContent;
                        } else {
                            var tc = [];
                            for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
                                if (c.nodeType !== Node.COMMENT_NODE) {
                                    tc.push(c.textContent);
                                }
                            }
                            return tc.join('');
                        }
                    },
                    set: function (text) {
                        var nt = this.node.nodeType;
                        if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
                            this.node.textContent = text;
                        } else {
                            this._clear();
                            if (text) {
                                this.appendChild(document.createTextNode(text));
                            }
                        }
                    },
                    configurable: true
                },
                innerHTML: {
                    get: function () {
                        var nt = this.node.nodeType;
                        if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
                            return null;
                        } else {
                            return getInnerHTML(this.node);
                        }
                    },
                    set: function (text) {
                        var nt = this.node.nodeType;
                        if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
                            this._clear();
                            var d = document.createElement('div');
                            d.innerHTML = text;
                            var c$ = Array.prototype.slice.call(d.childNodes);
                            for (var i = 0; i < c$.length; i++) {
                                this.appendChild(c$[i]);
                            }
                        }
                    },
                    configurable: true
                }
            });
            DomApi.prototype._getComposedInnerHTML = function () {
                return getInnerHTML(this.node, true);
            };
        } else {
            var forwardMethods = [
                'cloneNode',
                'appendChild',
                'insertBefore',
                'removeChild',
                'replaceChild'
            ];
            forwardMethods.forEach(function (name) {
                DomApi.prototype[name] = function () {
                    return this.node[name].apply(this.node, arguments);
                };
            });
            DomApi.prototype.querySelectorAll = function (selector) {
                return Array.prototype.slice.call(this.node.querySelectorAll(selector));
            };
            DomApi.prototype.getOwnerRoot = function () {
                var n = this.node;
                while (n) {
                    if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
                        return n;
                    }
                    n = n.parentNode;
                }
            };
            DomApi.prototype.importNode = function (externalNode, deep) {
                var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
                return doc.importNode(externalNode, deep);
            };
            DomApi.prototype.getDestinationInsertionPoints = function () {
                var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
                return n$ ? Array.prototype.slice.call(n$) : [];
            };
            DomApi.prototype.getDistributedNodes = function () {
                var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
                return n$ ? Array.prototype.slice.call(n$) : [];
            };
            DomApi.prototype._distributeParent = function () {
            };
            var nativeForwards = [
                'appendChild',
                'insertBefore',
                'removeChild',
                'replaceChild'
            ];
            nativeForwards.forEach(function (forward) {
                DomApi.prototype[forward] = function () {
                    return this.node[forward].apply(this.node, arguments);
                };
            });
            Object.defineProperties(DomApi.prototype, {
                childNodes: {
                    get: function () {
                        return Array.prototype.slice.call(this.node.childNodes);
                    },
                    configurable: true
                },
                children: {
                    get: function () {
                        return Array.prototype.slice.call(this.node.children);
                    },
                    configurable: true
                },
                textContent: {
                    get: function () {
                        return this.node.textContent;
                    },
                    set: function (value) {
                        return this.node.textContent = value;
                    },
                    configurable: true
                },
                innerHTML: {
                    get: function () {
                        return this.node.innerHTML;
                    },
                    set: function (value) {
                        return this.node.innerHTML = value;
                    },
                    configurable: true
                }
            });
            var forwardProperties = [
                'parentNode',
                'firstChild',
                'lastChild',
                'nextSibling',
                'previousSibling',
                'firstElementChild',
                'lastElementChild',
                'nextElementSibling',
                'previousElementSibling'
            ];
            forwardProperties.forEach(function (name) {
                Object.defineProperty(DomApi.prototype, name, {
                    get: function () {
                        return this.node[name];
                    },
                    configurable: true
                });
            });
        }
        var CONTENT = 'content';

        function factory(node, patch) {
            node = node || document;
            if (!node.__domApi) {
                node.__domApi = new DomApi(node, patch);
            }
            return node.__domApi;
        }
        ;
        function hasDomApi(node) {
            return Boolean(node.__domApi);
        }

        Polymer.dom = function (obj, patch) {
            if (obj instanceof Event) {
                return Polymer.EventApi.factory(obj);
            } else {
                return factory(obj, patch);
            }
        };
        function getLightChildren(node) {
            var children = node._lightChildren;
            return children ? children : node.childNodes;
        }

        function getComposedChildren(node) {
            if (!node._composedChildren) {
                node._composedChildren = Array.prototype.slice.call(node.childNodes);
            }
            return node._composedChildren;
        }

        function addToComposedParent(parent, node, ref_node) {
            var children = getComposedChildren(parent);
            var i = ref_node ? children.indexOf(ref_node) : -1;
            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                var fragChildren = getComposedChildren(node);
                for (var j = 0; j < fragChildren.length; j++) {
                    addNodeToComposedChildren(fragChildren[j], parent, children, i + j);
                }
                node._composedChildren = null;
            } else {
                addNodeToComposedChildren(node, parent, children, i);
            }
        }

        function getComposedParent(node) {
            return node.__patched ? node._composedParent : node.parentNode;
        }

        function addNodeToComposedChildren(node, parent, children, i) {
            node._composedParent = parent;
            children.splice(i >= 0 ? i : children.length, 0, node);
        }

        function removeFromComposedParent(parent, node) {
            node._composedParent = null;
            if (parent) {
                var children = getComposedChildren(parent);
                var i = children.indexOf(node);
                if (i >= 0) {
                    children.splice(i, 1);
                }
            }
        }

        function saveLightChildrenIfNeeded(node) {
            if (!node._lightChildren) {
                var c$ = Array.prototype.slice.call(node.childNodes);
                for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
                    child._lightParent = child._lightParent || node;
                }
                node._lightChildren = c$;
            }
        }

        function hasInsertionPoint(root) {
            return Boolean(root && root._insertionPoints.length);
        }

        var p = Element.prototype;
        var matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
        return {
            getLightChildren: getLightChildren,
            getComposedParent: getComposedParent,
            getComposedChildren: getComposedChildren,
            removeFromComposedParent: removeFromComposedParent,
            saveLightChildrenIfNeeded: saveLightChildrenIfNeeded,
            matchesSelector: matchesSelector,
            hasInsertionPoint: hasInsertionPoint,
            ctor: DomApi,
            factory: factory,
            hasDomApi: hasDomApi
        };
    }();
    Polymer.Base.extend(Polymer.dom, {
        _flushGuard: 0,
        _FLUSH_MAX: 100,
        _needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
        _debouncers: [],
        _staticFlushList: [],
        _finishDebouncer: null,
        flush: function () {
            this._flushGuard = 0;
            this._prepareFlush();
            while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
                for (var i = 0; i < this._debouncers.length; i++) {
                    this._debouncers[i].complete();
                }
                if (this._finishDebouncer) {
                    this._finishDebouncer.complete();
                }
                this._prepareFlush();
                this._flushGuard++;
            }
            if (this._flushGuard >= this._FLUSH_MAX) {
                console.warn('Polymer.dom.flush aborted. Flush may not be complete.');
            }
        },
        _prepareFlush: function () {
            if (this._needsTakeRecords) {
                CustomElements.takeRecords();
            }
            for (var i = 0; i < this._staticFlushList.length; i++) {
                this._staticFlushList[i]();
            }
        },
        addStaticFlush: function (fn) {
            this._staticFlushList.push(fn);
        },
        removeStaticFlush: function (fn) {
            var i = this._staticFlushList.indexOf(fn);
            if (i >= 0) {
                this._staticFlushList.splice(i, 1);
            }
        },
        addDebouncer: function (debouncer) {
            this._debouncers.push(debouncer);
            this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);
        },
        _finishFlush: function () {
            Polymer.dom._debouncers = [];
        }
    });
    Polymer.EventApi = function () {
        'use strict';
        var DomApi = Polymer.DomApi.ctor;
        var Settings = Polymer.Settings;
        DomApi.Event = function (event) {
            this.event = event;
        };
        if (Settings.useShadow) {
            DomApi.Event.prototype = {
                get rootTarget() {
                    return this.event.path[0];
                },
                get localTarget() {
                    return this.event.target;
                },
                get path() {
                    return this.event.path;
                }
            };
        } else {
            DomApi.Event.prototype = {
                get rootTarget() {
                    return this.event.target;
                },
                get localTarget() {
                    var current = this.event.currentTarget;
                    var currentRoot = current && Polymer.dom(current).getOwnerRoot();
                    var p$ = this.path;
                    for (var i = 0; i < p$.length; i++) {
                        if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
                            return p$[i];
                        }
                    }
                },
                get path() {
                    if (!this.event._path) {
                        var path = [];
                        var o = this.rootTarget;
                        while (o) {
                            path.push(o);
                            o = Polymer.dom(o).parentNode || o.host;
                        }
                        path.push(window);
                        this.event._path = path;
                    }
                    return this.event._path;
                }
            };
        }
        var factory = function (event) {
            if (!event.__eventApi) {
                event.__eventApi = new DomApi.Event(event);
            }
            return event.__eventApi;
        };
        return {factory: factory};
    }();
    (function () {
        'use strict';
        var DomApi = Polymer.DomApi.ctor;
        Object.defineProperty(DomApi.prototype, 'classList', {
            get: function () {
                if (!this._classList) {
                    this._classList = new DomApi.ClassList(this);
                }
                return this._classList;
            },
            configurable: true
        });
        DomApi.ClassList = function (host) {
            this.domApi = host;
            this.node = host.node;
        };
        DomApi.ClassList.prototype = {
            add: function () {
                this.node.classList.add.apply(this.node.classList, arguments);
                this.domApi._distributeParent();
            },
            remove: function () {
                this.node.classList.remove.apply(this.node.classList, arguments);
                this.domApi._distributeParent();
            },
            toggle: function () {
                this.node.classList.toggle.apply(this.node.classList, arguments);
                this.domApi._distributeParent();
            },
            contains: function () {
                return this.node.classList.contains.apply(this.node.classList, arguments);
            }
        };
    }());
    (function () {
        'use strict';
        var DomApi = Polymer.DomApi.ctor;
        var Settings = Polymer.Settings;
        var hasDomApi = Polymer.DomApi.hasDomApi;
        DomApi.EffectiveNodesObserver = function (domApi) {
            this.domApi = domApi;
            this.node = this.domApi.node;
            this._listeners = [];
        };
        DomApi.EffectiveNodesObserver.prototype = {
            addListener: function (callback) {
                if (!this._isSetup) {
                    this._setup();
                    this._isSetup = true;
                }
                var listener = {
                    fn: callback,
                    _nodes: []
                };
                this._listeners.push(listener);
                this._scheduleNotify();
                return listener;
            },
            removeListener: function (handle) {
                var i = this._listeners.indexOf(handle);
                if (i >= 0) {
                    this._listeners.splice(i, 1);
                    handle._nodes = [];
                }
                if (!this._hasListeners()) {
                    this._cleanup();
                    this._isSetup = false;
                }
            },
            _setup: function () {
                this._observeContentElements(this.domApi.childNodes);
            },
            _cleanup: function () {
                this._unobserveContentElements(this.domApi.childNodes);
            },
            _hasListeners: function () {
                return Boolean(this._listeners.length);
            },
            _scheduleNotify: function () {
                if (this._debouncer) {
                    this._debouncer.stop();
                }
                this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
                this._debouncer.context = this;
                Polymer.dom.addDebouncer(this._debouncer);
            },
            notify: function () {
                if (this._hasListeners()) {
                    this._scheduleNotify();
                }
            },
            _notify: function (mxns) {
                this._beforeCallListeners();
                this._callListeners();
            },
            _beforeCallListeners: function () {
                this._updateContentElements();
            },
            _updateContentElements: function () {
                this._observeContentElements(this.domApi.childNodes);
            },
            _observeContentElements: function (elements) {
                for (var i = 0, n; i < elements.length && (n = elements[i]); i++) {
                    if (this._isContent(n)) {
                        n.__observeNodesMap = n.__observeNodesMap || new WeakMap();
                        if (!n.__observeNodesMap.has(this)) {
                            n.__observeNodesMap.set(this, this._observeContent(n));
                        }
                    }
                }
            },
            _observeContent: function (content) {
                var h = Polymer.dom(content).observeNodes(this._scheduleNotify.bind(this));
                h._avoidChangeCalculation = true;
                return h;
            },
            _unobserveContentElements: function (elements) {
                for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {
                    if (this._isContent(n)) {
                        h = n.__observeNodesMap.get(this);
                        if (h) {
                            Polymer.dom(n).unobserveNodes(h);
                            n.__observeNodesMap.delete(this);
                        }
                    }
                }
            },
            _isContent: function (node) {
                return node.localName === 'content';
            },
            _callListeners: function () {
                var o$ = this._listeners;
                var nodes = this._getEffectiveNodes();
                for (var i = 0, o; i < o$.length && (o = o$[i]); i++) {
                    var info = this._generateListenerInfo(o, nodes);
                    if (info || o._alwaysNotify) {
                        this._callListener(o, info);
                    }
                }
            },
            _getEffectiveNodes: function () {
                return this.domApi.getEffectiveChildNodes();
            },
            _generateListenerInfo: function (listener, newNodes) {
                if (listener._avoidChangeCalculation) {
                    return true;
                }
                var oldNodes = listener._nodes;
                var info = {
                    target: this.node,
                    addedNodes: [],
                    removedNodes: []
                };
                var splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);
                for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
                    for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
                        info.removedNodes.push(n);
                    }
                }
                for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
                    for (var j = s.index; j < s.index + s.addedCount; j++) {
                        info.addedNodes.push(newNodes[j]);
                    }
                }
                listener._nodes = newNodes;
                if (info.addedNodes.length || info.removedNodes.length) {
                    return info;
                }
            },
            _callListener: function (listener, info) {
                return listener.fn.call(this.node, info);
            },
            enableShadowAttributeTracking: function () {
            }
        };
        if (Settings.useShadow) {
            var baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;
            var baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
            var beforeCallListeners = DomApi.EffectiveNodesObserver.prototype._beforeCallListeners;
            Polymer.Base.extend(DomApi.EffectiveNodesObserver.prototype, {
                _setup: function () {
                    if (!this._observer) {
                        var self = this;
                        this._mutationHandler = function (mxns) {
                            if (mxns && mxns.length) {
                                self._scheduleNotify();
                            }
                        };
                        this._observer = new MutationObserver(this._mutationHandler);
                        this._boundFlush = this._flush.bind(this);
                        Polymer.dom.addStaticFlush(this._boundFlush);
                        this._observer.observe(this.node, {childList: true});
                    }
                    baseSetup.call(this);
                },
                _cleanup: function () {
                    this._observer.disconnect();
                    this._observer = null;
                    this._mutationHandler = null;
                    Polymer.dom.removeStaticFlush(this._boundFlush);
                    baseCleanup.call(this);
                },
                _flush: function () {
                    if (this._observer) {
                        this._mutationHandler(this._observer.takeRecords());
                    }
                },
                enableShadowAttributeTracking: function () {
                    if (this._observer) {
                        this._makeContentListenersAlwaysNotify();
                        this._observer.disconnect();
                        this._observer.observe(this.node, {
                            childList: true,
                            attributes: true,
                            subtree: true
                        });
                        var root = this.domApi.getOwnerRoot();
                        var host = root && root.host;
                        if (host && Polymer.dom(host).observer) {
                            Polymer.dom(host).observer.enableShadowAttributeTracking();
                        }
                    }
                },
                _makeContentListenersAlwaysNotify: function () {
                    for (var i = 0, h; i < this._listeners.length; i++) {
                        h = this._listeners[i];
                        h._alwaysNotify = h._isContentListener;
                    }
                }
            });
        }
    }());
    (function () {
        'use strict';
        var DomApi = Polymer.DomApi.ctor;
        var Settings = Polymer.Settings;
        DomApi.DistributedNodesObserver = function (domApi) {
            DomApi.EffectiveNodesObserver.call(this, domApi);
        };
        DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
        Polymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {
            _setup: function () {
            },
            _cleanup: function () {
            },
            _beforeCallListeners: function () {
            },
            _getEffectiveNodes: function () {
                return this.domApi.getDistributedNodes();
            }
        });
        if (Settings.useShadow) {
            Polymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {
                _setup: function () {
                    if (!this._observer) {
                        var root = this.domApi.getOwnerRoot();
                        var host = root && root.host;
                        if (host) {
                            this._observer = Polymer.dom(host).observeNodes(this._scheduleNotify.bind(this));
                            this._observer._isContentListener = true;
                            if (this._hasAttrSelect()) {
                                Polymer.dom(host).observer.enableShadowAttributeTracking();
                            }
                        }
                    }
                },
                _hasAttrSelect: function () {
                    var select = this.node.getAttribute('select');
                    return select && select.match(/[[.]+/);
                },
                _cleanup: function () {
                    var root = this.domApi.getOwnerRoot();
                    var host = root && root.host;
                    if (host) {
                        Polymer.dom(host).unobserveNodes(this._observer);
                    }
                    this._observer = null;
                }
            });
        }
    }());
    (function () {
        var hasDomApi = Polymer.DomApi.hasDomApi;
        Polymer.Base._addFeature({
            _prepShady: function () {
                this._useContent = this._useContent || Boolean(this._template);
            },
            _poolContent: function () {
                if (this._useContent) {
                    saveLightChildrenIfNeeded(this);
                }
            },
            _setupRoot: function () {
                if (this._useContent) {
                    this._createLocalRoot();
                    if (!this.dataHost) {
                        upgradeLightChildren(this._lightChildren);
                    }
                }
            },
            _createLocalRoot: function () {
                this.shadyRoot = this.root;
                this.shadyRoot._distributionClean = false;
                this.shadyRoot._isShadyRoot = true;
                this.shadyRoot._dirtyRoots = [];
                var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];
                saveLightChildrenIfNeeded(this.shadyRoot);
                for (var i = 0, c; i < i$.length; i++) {
                    c = i$[i];
                    saveLightChildrenIfNeeded(c);
                    saveLightChildrenIfNeeded(c.parentNode);
                }
                this.shadyRoot.host = this;
            },
            get domHost() {
                var root = Polymer.dom(this).getOwnerRoot();
                return root && root.host;
            },
            distributeContent: function (updateInsertionPoints) {
                if (this.shadyRoot) {
                    var dom = Polymer.dom(this);
                    if (updateInsertionPoints) {
                        dom._updateInsertionPoints(this);
                    }
                    var host = getTopDistributingHost(this);
                    dom._lazyDistribute(host);
                }
            },
            _distributeContent: function () {
                if (this._useContent && !this.shadyRoot._distributionClean) {
                    this._beginDistribute();
                    this._distributeDirtyRoots();
                    this._finishDistribute();
                }
            },
            _beginDistribute: function () {
                if (this._useContent && hasInsertionPoint(this.shadyRoot)) {
                    this._resetDistribution();
                    this._distributePool(this.shadyRoot, this._collectPool());
                }
            },
            _distributeDirtyRoots: function () {
                var c$ = this.shadyRoot._dirtyRoots;
                for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
                    c._distributeContent();
                }
                this.shadyRoot._dirtyRoots = [];
            },
            _finishDistribute: function () {
                if (this._useContent) {
                    this.shadyRoot._distributionClean = true;
                    if (hasInsertionPoint(this.shadyRoot)) {
                        this._composeTree();
                        notifyContentObservers(this.shadyRoot);
                    } else {
                        if (!this.shadyRoot._hasDistributed) {
                            this.textContent = '';
                            this._composedChildren = null;
                            this.appendChild(this.shadyRoot);
                        } else {
                            var children = this._composeNode(this);
                            this._updateChildNodes(this, children);
                        }
                    }
                    if (!this.shadyRoot._hasDistributed) {
                        notifyInitialDistribution(this);
                    }
                    this.shadyRoot._hasDistributed = true;
                }
            },
            elementMatches: function (selector, node) {
                node = node || this;
                return matchesSelector.call(node, selector);
            },
            _resetDistribution: function () {
                var children = getLightChildren(this);
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    if (child._destinationInsertionPoints) {
                        child._destinationInsertionPoints = undefined;
                    }
                    if (isInsertionPoint(child)) {
                        clearDistributedDestinationInsertionPoints(child);
                    }
                }
                var root = this.shadyRoot;
                var p$ = root._insertionPoints;
                for (var j = 0; j < p$.length; j++) {
                    p$[j]._distributedNodes = [];
                }
            },
            _collectPool: function () {
                var pool = [];
                var children = getLightChildren(this);
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    if (isInsertionPoint(child)) {
                        pool.push.apply(pool, child._distributedNodes);
                    } else {
                        pool.push(child);
                    }
                }
                return pool;
            },
            _distributePool: function (node, pool) {
                var p$ = node._insertionPoints;
                for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
                    this._distributeInsertionPoint(p, pool);
                    maybeRedistributeParent(p, this);
                }
            },
            _distributeInsertionPoint: function (content, pool) {
                var anyDistributed = false;
                for (var i = 0, l = pool.length, node; i < l; i++) {
                    node = pool[i];
                    if (!node) {
                        continue;
                    }
                    if (this._matchesContentSelect(node, content)) {
                        distributeNodeInto(node, content);
                        pool[i] = undefined;
                        anyDistributed = true;
                    }
                }
                if (!anyDistributed) {
                    var children = getLightChildren(content);
                    for (var j = 0; j < children.length; j++) {
                        distributeNodeInto(children[j], content);
                    }
                }
            },
            _composeTree: function () {
                this._updateChildNodes(this, this._composeNode(this));
                var p$ = this.shadyRoot._insertionPoints;
                for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
                    parent = p._lightParent || p.parentNode;
                    if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
                        this._updateChildNodes(parent, this._composeNode(parent));
                    }
                }
            },
            _composeNode: function (node) {
                var children = [];
                var c$ = getLightChildren(node.shadyRoot || node);
                for (var i = 0; i < c$.length; i++) {
                    var child = c$[i];
                    if (isInsertionPoint(child)) {
                        var distributedNodes = child._distributedNodes;
                        for (var j = 0; j < distributedNodes.length; j++) {
                            var distributedNode = distributedNodes[j];
                            if (isFinalDestination(child, distributedNode)) {
                                children.push(distributedNode);
                            }
                        }
                    } else {
                        children.push(child);
                    }
                }
                return children;
            },
            _updateChildNodes: function (container, children) {
                var composed = getComposedChildren(container);
                var splices = Polymer.ArraySplice.calculateSplices(children, composed);
                for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
                    for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
                        if (getComposedParent(n) === container) {
                            remove(n);
                        }
                        composed.splice(s.index + d, 1);
                    }
                    d -= s.addedCount;
                }
                for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
                    next = composed[s.index];
                    for (var j = s.index, n; j < s.index + s.addedCount; j++) {
                        n = children[j];
                        insertBefore(container, n, next);
                        composed.splice(j, 0, n);
                    }
                }
                ensureComposedParent(container, children);
            },
            _matchesContentSelect: function (node, contentElement) {
                var select = contentElement.getAttribute('select');
                if (!select) {
                    return true;
                }
                select = select.trim();
                if (!select) {
                    return true;
                }
                if (!(node instanceof Element)) {
                    return false;
                }
                var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
                if (!validSelectors.test(select)) {
                    return false;
                }
                return this.elementMatches(select, node);
            },
            _elementAdd: function () {
            },
            _elementRemove: function () {
            }
        });
        var saveLightChildrenIfNeeded = Polymer.DomApi.saveLightChildrenIfNeeded;
        var getLightChildren = Polymer.DomApi.getLightChildren;
        var matchesSelector = Polymer.DomApi.matchesSelector;
        var hasInsertionPoint = Polymer.DomApi.hasInsertionPoint;
        var getComposedChildren = Polymer.DomApi.getComposedChildren;
        var getComposedParent = Polymer.DomApi.getComposedParent;
        var removeFromComposedParent = Polymer.DomApi.removeFromComposedParent;

        function distributeNodeInto(child, insertionPoint) {
            insertionPoint._distributedNodes.push(child);
            var points = child._destinationInsertionPoints;
            if (!points) {
                child._destinationInsertionPoints = [insertionPoint];
            } else {
                points.push(insertionPoint);
            }
        }

        function clearDistributedDestinationInsertionPoints(content) {
            var e$ = content._distributedNodes;
            if (e$) {
                for (var i = 0; i < e$.length; i++) {
                    var d = e$[i]._destinationInsertionPoints;
                    if (d) {
                        d.splice(d.indexOf(content) + 1, d.length);
                    }
                }
            }
        }

        function maybeRedistributeParent(content, host) {
            var parent = content._lightParent;
            if (parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
                parent.shadyRoot._distributionClean = false;
                host.shadyRoot._dirtyRoots.push(parent);
            }
        }

        function isFinalDestination(insertionPoint, node) {
            var points = node._destinationInsertionPoints;
            return points && points[points.length - 1] === insertionPoint;
        }

        function isInsertionPoint(node) {
            return node.localName == 'content';
        }

        var nativeInsertBefore = Element.prototype.insertBefore;
        var nativeRemoveChild = Element.prototype.removeChild;

        function insertBefore(parentNode, newChild, refChild) {
            var newChildParent = getComposedParent(newChild);
            if (newChildParent !== parentNode) {
                removeFromComposedParent(newChildParent, newChild);
            }
            remove(newChild);
            nativeInsertBefore.call(parentNode, newChild, refChild || null);
            newChild._composedParent = parentNode;
        }

        function remove(node) {
            var parentNode = getComposedParent(node);
            if (parentNode) {
                node._composedParent = null;
                nativeRemoveChild.call(parentNode, node);
            }
        }

        function ensureComposedParent(parent, children) {
            for (var i = 0, n; i < children.length; i++) {
                children[i]._composedParent = parent;
            }
        }

        function getTopDistributingHost(host) {
            while (host && hostNeedsRedistribution(host)) {
                host = host.domHost;
            }
            return host;
        }

        function hostNeedsRedistribution(host) {
            var c$ = Polymer.dom(host).children;
            for (var i = 0, c; i < c$.length; i++) {
                c = c$[i];
                if (c.localName === 'content') {
                    return host.domHost;
                }
            }
        }

        function notifyContentObservers(root) {
            for (var i = 0, c; i < root._insertionPoints.length; i++) {
                c = root._insertionPoints[i];
                if (hasDomApi(c)) {
                    Polymer.dom(c).notifyObserver();
                }
            }
        }

        function notifyInitialDistribution(host) {
            if (hasDomApi(host)) {
                Polymer.dom(host).notifyObserver();
            }
        }

        var needsUpgrade = window.CustomElements && !CustomElements.useNative;

        function upgradeLightChildren(children) {
            if (needsUpgrade && children) {
                for (var i = 0; i < children.length; i++) {
                    CustomElements.upgrade(children[i]);
                }
            }
        }
    }());
    if (Polymer.Settings.useShadow) {
        Polymer.Base._addFeature({
            _poolContent: function () {
            },
            _beginDistribute: function () {
            },
            distributeContent: function () {
            },
            _distributeContent: function () {
            },
            _finishDistribute: function () {
            },
            _createLocalRoot: function () {
                this.createShadowRoot();
                this.shadowRoot.appendChild(this.root);
                this.root = this.shadowRoot;
            }
        });
    }
    Polymer.DomModule = document.createElement('dom-module');
    Polymer.Base._addFeature({
        _registerFeatures: function () {
            this._prepIs();
            this._prepAttributes();
            this._prepBehaviors();
            this._prepConstructor();
            this._prepTemplate();
            this._prepShady();
        },
        _prepBehavior: function (b) {
            this._addHostAttributes(b.hostAttributes);
        },
        _initFeatures: function () {
            this._poolContent();
            this._pushHost();
            this._stampTemplate();
            this._popHost();
            this._marshalHostAttributes();
            this._setupDebouncers();
            this._marshalBehaviors();
            this._tryReady();
        },
        _marshalBehavior: function (b) {
        }
    });</script>

    <script>Polymer.nar = [];
    Polymer.Annotations = {
        parseAnnotations: function (template) {
            var list = [];
            var content = template._content || template.content;
            this._parseNodeAnnotations(content, list);
            return list;
        },
        _parseNodeAnnotations: function (node, list) {
            return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list);
        },
        _bindingRegex: /([^{[]*)({{|\[\[)([^}\]]*)(?:]]|}})/g,
        _parseBindings: function (text) {
            var re = this._bindingRegex;
            var parts = [];
            var m, lastIndex;
            while ((m = re.exec(text)) !== null) {
                if (m[1]) {
                    parts.push({literal: m[1]});
                }
                var mode = m[2][0];
                var value = m[3].trim();
                var negate = false;
                if (value[0] == '!') {
                    negate = true;
                    value = value.substring(1).trim();
                }
                var customEvent, notifyEvent, colon;
                if (mode == '{' && (colon = value.indexOf('::')) > 0) {
                    notifyEvent = value.substring(colon + 2);
                    value = value.substring(0, colon);
                    customEvent = true;
                }
                parts.push({
                    compoundIndex: parts.length,
                    value: value,
                    mode: mode,
                    negate: negate,
                    event: notifyEvent,
                    customEvent: customEvent
                });
                lastIndex = re.lastIndex;
            }
            if (lastIndex && lastIndex < text.length) {
                var literal = text.substring(lastIndex);
                if (literal) {
                    parts.push({literal: literal});
                }
            }
            if (parts.length) {
                return parts;
            }
        },
        _literalFromParts: function (parts) {
            var s = '';
            for (var i = 0; i < parts.length; i++) {
                var literal = parts[i].literal;
                s += literal || '';
            }
            return s;
        },
        _parseTextNodeAnnotation: function (node, list) {
            var parts = this._parseBindings(node.textContent);
            if (parts) {
                node.textContent = this._literalFromParts(parts) || ' ';
                var annote = {
                    bindings: [{
                        kind: 'text',
                        name: 'textContent',
                        parts: parts,
                        isCompound: parts.length !== 1
                    }]
                };
                list.push(annote);
                return annote;
            }
        },
        _parseElementAnnotations: function (element, list) {
            var annote = {
                bindings: [],
                events: []
            };
            if (element.localName === 'content') {
                list._hasContent = true;
            }
            this._parseChildNodesAnnotations(element, annote, list);
            if (element.attributes) {
                this._parseNodeAttributeAnnotations(element, annote, list);
                if (this.prepElement) {
                    this.prepElement(element);
                }
            }
            if (annote.bindings.length || annote.events.length || annote.id) {
                list.push(annote);
            }
            return annote;
        },
        _parseChildNodesAnnotations: function (root, annote, list, callback) {
            if (root.firstChild) {
                for (var i = 0, node = root.firstChild; node; node = node.nextSibling, i++) {
                    if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
                        this._parseTemplate(node, i, list, annote);
                    }
                    if (node.nodeType === Node.TEXT_NODE) {
                        var n = node.nextSibling;
                        while (n && n.nodeType === Node.TEXT_NODE) {
                            node.textContent += n.textContent;
                            root.removeChild(n);
                            n = n.nextSibling;
                        }
                    }
                    var childAnnotation = this._parseNodeAnnotations(node, list, callback);
                    if (childAnnotation) {
                        childAnnotation.parent = annote;
                        childAnnotation.index = i;
                    }
                }
            }
        },
        _parseTemplate: function (node, index, list, parent) {
            var content = document.createDocumentFragment();
            content._notes = this.parseAnnotations(node);
            content.appendChild(node.content);
            list.push({
                bindings: Polymer.nar,
                events: Polymer.nar,
                templateContent: content,
                parent: parent,
                index: index
            });
        },
        _parseNodeAttributeAnnotations: function (node, annotation) {
            var attrs = Array.prototype.slice.call(node.attributes);
            for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
                var n = a.name;
                var v = a.value;
                var b;
                if (n.slice(0, 3) === 'on-') {
                    node.removeAttribute(n);
                    annotation.events.push({
                        name: n.slice(3),
                        value: v
                    });
                } else if (b = this._parseNodeAttributeAnnotation(node, n, v)) {
                    annotation.bindings.push(b);
                } else if (n === 'id') {
                    annotation.id = v;
                }
            }
        },
        _parseNodeAttributeAnnotation: function (node, name, value) {
            var parts = this._parseBindings(value);
            if (parts) {
                var origName = name;
                var kind = 'property';
                if (name[name.length - 1] == '$') {
                    name = name.slice(0, -1);
                    kind = 'attribute';
                }
                var literal = this._literalFromParts(parts);
                if (literal && kind == 'attribute') {
                    node.setAttribute(name, literal);
                }
                if (node.localName == 'input' && name == 'value') {
                    node.setAttribute(origName, '');
                }
                node.removeAttribute(origName);
                if (kind === 'property') {
                    name = Polymer.CaseMap.dashToCamelCase(name);
                }
                return {
                    kind: kind,
                    name: name,
                    parts: parts,
                    literal: literal,
                    isCompound: parts.length !== 1
                };
            }
        },
        _localSubTree: function (node, host) {
            return node === host ? node.childNodes : node._lightChildren || node.childNodes;
        },
        findAnnotatedNode: function (root, annote) {
            var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
            return !parent ? root : Polymer.Annotations._localSubTree(parent, root)[annote.index];
        }
    };
    (function () {
        function resolveCss(cssText, ownerDocument) {
            return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
                return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
            });
        }

        function resolveAttrs(element, ownerDocument) {
            for (var name in URL_ATTRS) {
                var a$ = URL_ATTRS[name];
                for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
                    if (name === '*' || element.localName === name) {
                        at = element.attributes[a];
                        v = at && at.value;
                        if (v && v.search(BINDING_RX) < 0) {
                            at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
                        }
                    }
                }
            }
        }

        function resolve(url, ownerDocument) {
            if (url && url[0] === '#') {
                return url;
            }
            var resolver = getUrlResolver(ownerDocument);
            resolver.href = url;
            return resolver.href || url;
        }

        var tempDoc;
        var tempDocBase;

        function resolveUrl(url, baseUri) {
            if (!tempDoc) {
                tempDoc = document.implementation.createHTMLDocument('temp');
                tempDocBase = tempDoc.createElement('base');
                tempDoc.head.appendChild(tempDocBase);
            }
            tempDocBase.href = baseUri;
            return resolve(url, tempDoc);
        }

        function getUrlResolver(ownerDocument) {
            return ownerDocument.__urlResolver || (ownerDocument.__urlResolver = ownerDocument.createElement('a'));
        }

        var CSS_URL_RX = /(url\()([^)]*)(\))/g;
        var URL_ATTRS = {
            '*': [
                'href',
                'src',
                'style',
                'url'
            ],
            form: ['action']
        };
        var BINDING_RX = /\{\{|\[\[/;
        Polymer.ResolveUrl = {
            resolveCss: resolveCss,
            resolveAttrs: resolveAttrs,
            resolveUrl: resolveUrl
        };
    }());
    Polymer.Base._addFeature({
        _prepAnnotations: function () {
            if (!this._template) {
                this._notes = [];
            } else {
                Polymer.Annotations.prepElement = this._prepElement.bind(this);
                if (this._template._content && this._template._content._notes) {
                    this._notes = this._template._content._notes;
                } else {
                    this._notes = Polymer.Annotations.parseAnnotations(this._template);
                }
                this._processAnnotations(this._notes);
                Polymer.Annotations.prepElement = null;
            }
        },
        _processAnnotations: function (notes) {
            for (var i = 0; i < notes.length; i++) {
                var note = notes[i];
                for (var j = 0; j < note.bindings.length; j++) {
                    var b = note.bindings[j];
                    for (var k = 0; k < b.parts.length; k++) {
                        var p = b.parts[k];
                        if (!p.literal) {
                            p.signature = this._parseMethod(p.value);
                            if (!p.signature) {
                                p.model = this._modelForPath(p.value);
                            }
                        }
                    }
                }
                if (note.templateContent) {
                    this._processAnnotations(note.templateContent._notes);
                    var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
                    var bindings = [];
                    for (var prop in pp) {
                        bindings.push({
                            index: note.index,
                            kind: 'property',
                            name: '_parent_' + prop,
                            parts: [{
                                mode: '{',
                                model: prop,
                                value: prop
                            }]
                        });
                    }
                    note.bindings = note.bindings.concat(bindings);
                }
            }
        },
        _discoverTemplateParentProps: function (notes) {
            var pp = {};
            notes.forEach(function (n) {
                n.bindings.forEach(function (b) {
                    b.parts.forEach(function (p) {
                        if (p.signature) {
                            var args = p.signature.args;
                            for (var k = 0; k < args.length; k++) {
                                pp[args[k].model] = true;
                            }
                        } else {
                            pp[p.model] = true;
                        }
                    });
                });
                if (n.templateContent) {
                    var tpp = n.templateContent._parentProps;
                    Polymer.Base.mixin(pp, tpp);
                }
            });
            return pp;
        },
        _prepElement: function (element) {
            Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
        },
        _findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
        _marshalAnnotationReferences: function () {
            if (this._template) {
                this._marshalIdNodes();
                this._marshalAnnotatedNodes();
                this._marshalAnnotatedListeners();
            }
        },
        _configureAnnotationReferences: function (config) {
            var notes = this._notes;
            var nodes = this._nodes;
            for (var i = 0; i < notes.length; i++) {
                var note = notes[i];
                var node = nodes[i];
                this._configureTemplateContent(note, node);
                this._configureCompoundBindings(note, node);
            }
        },
        _configureTemplateContent: function (note, node) {
            if (note.templateContent) {
                node._content = note.templateContent;
            }
        },
        _configureCompoundBindings: function (note, node) {
            var bindings = note.bindings;
            for (var i = 0; i < bindings.length; i++) {
                var binding = bindings[i];
                if (binding.isCompound) {
                    var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});
                    var parts = binding.parts;
                    var literals = new Array(parts.length);
                    for (var j = 0; j < parts.length; j++) {
                        literals[j] = parts[j].literal;
                    }
                    var name = binding.name;
                    storage[name] = literals;
                    if (binding.literal && binding.kind == 'property') {
                        if (node._configValue) {
                            node._configValue(name, binding.literal);
                        } else {
                            node[name] = binding.literal;
                        }
                    }
                }
            }
        },
        _marshalIdNodes: function () {
            this.$ = {};
            this._notes.forEach(function (a) {
                if (a.id) {
                    this.$[a.id] = this._findAnnotatedNode(this.root, a);
                }
            }, this);
        },
        _marshalAnnotatedNodes: function () {
            if (this._nodes) {
                this._nodes = this._nodes.map(function (a) {
                    return this._findAnnotatedNode(this.root, a);
                }, this);
            }
        },
        _marshalAnnotatedListeners: function () {
            this._notes.forEach(function (a) {
                if (a.events && a.events.length) {
                    var node = this._findAnnotatedNode(this.root, a);
                    a.events.forEach(function (e) {
                        this.listen(node, e.name, e.value);
                    }, this);
                }
            }, this);
        }
    });
    Polymer.Base._addFeature({
        listeners: {},
        _listenListeners: function (listeners) {
            var node, name, key;
            for (key in listeners) {
                if (key.indexOf('.') < 0) {
                    node = this;
                    name = key;
                } else {
                    name = key.split('.');
                    node = this.$[name[0]];
                    name = name[1];
                }
                this.listen(node, name, listeners[key]);
            }
        },
        listen: function (node, eventName, methodName) {
            var handler = this._recallEventHandler(this, eventName, node, methodName);
            if (!handler) {
                handler = this._createEventHandler(node, eventName, methodName);
            }
            if (handler._listening) {
                return;
            }
            this._listen(node, eventName, handler);
            handler._listening = true;
        },
        _boundListenerKey: function (eventName, methodName) {
            return eventName + ':' + methodName;
        },
        _recordEventHandler: function (host, eventName, target, methodName, handler) {
            var hbl = host.__boundListeners;
            if (!hbl) {
                hbl = host.__boundListeners = new WeakMap();
            }
            var bl = hbl.get(target);
            if (!bl) {
                bl = {};
                hbl.set(target, bl);
            }
            var key = this._boundListenerKey(eventName, methodName);
            bl[key] = handler;
        },
        _recallEventHandler: function (host, eventName, target, methodName) {
            var hbl = host.__boundListeners;
            if (!hbl) {
                return;
            }
            var bl = hbl.get(target);
            if (!bl) {
                return;
            }
            var key = this._boundListenerKey(eventName, methodName);
            return bl[key];
        },
        _createEventHandler: function (node, eventName, methodName) {
            var host = this;
            var handler = function (e) {
                if (host[methodName]) {
                    host[methodName](e, e.detail);
                } else {
                    host._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));
                }
            };
            handler._listening = false;
            this._recordEventHandler(host, eventName, node, methodName, handler);
            return handler;
        },
        unlisten: function (node, eventName, methodName) {
            var handler = this._recallEventHandler(this, eventName, node, methodName);
            if (handler) {
                this._unlisten(node, eventName, handler);
                handler._listening = false;
            }
        },
        _listen: function (node, eventName, handler) {
            node.addEventListener(eventName, handler);
        },
        _unlisten: function (node, eventName, handler) {
            node.removeEventListener(eventName, handler);
        }
    });
    (function () {
        'use strict';
        var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
        var GESTURE_KEY = '__polymerGestures';
        var HANDLED_OBJ = '__polymerGesturesHandled';
        var TOUCH_ACTION = '__polymerGesturesTouchAction';
        var TAP_DISTANCE = 25;
        var TRACK_DISTANCE = 5;
        var TRACK_LENGTH = 2;
        var MOUSE_TIMEOUT = 2500;
        var MOUSE_EVENTS = [
            'mousedown',
            'mousemove',
            'mouseup',
            'click'
        ];
        var MOUSE_WHICH_TO_BUTTONS = [
            0,
            1,
            4,
            2
        ];
        var MOUSE_HAS_BUTTONS = function () {
            try {
                return new MouseEvent('test', {buttons: 1}).buttons === 1;
            } catch (e) {
                return false;
            }
        }();
        var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
        var mouseCanceller = function (mouseEvent) {
            mouseEvent[HANDLED_OBJ] = {skip: true};
            if (mouseEvent.type === 'click') {
                var path = Polymer.dom(mouseEvent).path;
                for (var i = 0; i < path.length; i++) {
                    if (path[i] === POINTERSTATE.mouse.target) {
                        return;
                    }
                }
                mouseEvent.preventDefault();
                mouseEvent.stopPropagation();
            }
        };

        function setupTeardownMouseCanceller(setup) {
            for (var i = 0, en; i < MOUSE_EVENTS.length; i++) {
                en = MOUSE_EVENTS[i];
                if (setup) {
                    document.addEventListener(en, mouseCanceller, true);
                } else {
                    document.removeEventListener(en, mouseCanceller, true);
                }
            }
        }

        function ignoreMouse() {
            if (IS_TOUCH_ONLY) {
                return;
            }
            if (!POINTERSTATE.mouse.mouseIgnoreJob) {
                setupTeardownMouseCanceller(true);
            }
            var unset = function () {
                setupTeardownMouseCanceller();
                POINTERSTATE.mouse.target = null;
                POINTERSTATE.mouse.mouseIgnoreJob = null;
            };
            POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);
        }

        function hasLeftMouseButton(ev) {
            var type = ev.type;
            if (MOUSE_EVENTS.indexOf(type) === -1) {
                return false;
            }
            if (type === 'mousemove') {
                var buttons = ev.buttons === undefined ? 1 : ev.buttons;
                if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
                    buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
                }
                return Boolean(buttons & 1);
            } else {
                var button = ev.button === undefined ? 0 : ev.button;
                return button === 0;
            }
        }

        function isSyntheticClick(ev) {
            if (ev.type === 'click') {
                if (ev.detail === 0) {
                    return true;
                }
                var t = Gestures.findOriginalTarget(ev);
                var bcr = t.getBoundingClientRect();
                var x = ev.pageX, y = ev.pageY;
                return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));
            }
            return false;
        }

        var POINTERSTATE = {
            mouse: {
                target: null,
                mouseIgnoreJob: null
            },
            touch: {
                x: 0,
                y: 0,
                id: -1,
                scrollDecided: false
            }
        };

        function firstTouchAction(ev) {
            var path = Polymer.dom(ev).path;
            var ta = 'auto';
            for (var i = 0, n; i < path.length; i++) {
                n = path[i];
                if (n[TOUCH_ACTION]) {
                    ta = n[TOUCH_ACTION];
                    break;
                }
            }
            return ta;
        }

        function trackDocument(stateObj, movefn, upfn) {
            stateObj.movefn = movefn;
            stateObj.upfn = upfn;
            document.addEventListener('mousemove', movefn);
            document.addEventListener('mouseup', upfn);
        }

        function untrackDocument(stateObj) {
            document.removeEventListener('mousemove', stateObj.movefn);
            document.removeEventListener('mouseup', stateObj.upfn);
        }

        var Gestures = {
            gestures: {},
            recognizers: [],
            deepTargetFind: function (x, y) {
                var node = document.elementFromPoint(x, y);
                var next = node;
                while (next && next.shadowRoot) {
                    next = next.shadowRoot.elementFromPoint(x, y);
                    if (next) {
                        node = next;
                    }
                }
                return node;
            },
            findOriginalTarget: function (ev) {
                if (ev.path) {
                    return ev.path[0];
                }
                return ev.target;
            },
            handleNative: function (ev) {
                var handled;
                var type = ev.type;
                var node = ev.currentTarget;
                var gobj = node[GESTURE_KEY];
                var gs = gobj[type];
                if (!gs) {
                    return;
                }
                if (!ev[HANDLED_OBJ]) {
                    ev[HANDLED_OBJ] = {};
                    if (type.slice(0, 5) === 'touch') {
                        var t = ev.changedTouches[0];
                        if (type === 'touchstart') {
                            if (ev.touches.length === 1) {
                                POINTERSTATE.touch.id = t.identifier;
                            }
                        }
                        if (POINTERSTATE.touch.id !== t.identifier) {
                            return;
                        }
                        if (!HAS_NATIVE_TA) {
                            if (type === 'touchstart' || type === 'touchmove') {
                                Gestures.handleTouchAction(ev);
                            }
                        }
                        if (type === 'touchend') {
                            POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
                            ignoreMouse(true);
                        }
                    }
                }
                handled = ev[HANDLED_OBJ];
                if (handled.skip) {
                    return;
                }
                var recognizers = Gestures.recognizers;
                for (var i = 0, r; i < recognizers.length; i++) {
                    r = recognizers[i];
                    if (gs[r.name] && !handled[r.name]) {
                        if (r.flow && r.flow.start.indexOf(ev.type) > -1) {
                            if (r.reset) {
                                r.reset();
                            }
                        }
                    }
                }
                for (var i = 0, r; i < recognizers.length; i++) {
                    r = recognizers[i];
                    if (gs[r.name] && !handled[r.name]) {
                        handled[r.name] = true;
                        r[type](ev);
                    }
                }
            },
            handleTouchAction: function (ev) {
                var t = ev.changedTouches[0];
                var type = ev.type;
                if (type === 'touchstart') {
                    POINTERSTATE.touch.x = t.clientX;
                    POINTERSTATE.touch.y = t.clientY;
                    POINTERSTATE.touch.scrollDecided = false;
                } else if (type === 'touchmove') {
                    if (POINTERSTATE.touch.scrollDecided) {
                        return;
                    }
                    POINTERSTATE.touch.scrollDecided = true;
                    var ta = firstTouchAction(ev);
                    var prevent = false;
                    var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
                    var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
                    if (!ev.cancelable) {
                    } else if (ta === 'none') {
                        prevent = true;
                    } else if (ta === 'pan-x') {
                        prevent = dy > dx;
                    } else if (ta === 'pan-y') {
                        prevent = dx > dy;
                    }
                    if (prevent) {
                        ev.preventDefault();
                    } else {
                        Gestures.prevent('track');
                    }
                }
            },
            add: function (node, evType, handler) {
                var recognizer = this.gestures[evType];
                var deps = recognizer.deps;
                var name = recognizer.name;
                var gobj = node[GESTURE_KEY];
                if (!gobj) {
                    node[GESTURE_KEY] = gobj = {};
                }
                for (var i = 0, dep, gd; i < deps.length; i++) {
                    dep = deps[i];
                    if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1) {
                        continue;
                    }
                    gd = gobj[dep];
                    if (!gd) {
                        gobj[dep] = gd = {_count: 0};
                    }
                    if (gd._count === 0) {
                        node.addEventListener(dep, this.handleNative);
                    }
                    gd[name] = (gd[name] || 0) + 1;
                    gd._count = (gd._count || 0) + 1;
                }
                node.addEventListener(evType, handler);
                if (recognizer.touchAction) {
                    this.setTouchAction(node, recognizer.touchAction);
                }
            },
            remove: function (node, evType, handler) {
                var recognizer = this.gestures[evType];
                var deps = recognizer.deps;
                var name = recognizer.name;
                var gobj = node[GESTURE_KEY];
                if (gobj) {
                    for (var i = 0, dep, gd; i < deps.length; i++) {
                        dep = deps[i];
                        gd = gobj[dep];
                        if (gd && gd[name]) {
                            gd[name] = (gd[name] || 1) - 1;
                            gd._count = (gd._count || 1) - 1;
                            if (gd._count === 0) {
                                node.removeEventListener(dep, this.handleNative);
                            }
                        }
                    }
                }
                node.removeEventListener(evType, handler);
            },
            register: function (recog) {
                this.recognizers.push(recog);
                for (var i = 0; i < recog.emits.length; i++) {
                    this.gestures[recog.emits[i]] = recog;
                }
            },
            findRecognizerByEvent: function (evName) {
                for (var i = 0, r; i < this.recognizers.length; i++) {
                    r = this.recognizers[i];
                    for (var j = 0, n; j < r.emits.length; j++) {
                        n = r.emits[j];
                        if (n === evName) {
                            return r;
                        }
                    }
                }
                return null;
            },
            setTouchAction: function (node, value) {
                if (HAS_NATIVE_TA) {
                    node.style.touchAction = value;
                }
                node[TOUCH_ACTION] = value;
            },
            fire: function (target, type, detail) {
                var ev = Polymer.Base.fire(type, detail, {
                    node: target,
                    bubbles: true,
                    cancelable: true
                });
                if (ev.defaultPrevented) {
                    var se = detail.sourceEvent;
                    if (se && se.preventDefault) {
                        se.preventDefault();
                    }
                }
            },
            prevent: function (evName) {
                var recognizer = this.findRecognizerByEvent(evName);
                if (recognizer.info) {
                    recognizer.info.prevent = true;
                }
            }
        };
        Gestures.register({
            name: 'downup',
            deps: [
                'mousedown',
                'touchstart',
                'touchend'
            ],
            flow: {
                start: [
                    'mousedown',
                    'touchstart'
                ],
                end: [
                    'mouseup',
                    'touchend'
                ]
            },
            emits: [
                'down',
                'up'
            ],
            info: {
                movefn: function () {
                },
                upfn: function () {
                }
            },
            reset: function () {
                untrackDocument(this.info);
            },
            mousedown: function (e) {
                if (!hasLeftMouseButton(e)) {
                    return;
                }
                var t = Gestures.findOriginalTarget(e);
                var self = this;
                var movefn = function movefn(e) {
                    if (!hasLeftMouseButton(e)) {
                        self.fire('up', t, e);
                        untrackDocument(self.info);
                    }
                };
                var upfn = function upfn(e) {
                    if (hasLeftMouseButton(e)) {
                        self.fire('up', t, e);
                    }
                    untrackDocument(self.info);
                };
                trackDocument(this.info, movefn, upfn);
                this.fire('down', t, e);
            },
            touchstart: function (e) {
                this.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0]);
            },
            touchend: function (e) {
                this.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0]);
            },
            fire: function (type, target, event) {
                var self = this;
                Gestures.fire(target, type, {
                    x: event.clientX,
                    y: event.clientY,
                    sourceEvent: event,
                    prevent: Gestures.prevent.bind(Gestures)
                });
            }
        });
        Gestures.register({
            name: 'track',
            touchAction: 'none',
            deps: [
                'mousedown',
                'touchstart',
                'touchmove',
                'touchend'
            ],
            flow: {
                start: [
                    'mousedown',
                    'touchstart'
                ],
                end: [
                    'mouseup',
                    'touchend'
                ]
            },
            emits: ['track'],
            info: {
                x: 0,
                y: 0,
                state: 'start',
                started: false,
                moves: [],
                addMove: function (move) {
                    if (this.moves.length > TRACK_LENGTH) {
                        this.moves.shift();
                    }
                    this.moves.push(move);
                },
                movefn: function () {
                },
                upfn: function () {
                },
                prevent: false
            },
            reset: function () {
                this.info.state = 'start';
                this.info.started = false;
                this.info.moves = [];
                this.info.x = 0;
                this.info.y = 0;
                this.info.prevent = false;
                untrackDocument(this.info);
            },
            hasMovedEnough: function (x, y) {
                if (this.info.prevent) {
                    return false;
                }
                if (this.info.started) {
                    return true;
                }
                var dx = Math.abs(this.info.x - x);
                var dy = Math.abs(this.info.y - y);
                return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
            },
            mousedown: function (e) {
                if (!hasLeftMouseButton(e)) {
                    return;
                }
                var t = Gestures.findOriginalTarget(e);
                var self = this;
                var movefn = function movefn(e) {
                    var x = e.clientX, y = e.clientY;
                    if (self.hasMovedEnough(x, y)) {
                        self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
                        self.info.addMove({
                            x: x,
                            y: y
                        });
                        if (!hasLeftMouseButton(e)) {
                            self.info.state = 'end';
                            untrackDocument(self.info);
                        }
                        self.fire(t, e);
                        self.info.started = true;
                    }
                };
                var upfn = function upfn(e) {
                    if (self.info.started) {
                        Gestures.prevent('tap');
                        movefn(e);
                    }
                    untrackDocument(self.info);
                };
                trackDocument(this.info, movefn, upfn);
                this.info.x = e.clientX;
                this.info.y = e.clientY;
            },
            touchstart: function (e) {
                var ct = e.changedTouches[0];
                this.info.x = ct.clientX;
                this.info.y = ct.clientY;
            },
            touchmove: function (e) {
                var t = Gestures.findOriginalTarget(e);
                var ct = e.changedTouches[0];
                var x = ct.clientX, y = ct.clientY;
                if (this.hasMovedEnough(x, y)) {
                    this.info.addMove({
                        x: x,
                        y: y
                    });
                    this.fire(t, ct);
                    this.info.state = 'track';
                    this.info.started = true;
                }
            },
            touchend: function (e) {
                var t = Gestures.findOriginalTarget(e);
                var ct = e.changedTouches[0];
                if (this.info.started) {
                    Gestures.prevent('tap');
                    this.info.state = 'end';
                    this.info.addMove({
                        x: ct.clientX,
                        y: ct.clientY
                    });
                    this.fire(t, ct);
                }
            },
            fire: function (target, touch) {
                var secondlast = this.info.moves[this.info.moves.length - 2];
                var lastmove = this.info.moves[this.info.moves.length - 1];
                var dx = lastmove.x - this.info.x;
                var dy = lastmove.y - this.info.y;
                var ddx, ddy = 0;
                if (secondlast) {
                    ddx = lastmove.x - secondlast.x;
                    ddy = lastmove.y - secondlast.y;
                }
                return Gestures.fire(target, 'track', {
                    state: this.info.state,
                    x: touch.clientX,
                    y: touch.clientY,
                    dx: dx,
                    dy: dy,
                    ddx: ddx,
                    ddy: ddy,
                    sourceEvent: touch,
                    hover: function () {
                        return Gestures.deepTargetFind(touch.clientX, touch.clientY);
                    }
                });
            }
        });
        Gestures.register({
            name: 'tap',
            deps: [
                'mousedown',
                'click',
                'touchstart',
                'touchend'
            ],
            flow: {
                start: [
                    'mousedown',
                    'touchstart'
                ],
                end: [
                    'click',
                    'touchend'
                ]
            },
            emits: ['tap'],
            info: {
                x: NaN,
                y: NaN,
                prevent: false
            },
            reset: function () {
                this.info.x = NaN;
                this.info.y = NaN;
                this.info.prevent = false;
            },
            save: function (e) {
                this.info.x = e.clientX;
                this.info.y = e.clientY;
            },
            mousedown: function (e) {
                if (hasLeftMouseButton(e)) {
                    this.save(e);
                }
            },
            click: function (e) {
                if (hasLeftMouseButton(e)) {
                    this.forward(e);
                }
            },
            touchstart: function (e) {
                this.save(e.changedTouches[0]);
            },
            touchend: function (e) {
                this.forward(e.changedTouches[0]);
            },
            forward: function (e) {
                var dx = Math.abs(e.clientX - this.info.x);
                var dy = Math.abs(e.clientY - this.info.y);
                var t = Gestures.findOriginalTarget(e);
                if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
                    if (!this.info.prevent) {
                        Gestures.fire(t, 'tap', {
                            x: e.clientX,
                            y: e.clientY,
                            sourceEvent: e
                        });
                    }
                }
            }
        });
        var DIRECTION_MAP = {
            x: 'pan-x',
            y: 'pan-y',
            none: 'none',
            all: 'auto'
        };
        Polymer.Base._addFeature({
            _listen: function (node, eventName, handler) {
                if (Gestures.gestures[eventName]) {
                    Gestures.add(node, eventName, handler);
                } else {
                    node.addEventListener(eventName, handler);
                }
            },
            _unlisten: function (node, eventName, handler) {
                if (Gestures.gestures[eventName]) {
                    Gestures.remove(node, eventName, handler);
                } else {
                    node.removeEventListener(eventName, handler);
                }
            },
            setScrollDirection: function (direction, node) {
                node = node || this;
                Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
            }
        });
        Polymer.Gestures = Gestures;
    }());
    Polymer.Async = {
        _currVal: 0,
        _lastVal: 0,
        _callbacks: [],
        _twiddleContent: 0,
        _twiddle: document.createTextNode(''),
        run: function (callback, waitTime) {
            if (waitTime > 0) {
                return ~setTimeout(callback, waitTime);
            } else {
                this._twiddle.textContent = this._twiddleContent++;
                this._callbacks.push(callback);
                return this._currVal++;
            }
        },
        cancel: function (handle) {
            if (handle < 0) {
                clearTimeout(~handle);
            } else {
                var idx = handle - this._lastVal;
                if (idx >= 0) {
                    if (!this._callbacks[idx]) {
                        throw 'invalid async handle: ' + handle;
                    }
                    this._callbacks[idx] = null;
                }
            }
        },
        _atEndOfMicrotask: function () {
            var len = this._callbacks.length;
            for (var i = 0; i < len; i++) {
                var cb = this._callbacks[i];
                if (cb) {
                    try {
                        cb();
                    } catch (e) {
                        i++;
                        this._callbacks.splice(0, i);
                        this._lastVal += i;
                        this._twiddle.textContent = this._twiddleContent++;
                        throw e;
                    }
                }
            }
            this._callbacks.splice(0, len);
            this._lastVal += len;
        }
    };
    new window.MutationObserver(function () {
        Polymer.Async._atEndOfMicrotask();
    }).observe(Polymer.Async._twiddle, {characterData: true});
    Polymer.Debounce = function () {
        var Async = Polymer.Async;
        var Debouncer = function (context) {
            this.context = context;
            this.boundComplete = this.complete.bind(this);
        };
        Debouncer.prototype = {
            go: function (callback, wait) {
                var h;
                this.finish = function () {
                    Async.cancel(h);
                };
                h = Async.run(this.boundComplete, wait);
                this.callback = callback;
            },
            stop: function () {
                if (this.finish) {
                    this.finish();
                    this.finish = null;
                }
            },
            complete: function () {
                if (this.finish) {
                    this.stop();
                    this.callback.call(this.context);
                }
            }
        };
        function debounce(debouncer, callback, wait) {
            if (debouncer) {
                debouncer.stop();
            } else {
                debouncer = new Debouncer(this);
            }
            debouncer.go(callback, wait);
            return debouncer;
        }

        return debounce;
    }();
    Polymer.Base._addFeature({
        $$: function (slctr) {
            return Polymer.dom(this.root).querySelector(slctr);
        },
        toggleClass: function (name, bool, node) {
            node = node || this;
            if (arguments.length == 1) {
                bool = !node.classList.contains(name);
            }
            if (bool) {
                Polymer.dom(node).classList.add(name);
            } else {
                Polymer.dom(node).classList.remove(name);
            }
        },
        toggleAttribute: function (name, bool, node) {
            node = node || this;
            if (arguments.length == 1) {
                bool = !node.hasAttribute(name);
            }
            if (bool) {
                Polymer.dom(node).setAttribute(name, '');
            } else {
                Polymer.dom(node).removeAttribute(name);
            }
        },
        classFollows: function (name, toElement, fromElement) {
            if (fromElement) {
                Polymer.dom(fromElement).classList.remove(name);
            }
            if (toElement) {
                Polymer.dom(toElement).classList.add(name);
            }
        },
        attributeFollows: function (name, toElement, fromElement) {
            if (fromElement) {
                Polymer.dom(fromElement).removeAttribute(name);
            }
            if (toElement) {
                Polymer.dom(toElement).setAttribute(name, '');
            }
        },
        getEffectiveChildNodes: function () {
            return Polymer.dom(this).getEffectiveChildNodes();
        },
        getEffectiveChildren: function () {
            var list = Polymer.dom(this).getEffectiveChildNodes();
            return list.filter(function (n) {
                return n.nodeType === Node.ELEMENT_NODE;
            });
        },
        getEffectiveTextContent: function () {
            var cn = this.getEffectiveChildNodes();
            var tc = [];
            for (var i = 0, c; c = cn[i]; i++) {
                if (c.nodeType !== Node.COMMENT_NODE) {
                    tc.push(Polymer.dom(c).textContent);
                }
            }
            return tc.join('');
        },
        queryEffectiveChildren: function (slctr) {
            var e$ = Polymer.dom(this).queryDistributedElements(slctr);
            return e$ && e$[0];
        },
        queryAllEffectiveChildren: function (slctr) {
            return Polymer.dom(this).queryAllDistributedElements(slctr);
        },
        getContentChildNodes: function (slctr) {
            var content = Polymer.dom(this.root).querySelector(slctr || 'content');
            return content ? Polymer.dom(content).getDistributedNodes() : [];
        },
        getContentChildren: function (slctr) {
            return this.getContentChildNodes(slctr).filter(function (n) {
                return n.nodeType === Node.ELEMENT_NODE;
            });
        },
        fire: function (type, detail, options) {
            options = options || Polymer.nob;
            var node = options.node || this;
            var detail = detail === null || detail === undefined ? Polymer.nob : detail;
            var bubbles = options.bubbles === undefined ? true : options.bubbles;
            var cancelable = Boolean(options.cancelable);
            var event = new CustomEvent(type, {
                bubbles: Boolean(bubbles),
                cancelable: cancelable,
                detail: detail
            });
            node.dispatchEvent(event);
            return event;
        },
        async: function (callback, waitTime) {
            return Polymer.Async.run(callback.bind(this), waitTime);
        },
        cancelAsync: function (handle) {
            Polymer.Async.cancel(handle);
        },
        arrayDelete: function (path, item) {
            var index;
            if (Array.isArray(path)) {
                index = path.indexOf(item);
                if (index >= 0) {
                    return path.splice(index, 1);
                }
            } else {
                var arr = this._get(path);
                index = arr.indexOf(item);
                if (index >= 0) {
                    return this.splice(path, index, 1);
                }
            }
        },
        transform: function (transform, node) {
            node = node || this;
            node.style.webkitTransform = transform;
            node.style.transform = transform;
        },
        translate3d: function (x, y, z, node) {
            node = node || this;
            this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
        },
        importHref: function (href, onload, onerror) {
            var l = document.createElement('link');
            l.rel = 'import';
            l.href = href;
            if (onload) {
                l.onload = onload.bind(this);
            }
            if (onerror) {
                l.onerror = onerror.bind(this);
            }
            document.head.appendChild(l);
            return l;
        },
        create: function (tag, props) {
            var elt = document.createElement(tag);
            if (props) {
                for (var n in props) {
                    elt[n] = props[n];
                }
            }
            return elt;
        },
        isLightDescendant: function (node) {
            return this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();
        },
        isLocalDescendant: function (node) {
            return this.root === Polymer.dom(node).getOwnerRoot();
        }
    });
    Polymer.Bind = {
        prepareModel: function (model) {
            model._propertyEffects = {};
            model._bindListeners = [];
            Polymer.Base.mixin(model, this._modelApi);
        },
        _modelApi: {
            _notifyChange: function (property) {
                var eventName = Polymer.CaseMap.camelToDashCase(property) + '-changed';
                Polymer.Base.fire(eventName, {value: this[property]}, {
                    bubbles: false,
                    node: this
                });
            },
            _propertySetter: function (property, value, effects, fromAbove) {
                var old = this.__data__[property];
                if (old !== value && (old === old || value === value)) {
                    this.__data__[property] = value;
                    if (typeof value == 'object') {
                        this._clearPath(property);
                    }
                    if (this._propertyChanged) {
                        this._propertyChanged(property, value, old);
                    }
                    if (effects) {
                        this._effectEffects(property, value, effects, old, fromAbove);
                    }
                }
                return old;
            },
            __setProperty: function (property, value, quiet, node) {
                node = node || this;
                var effects = node._propertyEffects && node._propertyEffects[property];
                if (effects) {
                    node._propertySetter(property, value, effects, quiet);
                } else {
                    node[property] = value;
                }
            },
            _effectEffects: function (property, value, effects, old, fromAbove) {
                effects.forEach(function (fx) {
                    var fn = Polymer.Bind['_' + fx.kind + 'Effect'];
                    if (fn) {
                        fn.call(this, property, value, fx.effect, old, fromAbove);
                    }
                }, this);
            },
            _clearPath: function (path) {
                for (var prop in this.__data__) {
                    if (prop.indexOf(path + '.') === 0) {
                        this.__data__[prop] = undefined;
                    }
                }
            }
        },
        ensurePropertyEffects: function (model, property) {
            var fx = model._propertyEffects[property];
            if (!fx) {
                fx = model._propertyEffects[property] = [];
            }
            return fx;
        },
        addPropertyEffect: function (model, property, kind, effect) {
            var fx = this.ensurePropertyEffects(model, property);
            fx.push({
                kind: kind,
                effect: effect
            });
        },
        createBindings: function (model) {
            var fx$ = model._propertyEffects;
            if (fx$) {
                for (var n in fx$) {
                    var fx = fx$[n];
                    fx.sort(this._sortPropertyEffects);
                    this._createAccessors(model, n, fx);
                }
            }
        },
        _sortPropertyEffects: function () {
            var EFFECT_ORDER = {
                'compute': 0,
                'annotation': 1,
                'computedAnnotation': 2,
                'reflect': 3,
                'notify': 4,
                'observer': 5,
                'complexObserver': 6,
                'function': 7
            };
            return function (a, b) {
                return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
            };
        }(),
        _createAccessors: function (model, property, effects) {
            var defun = {
                get: function () {
                    return this.__data__[property];
                }
            };
            var setter = function (value) {
                this._propertySetter(property, value, effects);
            };
            var info = model.getPropertyInfo && model.getPropertyInfo(property);
            if (info && info.readOnly) {
                if (!info.computed) {
                    model['_set' + this.upper(property)] = setter;
                }
            } else {
                defun.set = setter;
            }
            Object.defineProperty(model, property, defun);
        },
        upper: function (name) {
            return name[0].toUpperCase() + name.substring(1);
        },
        _addAnnotatedListener: function (model, index, property, path, event) {
            var fn = this._notedListenerFactory(property, path, this._isStructured(path), this._isEventBogus);
            var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
            model._bindListeners.push({
                index: index,
                property: property,
                path: path,
                changedFn: fn,
                event: eventName
            });
        },
        _isStructured: function (path) {
            return path.indexOf('.') > 0;
        },
        _isEventBogus: function (e, target) {
            return e.path && e.path[0] !== target;
        },
        _notedListenerFactory: function (property, path, isStructured, bogusTest) {
            return function (e, target) {
                if (!bogusTest(e, target)) {
                    if (e.detail && e.detail.path) {
                        this._notifyPath(this._fixPath(path, property, e.detail.path), e.detail.value);
                    } else {
                        var value = target[property];
                        if (!isStructured) {
                            this[path] = target[property];
                        } else {
                            if (this.__data__[path] != value) {
                                this.set(path, value);
                            }
                        }
                    }
                }
            };
        },
        prepareInstance: function (inst) {
            inst.__data__ = Object.create(null);
        },
        setupBindListeners: function (inst) {
            inst._bindListeners.forEach(function (info) {
                var node = inst._nodes[info.index];
                node.addEventListener(info.event, inst._notifyListener.bind(inst, info.changedFn));
            });
        }
    };
    Polymer.Base.extend(Polymer.Bind, {
        _shouldAddListener: function (effect) {
            return effect.name && effect.kind != 'attribute' && effect.kind != 'text' && !effect.isCompound && effect.parts[0].mode === '{' && !effect.parts[0].negate;
        },
        _annotationEffect: function (source, value, effect) {
            if (source != effect.value) {
                value = this._get(effect.value);
                this.__data__[effect.value] = value;
            }
            var calc = effect.negate ? !value : value;
            if (!effect.customEvent || this._nodes[effect.index][effect.name] !== calc) {
                return this._applyEffectValue(effect, calc);
            }
        },
        _reflectEffect: function (source) {
            this.reflectPropertyToAttribute(source);
        },
        _notifyEffect: function (source, value, effect, old, fromAbove) {
            if (!fromAbove) {
                this._notifyChange(source);
            }
        },
        _functionEffect: function (source, value, fn, old, fromAbove) {
            fn.call(this, source, value, old, fromAbove);
        },
        _observerEffect: function (source, value, effect, old) {
            var fn = this[effect.method];
            if (fn) {
                fn.call(this, value, old);
            } else {
                this._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));
            }
        },
        _complexObserverEffect: function (source, value, effect) {
            var fn = this[effect.method];
            if (fn) {
                var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
                if (args) {
                    fn.apply(this, args);
                }
            } else {
                this._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));
            }
        },
        _computeEffect: function (source, value, effect) {
            var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
            if (args) {
                var fn = this[effect.method];
                if (fn) {
                    this.__setProperty(effect.name, fn.apply(this, args));
                } else {
                    this._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));
                }
            }
        },
        _annotatedComputationEffect: function (source, value, effect) {
            var computedHost = this._rootDataHost || this;
            var fn = computedHost[effect.method];
            if (fn) {
                var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
                if (args) {
                    var computedvalue = fn.apply(computedHost, args);
                    if (effect.negate) {
                        computedvalue = !computedvalue;
                    }
                    this._applyEffectValue(effect, computedvalue);
                }
            } else {
                computedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));
            }
        },
        _marshalArgs: function (model, effect, path, value) {
            var values = [];
            var args = effect.args;
            for (var i = 0, l = args.length; i < l; i++) {
                var arg = args[i];
                var name = arg.name;
                var v;
                if (arg.literal) {
                    v = arg.value;
                } else if (arg.structured) {
                    v = Polymer.Base._get(name, model);
                } else {
                    v = model[name];
                }
                if (args.length > 1 && v === undefined) {
                    return;
                }
                if (arg.wildcard) {
                    var baseChanged = name.indexOf(path + '.') === 0;
                    var matches = effect.trigger.name.indexOf(name) === 0 && !baseChanged;
                    values[i] = {
                        path: matches ? path : name,
                        value: matches ? value : v,
                        base: v
                    };
                } else {
                    values[i] = v;
                }
            }
            return values;
        }
    });
    Polymer.Base._addFeature({
        _addPropertyEffect: function (property, kind, effect) {
            Polymer.Bind.addPropertyEffect(this, property, kind, effect);
        },
        _prepEffects: function () {
            Polymer.Bind.prepareModel(this);
            this._addAnnotationEffects(this._notes);
        },
        _prepBindings: function () {
            Polymer.Bind.createBindings(this);
        },
        _addPropertyEffects: function (properties) {
            if (properties) {
                for (var p in properties) {
                    var prop = properties[p];
                    if (prop.observer) {
                        this._addObserverEffect(p, prop.observer);
                    }
                    if (prop.computed) {
                        prop.readOnly = true;
                        this._addComputedEffect(p, prop.computed);
                    }
                    if (prop.notify) {
                        this._addPropertyEffect(p, 'notify');
                    }
                    if (prop.reflectToAttribute) {
                        this._addPropertyEffect(p, 'reflect');
                    }
                    if (prop.readOnly) {
                        Polymer.Bind.ensurePropertyEffects(this, p);
                    }
                }
            }
        },
        _addComputedEffect: function (name, expression) {
            var sig = this._parseMethod(expression);
            sig.args.forEach(function (arg) {
                this._addPropertyEffect(arg.model, 'compute', {
                    method: sig.method,
                    args: sig.args,
                    trigger: arg,
                    name: name
                });
            }, this);
        },
        _addObserverEffect: function (property, observer) {
            this._addPropertyEffect(property, 'observer', {
                method: observer,
                property: property
            });
        },
        _addComplexObserverEffects: function (observers) {
            if (observers) {
                observers.forEach(function (observer) {
                    this._addComplexObserverEffect(observer);
                }, this);
            }
        },
        _addComplexObserverEffect: function (observer) {
            var sig = this._parseMethod(observer);
            sig.args.forEach(function (arg) {
                this._addPropertyEffect(arg.model, 'complexObserver', {
                    method: sig.method,
                    args: sig.args,
                    trigger: arg
                });
            }, this);
        },
        _addAnnotationEffects: function (notes) {
            this._nodes = [];
            notes.forEach(function (note) {
                var index = this._nodes.push(note) - 1;
                note.bindings.forEach(function (binding) {
                    this._addAnnotationEffect(binding, index);
                }, this);
            }, this);
        },
        _addAnnotationEffect: function (note, index) {
            if (Polymer.Bind._shouldAddListener(note)) {
                Polymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event);
            }
            for (var i = 0; i < note.parts.length; i++) {
                var part = note.parts[i];
                if (part.signature) {
                    this._addAnnotatedComputationEffect(note, part, index);
                } else if (!part.literal) {
                    this._addPropertyEffect(part.model, 'annotation', {
                        kind: note.kind,
                        index: index,
                        name: note.name,
                        value: part.value,
                        isCompound: note.isCompound,
                        compoundIndex: part.compoundIndex,
                        event: part.event,
                        customEvent: part.customEvent,
                        negate: part.negate
                    });
                }
            }
        },
        _addAnnotatedComputationEffect: function (note, part, index) {
            var sig = part.signature;
            if (sig.static) {
                this.__addAnnotatedComputationEffect('__static__', index, note, part, null);
            } else {
                sig.args.forEach(function (arg) {
                    if (!arg.literal) {
                        this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);
                    }
                }, this);
            }
        },
        __addAnnotatedComputationEffect: function (property, index, note, part, trigger) {
            this._addPropertyEffect(property, 'annotatedComputation', {
                index: index,
                isCompound: note.isCompound,
                compoundIndex: part.compoundIndex,
                kind: note.kind,
                name: note.name,
                negate: part.negate,
                method: part.signature.method,
                args: part.signature.args,
                trigger: trigger
            });
        },
        _parseMethod: function (expression) {
            var m = expression.match(/([^\s]+)\((.*)\)/);
            if (m) {
                var sig = {
                    method: m[1],
                    static: true
                };
                if (m[2].trim()) {
                    var args = m[2].replace(/\\,/g, '&comma;').split(',');
                    return this._parseArgs(args, sig);
                } else {
                    sig.args = Polymer.nar;
                    return sig;
                }
            }
        },
        _parseArgs: function (argList, sig) {
            sig.args = argList.map(function (rawArg) {
                var arg = this._parseArg(rawArg);
                if (!arg.literal) {
                    sig.static = false;
                }
                return arg;
            }, this);
            return sig;
        },
        _parseArg: function (rawArg) {
            var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
            var a = {
                name: arg,
                model: this._modelForPath(arg)
            };
            var fc = arg[0];
            if (fc === '-') {
                fc = arg[1];
            }
            if (fc >= '0' && fc <= '9') {
                fc = '#';
            }
            switch (fc) {
                case '\'':
                case '"':
                    a.value = arg.slice(1, -1);
                    a.literal = true;
                    break;
                case '#':
                    a.value = Number(arg);
                    a.literal = true;
                    break;
            }
            if (!a.literal) {
                a.structured = arg.indexOf('.') > 0;
                if (a.structured) {
                    a.wildcard = arg.slice(-2) == '.*';
                    if (a.wildcard) {
                        a.name = arg.slice(0, -2);
                    }
                }
            }
            return a;
        },
        _marshalInstanceEffects: function () {
            Polymer.Bind.prepareInstance(this);
            Polymer.Bind.setupBindListeners(this);
        },
        _applyEffectValue: function (info, value) {
            var node = this._nodes[info.index];
            var property = info.name;
            if (info.isCompound) {
                var storage = node.__compoundStorage__[property];
                storage[info.compoundIndex] = value;
                value = storage.join('');
            }
            if (info.kind == 'attribute') {
                this.serializeValueToAttribute(value, property, node);
            } else {
                if (property === 'className') {
                    value = this._scopeElementClass(node, value);
                }
                if (property === 'textContent' || node.localName == 'input' && property == 'value') {
                    value = value == undefined ? '' : value;
                }
                return node[property] = value;
            }
        },
        _executeStaticEffects: function () {
            if (this._propertyEffects.__static__) {
                this._effectEffects('__static__', null, this._propertyEffects.__static__);
            }
        }
    });
    Polymer.Base._addFeature({
        _setupConfigure: function (initialConfig) {
            this._config = {};
            for (var i in initialConfig) {
                if (initialConfig[i] !== undefined) {
                    this._config[i] = initialConfig[i];
                }
            }
            this._handlers = [];
        },
        _marshalAttributes: function () {
            this._takeAttributesToModel(this._config);
        },
        _attributeChangedImpl: function (name) {
            var model = this._clientsReadied ? this : this._config;
            this._setAttributeToProperty(model, name);
        },
        _configValue: function (name, value) {
            this._config[name] = value;
        },
        _beforeClientsReady: function () {
            this._configure();
        },
        _configure: function () {
            this._configureAnnotationReferences();
            this._aboveConfig = this.mixin({}, this._config);
            var config = {};
            this.behaviors.forEach(function (b) {
                this._configureProperties(b.properties, config);
            }, this);
            this._configureProperties(this.properties, config);
            this._mixinConfigure(config, this._aboveConfig);
            this._config = config;
            this._distributeConfig(this._config);
        },
        _configureProperties: function (properties, config) {
            for (var i in properties) {
                var c = properties[i];
                if (c.value !== undefined) {
                    var value = c.value;
                    if (typeof value == 'function') {
                        value = value.call(this, this._config);
                    }
                    config[i] = value;
                }
            }
        },
        _mixinConfigure: function (a, b) {
            for (var prop in b) {
                if (!this.getPropertyInfo(prop).readOnly) {
                    a[prop] = b[prop];
                }
            }
        },
        _distributeConfig: function (config) {
            var fx$ = this._propertyEffects;
            if (fx$) {
                for (var p in config) {
                    var fx = fx$[p];
                    if (fx) {
                        for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
                            if (x.kind === 'annotation' && !x.isCompound) {
                                var node = this._nodes[x.effect.index];
                                if (node._configValue) {
                                    var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
                                    node._configValue(x.effect.name, value);
                                }
                            }
                        }
                    }
                }
            }
        },
        _afterClientsReady: function () {
            this._executeStaticEffects();
            this._applyConfig(this._config, this._aboveConfig);
            this._flushHandlers();
        },
        _applyConfig: function (config, aboveConfig) {
            for (var n in config) {
                if (this[n] === undefined) {
                    this.__setProperty(n, config[n], n in aboveConfig);
                }
            }
        },
        _notifyListener: function (fn, e) {
            if (!this._clientsReadied) {
                this._queueHandler([
                    fn,
                    e,
                    e.target
                ]);
            } else {
                return fn.call(this, e, e.target);
            }
        },
        _queueHandler: function (args) {
            this._handlers.push(args);
        },
        _flushHandlers: function () {
            var h$ = this._handlers;
            for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
                h[0].call(this, h[1], h[2]);
            }
            this._handlers = [];
        }
    });
    (function () {
        'use strict';
        Polymer.Base._addFeature({
            notifyPath: function (path, value, fromAbove) {
                var info = {};
                path = this._get(path, this, info);
                this._notifyPath(info.path, value, fromAbove);
            },
            _notifyPath: function (path, value, fromAbove) {
                var old = this._propertySetter(path, value);
                if (old !== value && (old === old || value === value)) {
                    this._pathEffector(path, value);
                    if (!fromAbove) {
                        this._notifyPathUp(path, value);
                    }
                    return true;
                }
            },
            _getPathParts: function (path) {
                if (Array.isArray(path)) {
                    var parts = [];
                    for (var i = 0; i < path.length; i++) {
                        var args = path[i].toString().split('.');
                        for (var j = 0; j < args.length; j++) {
                            parts.push(args[j]);
                        }
                    }
                    return parts;
                } else {
                    return path.toString().split('.');
                }
            },
            set: function (path, value, root) {
                var prop = root || this;
                var parts = this._getPathParts(path);
                var array;
                var last = parts[parts.length - 1];
                if (parts.length > 1) {
                    for (var i = 0; i < parts.length - 1; i++) {
                        var part = parts[i];
                        if (array && part[0] == '#') {
                            prop = Polymer.Collection.get(array).getItem(part);
                        } else {
                            prop = prop[part];
                            if (array && parseInt(part, 10) == part) {
                                parts[i] = Polymer.Collection.get(array).getKey(prop);
                            }
                        }
                        if (!prop) {
                            return;
                        }
                        array = Array.isArray(prop) ? prop : null;
                    }
                    if (array) {
                        var coll = Polymer.Collection.get(array);
                        if (last[0] == '#') {
                            var key = last;
                            var old = coll.getItem(key);
                            last = array.indexOf(old);
                            coll.setItem(key, value);
                        } else if (parseInt(last, 10) == last) {
                            var old = prop[last];
                            var key = coll.getKey(old);
                            parts[i] = key;
                            coll.setItem(key, value);
                        }
                    }
                    prop[last] = value;
                    if (!root) {
                        this._notifyPath(parts.join('.'), value);
                    }
                } else {
                    prop[path] = value;
                }
            },
            get: function (path, root) {
                return this._get(path, root);
            },
            _get: function (path, root, info) {
                var prop = root || this;
                var parts = this._getPathParts(path);
                var array;
                for (var i = 0; i < parts.length; i++) {
                    if (!prop) {
                        return;
                    }
                    var part = parts[i];
                    if (array && part[0] == '#') {
                        prop = Polymer.Collection.get(array).getItem(part);
                    } else {
                        prop = prop[part];
                        if (info && array && parseInt(part, 10) == part) {
                            parts[i] = Polymer.Collection.get(array).getKey(prop);
                        }
                    }
                    array = Array.isArray(prop) ? prop : null;
                }
                if (info) {
                    info.path = parts.join('.');
                }
                return prop;
            },
            _pathEffector: function (path, value) {
                var model = this._modelForPath(path);
                var fx$ = this._propertyEffects[model];
                if (fx$) {
                    fx$.forEach(function (fx) {
                        var fxFn = this['_' + fx.kind + 'PathEffect'];
                        if (fxFn) {
                            fxFn.call(this, path, value, fx.effect);
                        }
                    }, this);
                }
                if (this._boundPaths) {
                    this._notifyBoundPaths(path, value);
                }
            },
            _annotationPathEffect: function (path, value, effect) {
                if (effect.value === path || effect.value.indexOf(path + '.') === 0) {
                    Polymer.Bind._annotationEffect.call(this, path, value, effect);
                } else if (path.indexOf(effect.value + '.') === 0 && !effect.negate) {
                    var node = this._nodes[effect.index];
                    if (node && node.notifyPath) {
                        var p = this._fixPath(effect.name, effect.value, path);
                        node.notifyPath(p, value, true);
                    }
                }
            },
            _complexObserverPathEffect: function (path, value, effect) {
                if (this._pathMatchesEffect(path, effect)) {
                    Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
                }
            },
            _computePathEffect: function (path, value, effect) {
                if (this._pathMatchesEffect(path, effect)) {
                    Polymer.Bind._computeEffect.call(this, path, value, effect);
                }
            },
            _annotatedComputationPathEffect: function (path, value, effect) {
                if (this._pathMatchesEffect(path, effect)) {
                    Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
                }
            },
            _pathMatchesEffect: function (path, effect) {
                var effectArg = effect.trigger.name;
                return effectArg == path || effectArg.indexOf(path + '.') === 0 || effect.trigger.wildcard && path.indexOf(effectArg) === 0;
            },
            linkPaths: function (to, from) {
                this._boundPaths = this._boundPaths || {};
                if (from) {
                    this._boundPaths[to] = from;
                } else {
                    this.unlinkPaths(to);
                }
            },
            unlinkPaths: function (path) {
                if (this._boundPaths) {
                    delete this._boundPaths[path];
                }
            },
            _notifyBoundPaths: function (path, value) {
                for (var a in this._boundPaths) {
                    var b = this._boundPaths[a];
                    if (path.indexOf(a + '.') == 0) {
                        this.notifyPath(this._fixPath(b, a, path), value);
                    } else if (path.indexOf(b + '.') == 0) {
                        this.notifyPath(this._fixPath(a, b, path), value);
                    }
                }
            },
            _fixPath: function (property, root, path) {
                return property + path.slice(root.length);
            },
            _notifyPathUp: function (path, value) {
                var rootName = this._modelForPath(path);
                var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
                var eventName = dashCaseName + this._EVENT_CHANGED;
                this.fire(eventName, {
                    path: path,
                    value: value
                }, {bubbles: false});
            },
            _modelForPath: function (path) {
                var dot = path.indexOf('.');
                return dot < 0 ? path : path.slice(0, dot);
            },
            _EVENT_CHANGED: '-changed',
            notifySplices: function (path, splices) {
                var info = {};
                var array = this._get(path, this, info);
                this._notifySplices(array, info.path, splices);
            },
            _notifySplices: function (array, path, splices) {
                var change = {
                    keySplices: Polymer.Collection.applySplices(array, splices),
                    indexSplices: splices
                };
                if (!array.hasOwnProperty('splices')) {
                    Object.defineProperty(array, 'splices', {
                        configurable: true,
                        writable: true
                    });
                }
                array.splices = change;
                this._notifyPath(path + '.splices', change);
                this._notifyPath(path + '.length', array.length);
                change.keySplices = null;
                change.indexSplices = null;
            },
            _notifySplice: function (array, path, index, added, removed) {
                this._notifySplices(array, path, [{
                    index: index,
                    addedCount: added,
                    removed: removed,
                    object: array,
                    type: 'splice'
                }]);
            },
            push: function (path) {
                var info = {};
                var array = this._get(path, this, info);
                var args = Array.prototype.slice.call(arguments, 1);
                var len = array.length;
                var ret = array.push.apply(array, args);
                if (args.length) {
                    this._notifySplice(array, info.path, len, args.length, []);
                }
                return ret;
            },
            pop: function (path) {
                var info = {};
                var array = this._get(path, this, info);
                var hadLength = Boolean(array.length);
                var args = Array.prototype.slice.call(arguments, 1);
                var ret = array.pop.apply(array, args);
                if (hadLength) {
                    this._notifySplice(array, info.path, array.length, 0, [ret]);
                }
                return ret;
            },
            splice: function (path, start, deleteCount) {
                var info = {};
                var array = this._get(path, this, info);
                if (start < 0) {
                    start = array.length - Math.floor(-start);
                } else {
                    start = Math.floor(start);
                }
                if (!start) {
                    start = 0;
                }
                var args = Array.prototype.slice.call(arguments, 1);
                var ret = array.splice.apply(array, args);
                var addedCount = Math.max(args.length - 2, 0);
                if (addedCount || ret.length) {
                    this._notifySplice(array, info.path, start, addedCount, ret);
                }
                return ret;
            },
            shift: function (path) {
                var info = {};
                var array = this._get(path, this, info);
                var hadLength = Boolean(array.length);
                var args = Array.prototype.slice.call(arguments, 1);
                var ret = array.shift.apply(array, args);
                if (hadLength) {
                    this._notifySplice(array, info.path, 0, 0, [ret]);
                }
                return ret;
            },
            unshift: function (path) {
                var info = {};
                var array = this._get(path, this, info);
                var args = Array.prototype.slice.call(arguments, 1);
                var ret = array.unshift.apply(array, args);
                if (args.length) {
                    this._notifySplice(array, info.path, 0, args.length, []);
                }
                return ret;
            },
            prepareModelNotifyPath: function (model) {
                this.mixin(model, {
                    fire: Polymer.Base.fire,
                    notifyPath: Polymer.Base.notifyPath,
                    _get: Polymer.Base._get,
                    _EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
                    _notifyPath: Polymer.Base._notifyPath,
                    _notifyPathUp: Polymer.Base._notifyPathUp,
                    _pathEffector: Polymer.Base._pathEffector,
                    _annotationPathEffect: Polymer.Base._annotationPathEffect,
                    _complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
                    _annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
                    _computePathEffect: Polymer.Base._computePathEffect,
                    _modelForPath: Polymer.Base._modelForPath,
                    _pathMatchesEffect: Polymer.Base._pathMatchesEffect,
                    _notifyBoundPaths: Polymer.Base._notifyBoundPaths,
                    _getPathParts: Polymer.Base._getPathParts
                });
            }
        });
    }());
    Polymer.Base._addFeature({
        resolveUrl: function (url) {
            var module = Polymer.DomModule.import(this.is);
            var root = '';
            if (module) {
                var assetPath = module.getAttribute('assetpath') || '';
                root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
            }
            return Polymer.ResolveUrl.resolveUrl(url, root);
        }
    });
    Polymer.CssParse = function () {
        var api = {
            parse: function (text) {
                text = this._clean(text);
                return this._parseCss(this._lex(text), text);
            },
            _clean: function (cssText) {
                return cssText.replace(this._rx.comments, '').replace(this._rx.port, '');
            },
            _lex: function (text) {
                var root = {
                    start: 0,
                    end: text.length
                };
                var n = root;
                for (var i = 0, s = 0, l = text.length; i < l; i++) {
                    switch (text[i]) {
                        case this.OPEN_BRACE:
                            if (!n.rules) {
                                n.rules = [];
                            }
                            var p = n;
                            var previous = p.rules[p.rules.length - 1];
                            n = {
                                start: i + 1,
                                parent: p,
                                previous: previous
                            };
                            p.rules.push(n);
                            break;
                        case this.CLOSE_BRACE:
                            n.end = i + 1;
                            n = n.parent || root;
                            break;
                    }
                }
                return root;
            },
            _parseCss: function (node, text) {
                var t = text.substring(node.start, node.end - 1);
                node.parsedCssText = node.cssText = t.trim();
                if (node.parent) {
                    var ss = node.previous ? node.previous.end : node.parent.start;
                    t = text.substring(ss, node.start - 1);
                    t = t.substring(t.lastIndexOf(';') + 1);
                    var s = node.parsedSelector = node.selector = t.trim();
                    node.atRule = s.indexOf(this.AT_START) === 0;
                    if (node.atRule) {
                        if (s.indexOf(this.MEDIA_START) === 0) {
                            node.type = this.types.MEDIA_RULE;
                        } else if (s.match(this._rx.keyframesRule)) {
                            node.type = this.types.KEYFRAMES_RULE;
                        }
                    } else {
                        if (s.indexOf(this.VAR_START) === 0) {
                            node.type = this.types.MIXIN_RULE;
                        } else {
                            node.type = this.types.STYLE_RULE;
                        }
                    }
                }
                var r$ = node.rules;
                if (r$) {
                    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
                        this._parseCss(r, text);
                    }
                }
                return node;
            },
            stringify: function (node, preserveProperties, text) {
                text = text || '';
                var cssText = '';
                if (node.cssText || node.rules) {
                    var r$ = node.rules;
                    if (r$ && (preserveProperties || !this._hasMixinRules(r$))) {
                        for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
                            cssText = this.stringify(r, preserveProperties, cssText);
                        }
                    } else {
                        cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
                        cssText = cssText.trim();
                        if (cssText) {
                            cssText = '  ' + cssText + '\n';
                        }
                    }
                }
                if (cssText) {
                    if (node.selector) {
                        text += node.selector + ' ' + this.OPEN_BRACE + '\n';
                    }
                    text += cssText;
                    if (node.selector) {
                        text += this.CLOSE_BRACE + '\n\n';
                    }
                }
                return text;
            },
            _hasMixinRules: function (rules) {
                return rules[0].selector.indexOf(this.VAR_START) >= 0;
            },
            removeCustomProps: function (cssText) {
                cssText = this.removeCustomPropAssignment(cssText);
                return this.removeCustomPropApply(cssText);
            },
            removeCustomPropAssignment: function (cssText) {
                return cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');
            },
            removeCustomPropApply: function (cssText) {
                return cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');
            },
            types: {
                STYLE_RULE: 1,
                KEYFRAMES_RULE: 7,
                MEDIA_RULE: 4,
                MIXIN_RULE: 1000
            },
            OPEN_BRACE: '{',
            CLOSE_BRACE: '}',
            _rx: {
                comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
                port: /@import[^;]*;/gim,
                customProp: /(?:^|[\s;])--[^;{]*?:[^{};]*?(?:[;\n]|$)/gim,
                mixinProp: /(?:^|[\s;])--[^;{]*?:[^{;]*?{[^}]*?}(?:[;\n]|$)?/gim,
                mixinApply: /@apply[\s]*\([^)]*?\)[\s]*(?:[;\n]|$)?/gim,
                varApply: /[^;:]*?:[^;]*var[^;]*(?:[;\n]|$)?/gim,
                keyframesRule: /^@[^\s]*keyframes/
            },
            VAR_START: '--',
            MEDIA_START: '@media',
            AT_START: '@'
        };
        return api;
    }();
    Polymer.StyleUtil = function () {
        return {
            MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
            INCLUDE_ATTR: 'include',
            toCssText: function (rules, callback, preserveProperties) {
                if (typeof rules === 'string') {
                    rules = this.parser.parse(rules);
                }
                if (callback) {
                    this.forEachStyleRule(rules, callback);
                }
                return this.parser.stringify(rules, preserveProperties);
            },
            forRulesInStyles: function (styles, callback) {
                if (styles) {
                    for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
                        this.forEachStyleRule(this.rulesForStyle(s), callback);
                    }
                }
            },
            rulesForStyle: function (style) {
                if (!style.__cssRules && style.textContent) {
                    style.__cssRules = this.parser.parse(style.textContent);
                }
                return style.__cssRules;
            },
            clearStyleRules: function (style) {
                style.__cssRules = null;
            },
            forEachStyleRule: function (node, callback) {
                if (!node) {
                    return;
                }
                var s = node.parsedSelector;
                var skipRules = false;
                if (node.type === this.ruleTypes.STYLE_RULE) {
                    callback(node);
                } else if (node.type === this.ruleTypes.KEYFRAMES_RULE || node.type === this.ruleTypes.MIXIN_RULE) {
                    skipRules = true;
                }
                var r$ = node.rules;
                if (r$ && !skipRules) {
                    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
                        this.forEachStyleRule(r, callback);
                    }
                }
            },
            applyCss: function (cssText, moniker, target, afterNode) {
                var style = document.createElement('style');
                if (moniker) {
                    style.setAttribute('scope', moniker);
                }
                style.textContent = cssText;
                target = target || document.head;
                if (!afterNode) {
                    var n$ = target.querySelectorAll('style[scope]');
                    afterNode = n$[n$.length - 1];
                }
                target.insertBefore(style, afterNode && afterNode.nextSibling || target.firstChild);
                return style;
            },
            cssFromModules: function (moduleIds, warnIfNotFound) {
                var modules = moduleIds.trim().split(' ');
                var cssText = '';
                for (var i = 0; i < modules.length; i++) {
                    cssText += this.cssFromModule(modules[i], warnIfNotFound);
                }
                return cssText;
            },
            cssFromModule: function (moduleId, warnIfNotFound) {
                var m = Polymer.DomModule.import(moduleId);
                if (m && !m._cssText) {
                    m._cssText = this._cssFromElement(m);
                }
                if (!m && warnIfNotFound) {
                    console.warn('Could not find style data in module named', moduleId);
                }
                return m && m._cssText || '';
            },
            _cssFromElement: function (element) {
                var cssText = '';
                var content = element.content || element;
                var e$ = Array.prototype.slice.call(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
                for (var i = 0, e; i < e$.length; i++) {
                    e = e$[i];
                    if (e.localName === 'template') {
                        cssText += this._cssFromElement(e);
                    } else {
                        if (e.localName === 'style') {
                            var include = e.getAttribute(this.INCLUDE_ATTR);
                            if (include) {
                                cssText += this.cssFromModules(include, true);
                            }
                            e = e.__appliedElement || e;
                            e.parentNode.removeChild(e);
                            cssText += this.resolveCss(e.textContent, element.ownerDocument);
                        } else if (e.import && e.import.body) {
                            cssText += this.resolveCss(e.import.body.textContent, e.import);
                        }
                    }
                }
                return cssText;
            },
            resolveCss: Polymer.ResolveUrl.resolveCss,
            parser: Polymer.CssParse,
            ruleTypes: Polymer.CssParse.types
        };
    }();
    Polymer.StyleTransformer = function () {
        var nativeShadow = Polymer.Settings.useNativeShadow;
        var styleUtil = Polymer.StyleUtil;
        var api = {
            dom: function (node, scope, useAttr, shouldRemoveScope) {
                this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
            },
            _transformDom: function (node, selector, useAttr, shouldRemoveScope) {
                if (node.setAttribute) {
                    this.element(node, selector, useAttr, shouldRemoveScope);
                }
                var c$ = Polymer.dom(node).childNodes;
                for (var i = 0; i < c$.length; i++) {
                    this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
                }
            },
            element: function (element, scope, useAttr, shouldRemoveScope) {
                if (useAttr) {
                    if (shouldRemoveScope) {
                        element.removeAttribute(SCOPE_NAME);
                    } else {
                        element.setAttribute(SCOPE_NAME, scope);
                    }
                } else {
                    if (scope) {
                        if (element.classList) {
                            if (shouldRemoveScope) {
                                element.classList.remove(SCOPE_NAME);
                                element.classList.remove(scope);
                            } else {
                                element.classList.add(SCOPE_NAME);
                                element.classList.add(scope);
                            }
                        } else if (element.getAttribute) {
                            var c = element.getAttribute(CLASS);
                            if (shouldRemoveScope) {
                                if (c) {
                                    element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
                                }
                            } else {
                                element.setAttribute(CLASS, c + (c ? ' ' : '') + SCOPE_NAME + ' ' + scope);
                            }
                        }
                    }
                }
            },
            elementStyles: function (element, callback) {
                var styles = element._styles;
                var cssText = '';
                for (var i = 0, l = styles.length, s, text; i < l && (s = styles[i]); i++) {
                    var rules = styleUtil.rulesForStyle(s);
                    cssText += nativeShadow ? styleUtil.toCssText(rules, callback) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
                }
                return cssText.trim();
            },
            css: function (rules, scope, ext, callback, useAttr) {
                var hostScope = this._calcHostScope(scope, ext);
                scope = this._calcElementScope(scope, useAttr);
                var self = this;
                return styleUtil.toCssText(rules, function (rule) {
                    if (!rule.isScoped) {
                        self.rule(rule, scope, hostScope);
                        rule.isScoped = true;
                    }
                    if (callback) {
                        callback(rule, scope, hostScope);
                    }
                });
            },
            _calcElementScope: function (scope, useAttr) {
                if (scope) {
                    return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
                } else {
                    return '';
                }
            },
            _calcHostScope: function (scope, ext) {
                return ext ? '[is=' + scope + ']' : scope;
            },
            rule: function (rule, scope, hostScope) {
                this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
            },
            _transformRule: function (rule, transformer, scope, hostScope) {
                var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
                for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
                    p$[i] = transformer.call(this, p, scope, hostScope);
                }
                rule.selector = rule.transformedSelector = p$.join(COMPLEX_SELECTOR_SEP);
            },
            _transformComplexSelector: function (selector, scope, hostScope) {
                var stop = false;
                var hostContext = false;
                var self = this;
                selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
                    if (!stop) {
                        var info = self._transformCompoundSelector(s, c, scope, hostScope);
                        stop = stop || info.stop;
                        hostContext = hostContext || info.hostContext;
                        c = info.combinator;
                        s = info.value;
                    } else {
                        s = s.replace(SCOPE_JUMP, ' ');
                    }
                    return c + s;
                });
                if (hostContext) {
                    selector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {
                        return pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;
                    });
                }
                return selector;
            },
            _transformCompoundSelector: function (selector, combinator, scope, hostScope) {
                var jumpIndex = selector.search(SCOPE_JUMP);
                var hostContext = false;
                if (selector.indexOf(HOST_CONTEXT) >= 0) {
                    hostContext = true;
                } else if (selector.indexOf(HOST) >= 0) {
                    selector = selector.replace(HOST_PAREN, function (m, host, paren) {
                        return hostScope + paren;
                    });
                    selector = selector.replace(HOST, hostScope);
                } else if (jumpIndex !== 0) {
                    selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
                }
                if (selector.indexOf(CONTENT) >= 0) {
                    combinator = '';
                }
                var stop;
                if (jumpIndex >= 0) {
                    selector = selector.replace(SCOPE_JUMP, ' ');
                    stop = true;
                }
                return {
                    value: selector,
                    combinator: combinator,
                    stop: stop,
                    hostContext: hostContext
                };
            },
            _transformSimpleSelector: function (selector, scope) {
                var p$ = selector.split(PSEUDO_PREFIX);
                p$[0] += scope;
                return p$.join(PSEUDO_PREFIX);
            },
            documentRule: function (rule) {
                rule.selector = rule.parsedSelector;
                this.normalizeRootSelector(rule);
                if (!nativeShadow) {
                    this._transformRule(rule, this._transformDocumentSelector);
                }
            },
            normalizeRootSelector: function (rule) {
                if (rule.selector === ROOT) {
                    rule.selector = 'body';
                }
            },
            _transformDocumentSelector: function (selector) {
                return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
            },
            SCOPE_NAME: 'style-scope'
        };
        var SCOPE_NAME = api.SCOPE_NAME;
        var SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
        var COMPLEX_SELECTOR_SEP = ',';
        var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)([^\s>+~]+)/g;
        var HOST = ':host';
        var ROOT = ':root';
        var HOST_PAREN = /(\:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
        var HOST_CONTEXT = ':host-context';
        var HOST_CONTEXT_PAREN = /(.*)(?:\:host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
        var CONTENT = '::content';
        var SCOPE_JUMP = /\:\:content|\:\:shadow|\/deep\//;
        var CSS_CLASS_PREFIX = '.';
        var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
        var CSS_ATTR_SUFFIX = ']';
        var PSEUDO_PREFIX = ':';
        var CLASS = 'class';
        return api;
    }();
    Polymer.StyleExtends = function () {
        var styleUtil = Polymer.StyleUtil;
        return {
            hasExtends: function (cssText) {
                return Boolean(cssText.match(this.rx.EXTEND));
            },
            transform: function (style) {
                var rules = styleUtil.rulesForStyle(style);
                var self = this;
                styleUtil.forEachStyleRule(rules, function (rule) {
                    var map = self._mapRule(rule);
                    if (rule.parent) {
                        var m;
                        while (m = self.rx.EXTEND.exec(rule.cssText)) {
                            var extend = m[1];
                            var extendor = self._findExtendor(extend, rule);
                            if (extendor) {
                                self._extendRule(rule, extendor);
                            }
                        }
                    }
                    rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
                });
                return styleUtil.toCssText(rules, function (rule) {
                    if (rule.selector.match(self.rx.STRIP)) {
                        rule.cssText = '';
                    }
                }, true);
            },
            _mapRule: function (rule) {
                if (rule.parent) {
                    var map = rule.parent.map || (rule.parent.map = {});
                    var parts = rule.selector.split(',');
                    for (var i = 0, p; i < parts.length; i++) {
                        p = parts[i];
                        map[p.trim()] = rule;
                    }
                    return map;
                }
            },
            _findExtendor: function (extend, rule) {
                return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
            },
            _extendRule: function (target, source) {
                if (target.parent !== source.parent) {
                    this._cloneAndAddRuleToParent(source, target.parent);
                }
                target.extends = target.extends || (target.extends = []);
                target.extends.push(source);
                source.selector = source.selector.replace(this.rx.STRIP, '');
                source.selector = (source.selector && source.selector + ',\n') + target.selector;
                if (source.extends) {
                    source.extends.forEach(function (e) {
                        this._extendRule(target, e);
                    }, this);
                }
            },
            _cloneAndAddRuleToParent: function (rule, parent) {
                rule = Object.create(rule);
                rule.parent = parent;
                if (rule.extends) {
                    rule.extends = rule.extends.slice();
                }
                parent.rules.push(rule);
            },
            rx: {
                EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
                STRIP: /%[^,]*$/
            }
        };
    }();
    (function () {
        var prepElement = Polymer.Base._prepElement;
        var nativeShadow = Polymer.Settings.useNativeShadow;
        var styleUtil = Polymer.StyleUtil;
        var styleTransformer = Polymer.StyleTransformer;
        var styleExtends = Polymer.StyleExtends;
        Polymer.Base._addFeature({
            _prepElement: function (element) {
                if (this._encapsulateStyle) {
                    styleTransformer.element(element, this.is, this._scopeCssViaAttr);
                }
                prepElement.call(this, element);
            },
            _prepStyles: function () {
                if (this._encapsulateStyle === undefined) {
                    this._encapsulateStyle = !nativeShadow && Boolean(this._template);
                }
                this._styles = this._collectStyles();
                var cssText = styleTransformer.elementStyles(this);
                if (cssText && this._template) {
                    var style = styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null);
                    if (!nativeShadow) {
                        this._scopeStyle = style;
                    }
                }
            },
            _collectStyles: function () {
                var styles = [];
                var cssText = '', m$ = this.styleModules;
                if (m$) {
                    for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
                        cssText += styleUtil.cssFromModule(m);
                    }
                }
                cssText += styleUtil.cssFromModule(this.is);
                if (cssText) {
                    var style = document.createElement('style');
                    style.textContent = cssText;
                    if (styleExtends.hasExtends(style.textContent)) {
                        cssText = styleExtends.transform(style);
                    }
                    styles.push(style);
                }
                return styles;
            },
            _elementAdd: function (node) {
                if (this._encapsulateStyle) {
                    if (node.__styleScoped) {
                        node.__styleScoped = false;
                    } else {
                        styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
                    }
                }
            },
            _elementRemove: function (node) {
                if (this._encapsulateStyle) {
                    styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
                }
            },
            scopeSubtree: function (container, shouldObserve) {
                if (nativeShadow) {
                    return;
                }
                var self = this;
                var scopify = function (node) {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        node.className = self._scopeElementClass(node, node.className);
                        var n$ = node.querySelectorAll('*');
                        Array.prototype.forEach.call(n$, function (n) {
                            n.className = self._scopeElementClass(n, n.className);
                        });
                    }
                };
                scopify(container);
                if (shouldObserve) {
                    var mo = new MutationObserver(function (mxns) {
                        mxns.forEach(function (m) {
                            if (m.addedNodes) {
                                for (var i = 0; i < m.addedNodes.length; i++) {
                                    scopify(m.addedNodes[i]);
                                }
                            }
                        });
                    });
                    mo.observe(container, {
                        childList: true,
                        subtree: true
                    });
                    return mo;
                }
            }
        });
    }());
    Polymer.StyleProperties = function () {
        'use strict';
        var nativeShadow = Polymer.Settings.useNativeShadow;
        var matchesSelector = Polymer.DomApi.matchesSelector;
        var styleUtil = Polymer.StyleUtil;
        var styleTransformer = Polymer.StyleTransformer;
        return {
            decorateStyles: function (styles) {
                var self = this, props = {};
                styleUtil.forRulesInStyles(styles, function (rule) {
                    self.decorateRule(rule);
                    self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
                });
                var names = [];
                for (var i in props) {
                    names.push(i);
                }
                return names;
            },
            decorateRule: function (rule) {
                if (rule.propertyInfo) {
                    return rule.propertyInfo;
                }
                var info = {}, properties = {};
                var hasProperties = this.collectProperties(rule, properties);
                if (hasProperties) {
                    info.properties = properties;
                    rule.rules = null;
                }
                info.cssText = this.collectCssText(rule);
                rule.propertyInfo = info;
                return info;
            },
            collectProperties: function (rule, properties) {
                var info = rule.propertyInfo;
                if (info) {
                    if (info.properties) {
                        Polymer.Base.mixin(properties, info.properties);
                        return true;
                    }
                } else {
                    var m, rx = this.rx.VAR_ASSIGN;
                    var cssText = rule.parsedCssText;
                    var any;
                    while (m = rx.exec(cssText)) {
                        properties[m[1]] = (m[2] || m[3]).trim();
                        any = true;
                    }
                    return any;
                }
            },
            collectCssText: function (rule) {
                var customCssText = '';
                var cssText = rule.parsedCssText;
                cssText = cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
                var parts = cssText.split(';');
                for (var i = 0, p; i < parts.length; i++) {
                    p = parts[i];
                    if (p.match(this.rx.MIXIN_MATCH) || p.match(this.rx.VAR_MATCH)) {
                        customCssText += p + ';\n';
                    }
                }
                return customCssText;
            },
            collectPropertiesInCssText: function (cssText, props) {
                var m;
                while (m = this.rx.VAR_CAPTURE.exec(cssText)) {
                    props[m[1]] = true;
                    var def = m[2];
                    if (def && def.match(this.rx.IS_VAR)) {
                        props[def] = true;
                    }
                }
            },
            reify: function (props) {
                var names = Object.getOwnPropertyNames(props);
                for (var i = 0, n; i < names.length; i++) {
                    n = names[i];
                    props[n] = this.valueForProperty(props[n], props);
                }
            },
            valueForProperty: function (property, props) {
                if (property) {
                    if (property.indexOf(';') >= 0) {
                        property = this.valueForProperties(property, props);
                    } else {
                        var self = this;
                        var fn = function (all, prefix, value, fallback) {
                            var propertyValue = self.valueForProperty(props[value], props) || (props[fallback] ? self.valueForProperty(props[fallback], props) : fallback);
                            return prefix + (propertyValue || '');
                        };
                        property = property.replace(this.rx.VAR_MATCH, fn);
                    }
                }
                return property && property.trim() || '';
            },
            valueForProperties: function (property, props) {
                var parts = property.split(';');
                for (var i = 0, p, m; i < parts.length; i++) {
                    if (p = parts[i]) {
                        m = p.match(this.rx.MIXIN_MATCH);
                        if (m) {
                            p = this.valueForProperty(props[m[1]], props);
                        } else {
                            var pp = p.split(':');
                            if (pp[1]) {
                                pp[1] = pp[1].trim();
                                pp[1] = this.valueForProperty(pp[1], props) || pp[1];
                            }
                            p = pp.join(':');
                        }
                        parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
                    }
                }
                return parts.join(';');
            },
            applyProperties: function (rule, props) {
                var output = '';
                if (!rule.propertyInfo) {
                    this.decorateRule(rule);
                }
                if (rule.propertyInfo.cssText) {
                    output = this.valueForProperties(rule.propertyInfo.cssText, props);
                }
                rule.cssText = output;
            },
            propertyDataFromStyles: function (styles, element) {
                var props = {}, self = this;
                var o = [], i = 0;
                styleUtil.forRulesInStyles(styles, function (rule) {
                    if (!rule.propertyInfo) {
                        self.decorateRule(rule);
                    }
                    if (element && rule.propertyInfo.properties && matchesSelector.call(element, rule.transformedSelector || rule.parsedSelector)) {
                        self.collectProperties(rule, props);
                        addToBitMask(i, o);
                    }
                    i++;
                });
                return {
                    properties: props,
                    key: o
                };
            },
            scopePropertiesFromStyles: function (styles) {
                if (!styles._scopeStyleProperties) {
                    styles._scopeStyleProperties = this.selectedPropertiesFromStyles(styles, this.SCOPE_SELECTORS);
                }
                return styles._scopeStyleProperties;
            },
            hostPropertiesFromStyles: function (styles) {
                if (!styles._hostStyleProperties) {
                    styles._hostStyleProperties = this.selectedPropertiesFromStyles(styles, this.HOST_SELECTORS);
                }
                return styles._hostStyleProperties;
            },
            selectedPropertiesFromStyles: function (styles, selectors) {
                var props = {}, self = this;
                styleUtil.forRulesInStyles(styles, function (rule) {
                    if (!rule.propertyInfo) {
                        self.decorateRule(rule);
                    }
                    for (var i = 0; i < selectors.length; i++) {
                        if (rule.parsedSelector === selectors[i]) {
                            self.collectProperties(rule, props);
                            return;
                        }
                    }
                });
                return props;
            },
            transformStyles: function (element, properties, scopeSelector) {
                var self = this;
                var hostSelector = styleTransformer._calcHostScope(element.is, element.extends);
                var rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
                var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
                return styleTransformer.elementStyles(element, function (rule) {
                    self.applyProperties(rule, properties);
                    if (rule.cssText && !nativeShadow) {
                        self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);
                    }
                });
            },
            _scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {
                rule.transformedSelector = rule.transformedSelector || rule.selector;
                var selector = rule.transformedSelector;
                var scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;
                var parts = selector.split(',');
                for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
                    parts[i] = p.match(hostRx) ? p.replace(hostSelector, hostSelector + scope) : scope + ' ' + p;
                }
                rule.selector = parts.join(',');
            },
            applyElementScopeSelector: function (element, selector, old, viaAttr) {
                var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.className;
                var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
                if (c !== v) {
                    if (viaAttr) {
                        element.setAttribute(styleTransformer.SCOPE_NAME, v);
                    } else {
                        element.className = v;
                    }
                }
            },
            applyElementStyle: function (element, properties, selector, style) {
                var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
                var s = element._customStyle;
                if (s && !nativeShadow && s !== style) {
                    s._useCount--;
                    if (s._useCount <= 0 && s.parentNode) {
                        s.parentNode.removeChild(s);
                    }
                }
                if (nativeShadow || (!style || !style.parentNode)) {
                    if (nativeShadow && element._customStyle) {
                        element._customStyle.textContent = cssText;
                        style = element._customStyle;
                    } else if (cssText) {
                        style = styleUtil.applyCss(cssText, selector, nativeShadow ? element.root : null, element._scopeStyle);
                    }
                }
                if (style) {
                    style._useCount = style._useCount || 0;
                    if (element._customStyle != style) {
                        style._useCount++;
                    }
                    element._customStyle = style;
                }
                return style;
            },
            mixinCustomStyle: function (props, customStyle) {
                var v;
                for (var i in customStyle) {
                    v = customStyle[i];
                    if (v || v === 0) {
                        props[i] = v;
                    }
                }
            },
            rx: {
                VAR_ASSIGN: /(?:^|[;\n]\s*)(--[\w-]*?):\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\n])|$)/gi,
                MIXIN_MATCH: /(?:^|\W+)@apply[\s]*\(([^)]*)\)/i,
                VAR_MATCH: /(^|\W+)var\([\s]*([^,)]*)[\s]*,?[\s]*((?:[^,)]*)|(?:[^;]*\([^;)]*\)))[\s]*?\)/gi,
                VAR_CAPTURE: /\([\s]*(--[^,\s)]*)(?:,[\s]*(--[^,\s)]*))?(?:\)|,)/gi,
                IS_VAR: /^--/,
                BRACKETED: /\{[^}]*\}/g,
                HOST_PREFIX: '(?:^|[^.#[:])',
                HOST_SUFFIX: '($|[.:[\\s>+~])'
            },
            HOST_SELECTORS: [':host'],
            SCOPE_SELECTORS: [':root'],
            XSCOPE_NAME: 'x-scope'
        };
        function addToBitMask(n, bits) {
            var o = parseInt(n / 32);
            var v = 1 << n % 32;
            bits[o] = (bits[o] || 0) | v;
        }
    }();
    (function () {
        Polymer.StyleCache = function () {
            this.cache = {};
        };
        Polymer.StyleCache.prototype = {
            MAX: 100,
            store: function (is, data, keyValues, keyStyles) {
                data.keyValues = keyValues;
                data.styles = keyStyles;
                var s$ = this.cache[is] = this.cache[is] || [];
                s$.push(data);
                if (s$.length > this.MAX) {
                    s$.shift();
                }
            },
            retrieve: function (is, keyValues, keyStyles) {
                var cache = this.cache[is];
                if (cache) {
                    for (var i = cache.length - 1, data; i >= 0; i--) {
                        data = cache[i];
                        if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
                            return data;
                        }
                    }
                }
            },
            clear: function () {
                this.cache = {};
            },
            _objectsEqual: function (target, source) {
                var t, s;
                for (var i in target) {
                    t = target[i], s = source[i];
                    if (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
                        return false;
                    }
                }
                if (Array.isArray(target)) {
                    return target.length === source.length;
                }
                return true;
            },
            _objectsStrictlyEqual: function (target, source) {
                return this._objectsEqual(target, source) && this._objectsEqual(source, target);
            }
        };
    }());
    Polymer.StyleDefaults = function () {
        var styleProperties = Polymer.StyleProperties;
        var styleUtil = Polymer.StyleUtil;
        var StyleCache = Polymer.StyleCache;
        var api = {
            _styles: [],
            _properties: null,
            customStyle: {},
            _styleCache: new StyleCache(),
            addStyle: function (style) {
                this._styles.push(style);
                this._properties = null;
            },
            get _styleProperties() {
                if (!this._properties) {
                    styleProperties.decorateStyles(this._styles);
                    this._styles._scopeStyleProperties = null;
                    this._properties = styleProperties.scopePropertiesFromStyles(this._styles);
                    styleProperties.mixinCustomStyle(this._properties, this.customStyle);
                    styleProperties.reify(this._properties);
                }
                return this._properties;
            },
            _needsStyleProperties: function () {
            },
            _computeStyleProperties: function () {
                return this._styleProperties;
            },
            updateStyles: function (properties) {
                this._properties = null;
                if (properties) {
                    Polymer.Base.mixin(this.customStyle, properties);
                }
                this._styleCache.clear();
                for (var i = 0, s; i < this._styles.length; i++) {
                    s = this._styles[i];
                    s = s.__importElement || s;
                    s._apply();
                }
            }
        };
        return api;
    }();
    (function () {
        'use strict';
        var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
        var propertyUtils = Polymer.StyleProperties;
        var styleTransformer = Polymer.StyleTransformer;
        var styleUtil = Polymer.StyleUtil;
        var styleDefaults = Polymer.StyleDefaults;
        var nativeShadow = Polymer.Settings.useNativeShadow;
        Polymer.Base._addFeature({
            _prepStyleProperties: function () {
                this._ownStylePropertyNames = this._styles ? propertyUtils.decorateStyles(this._styles) : [];
            },
            customStyle: {},
            _setupStyleProperties: function () {
                this.customStyle = {};
            },
            _needsStyleProperties: function () {
                return Boolean(this._ownStylePropertyNames && this._ownStylePropertyNames.length);
            },
            _beforeAttached: function () {
                if (!this._scopeSelector && this._needsStyleProperties()) {
                    this._updateStyleProperties();
                }
            },
            _findStyleHost: function () {
                var e = this, root;
                while (root = Polymer.dom(e).getOwnerRoot()) {
                    if (Polymer.isInstance(root.host)) {
                        return root.host;
                    }
                    e = root.host;
                }
                return styleDefaults;
            },
            _updateStyleProperties: function () {
                var info, scope = this._findStyleHost();
                if (!scope._styleCache) {
                    scope._styleCache = new Polymer.StyleCache();
                }
                var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
                scopeData.key.customStyle = this.customStyle;
                info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
                var scopeCached = Boolean(info);
                if (scopeCached) {
                    this._styleProperties = info._styleProperties;
                } else {
                    this._computeStyleProperties(scopeData.properties);
                }
                this._computeOwnStyleProperties();
                if (!scopeCached) {
                    info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
                }
                var globalCached = Boolean(info) && !scopeCached;
                var style = this._applyStyleProperties(info);
                if (!scopeCached) {
                    style = style && nativeShadow ? style.cloneNode(true) : style;
                    info = {
                        style: style,
                        _scopeSelector: this._scopeSelector,
                        _styleProperties: this._styleProperties
                    };
                    scopeData.key.customStyle = {};
                    this.mixin(scopeData.key.customStyle, this.customStyle);
                    scope._styleCache.store(this.is, info, scopeData.key, this._styles);
                    if (!globalCached) {
                        styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
                    }
                }
            },
            _computeStyleProperties: function (scopeProps) {
                var scope = this._findStyleHost();
                if (!scope._styleProperties) {
                    scope._computeStyleProperties();
                }
                var props = Object.create(scope._styleProperties);
                this.mixin(props, propertyUtils.hostPropertiesFromStyles(this._styles));
                scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
                this.mixin(props, scopeProps);
                this.mixin(props, propertyUtils.scopePropertiesFromStyles(this._styles));
                propertyUtils.mixinCustomStyle(props, this.customStyle);
                propertyUtils.reify(props);
                this._styleProperties = props;
            },
            _computeOwnStyleProperties: function () {
                var props = {};
                for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
                    n = this._ownStylePropertyNames[i];
                    props[n] = this._styleProperties[n];
                }
                this._ownStyleProperties = props;
            },
            _scopeCount: 0,
            _applyStyleProperties: function (info) {
                var oldScopeSelector = this._scopeSelector;
                this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
                var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
                if (!nativeShadow) {
                    propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
                }
                return style;
            },
            serializeValueToAttribute: function (value, attribute, node) {
                node = node || this;
                if (attribute === 'class' && !nativeShadow) {
                    var host = node === this ? this.domHost || this.dataHost : this;
                    if (host) {
                        value = host._scopeElementClass(node, value);
                    }
                }
                node = Polymer.dom(node);
                serializeValueToAttribute.call(this, value, attribute, node);
            },
            _scopeElementClass: function (element, selector) {
                if (!nativeShadow && !this._scopeCssViaAttr) {
                    selector += (selector ? ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
                }
                return selector;
            },
            updateStyles: function (properties) {
                if (this.isAttached) {
                    if (properties) {
                        this.mixin(this.customStyle, properties);
                    }
                    if (this._needsStyleProperties()) {
                        this._updateStyleProperties();
                    } else {
                        this._styleProperties = null;
                    }
                    if (this._styleCache) {
                        this._styleCache.clear();
                    }
                    this._updateRootStyles();
                }
            },
            _updateRootStyles: function (root) {
                root = root || this.root;
                var c$ = Polymer.dom(root)._query(function (e) {
                    return e.shadyRoot || e.shadowRoot;
                });
                for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
                    if (c.updateStyles) {
                        c.updateStyles();
                    }
                }
            }
        });
        Polymer.updateStyles = function (properties) {
            styleDefaults.updateStyles(properties);
            Polymer.Base._updateRootStyles(document);
        };
        var styleCache = new Polymer.StyleCache();
        Polymer.customStyleCache = styleCache;
        var SCOPE_NAME = styleTransformer.SCOPE_NAME;
        var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
    }());
    Polymer.Base._addFeature({
        _registerFeatures: function () {
            this._prepIs();
            this._prepAttributes();
            this._prepConstructor();
            this._prepTemplate();
            this._prepStyles();
            this._prepStyleProperties();
            this._prepAnnotations();
            this._prepEffects();
            this._prepBehaviors();
            this._prepBindings();
            this._prepShady();
        },
        _prepBehavior: function (b) {
            this._addPropertyEffects(b.properties);
            this._addComplexObserverEffects(b.observers);
            this._addHostAttributes(b.hostAttributes);
        },
        _initFeatures: function () {
            this._poolContent();
            this._setupConfigure();
            this._setupStyleProperties();
            this._pushHost();
            this._stampTemplate();
            this._popHost();
            this._marshalAnnotationReferences();
            this._setupDebouncers();
            this._marshalInstanceEffects();
            this._marshalHostAttributes();
            this._marshalBehaviors();
            this._marshalAttributes();
            this._tryReady();
        },
        _marshalBehavior: function (b) {
            this._listenListeners(b.listeners);
        }
    });
    (function () {
        var nativeShadow = Polymer.Settings.useNativeShadow;
        var propertyUtils = Polymer.StyleProperties;
        var styleUtil = Polymer.StyleUtil;
        var cssParse = Polymer.CssParse;
        var styleDefaults = Polymer.StyleDefaults;
        var styleTransformer = Polymer.StyleTransformer;
        Polymer({
            is: 'custom-style',
            extends: 'style',
            properties: {include: String},
            ready: function () {
                this._tryApply();
            },
            attached: function () {
                this._tryApply();
            },
            _tryApply: function () {
                if (!this._appliesToDocument) {
                    if (this.parentNode && this.parentNode.localName !== 'dom-module') {
                        this._appliesToDocument = true;
                        var e = this.__appliedElement || this;
                        styleDefaults.addStyle(e);
                        if (e.textContent || this.include) {
                            this._apply();
                        } else {
                            var observer = new MutationObserver(function () {
                                observer.disconnect();
                                this._apply();
                            }.bind(this));
                            observer.observe(e, {childList: true});
                        }
                    }
                }
            },
            _apply: function () {
                var e = this.__appliedElement || this;
                if (this.include) {
                    e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
                }
                if (e.textContent) {
                    styleUtil.forEachStyleRule(styleUtil.rulesForStyle(e), function (rule) {
                        styleTransformer.documentRule(rule);
                    });
                    this._applyCustomProperties(e);
                }
            },
            _applyCustomProperties: function (element) {
                this._computeStyleProperties();
                var props = this._styleProperties;
                var rules = styleUtil.rulesForStyle(element);
                element.textContent = styleUtil.toCssText(rules, function (rule) {
                    var css = rule.cssText = rule.parsedCssText;
                    if (rule.propertyInfo && rule.propertyInfo.cssText) {
                        css = cssParse.removeCustomPropAssignment(css);
                        rule.cssText = propertyUtils.valueForProperties(css, props);
                    }
                });
            }
        });
    }());
    Polymer.Templatizer = {
        properties: {__hideTemplateChildren__: {observer: '_showHideChildren'}},
        _instanceProps: Polymer.nob,
        _parentPropPrefix: '_parent_',
        templatize: function (template) {
            this._templatized = template;
            if (!template._content) {
                template._content = template.content;
            }
            if (template._content._ctor) {
                this.ctor = template._content._ctor;
                this._prepParentProperties(this.ctor.prototype, template);
                return;
            }
            var archetype = Object.create(Polymer.Base);
            this._customPrepAnnotations(archetype, template);
            this._prepParentProperties(archetype, template);
            archetype._prepEffects();
            this._customPrepEffects(archetype);
            archetype._prepBehaviors();
            archetype._prepBindings();
            archetype._notifyPathUp = this._notifyPathUpImpl;
            archetype._scopeElementClass = this._scopeElementClassImpl;
            archetype.listen = this._listenImpl;
            archetype._showHideChildren = this._showHideChildrenImpl;
            var _constructor = this._constructorImpl;
            var ctor = function TemplateInstance(model, host) {
                _constructor.call(this, model, host);
            };
            ctor.prototype = archetype;
            archetype.constructor = ctor;
            template._content._ctor = ctor;
            this.ctor = ctor;
        },
        _getRootDataHost: function () {
            return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
        },
        _showHideChildrenImpl: function (hide) {
            var c = this._children;
            for (var i = 0; i < c.length; i++) {
                var n = c[i];
                if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
                    if (n.nodeType === Node.TEXT_NODE) {
                        if (hide) {
                            n.__polymerTextContent__ = n.textContent;
                            n.textContent = '';
                        } else {
                            n.textContent = n.__polymerTextContent__;
                        }
                    } else if (n.style) {
                        if (hide) {
                            n.__polymerDisplay__ = n.style.display;
                            n.style.display = 'none';
                        } else {
                            n.style.display = n.__polymerDisplay__;
                        }
                    }
                }
                n.__hideTemplateChildren__ = hide;
            }
        },
        _debounceTemplate: function (fn) {
            Polymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));
        },
        _flushTemplates: function (debouncerExpired) {
            Polymer.dom.flush();
        },
        _customPrepEffects: function (archetype) {
            var parentProps = archetype._parentProps;
            for (var prop in parentProps) {
                archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
            }
            for (var prop in this._instanceProps) {
                archetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));
            }
        },
        _customPrepAnnotations: function (archetype, template) {
            archetype._template = template;
            var c = template._content;
            if (!c._notes) {
                var rootDataHost = archetype._rootDataHost;
                if (rootDataHost) {
                    Polymer.Annotations.prepElement = rootDataHost._prepElement.bind(rootDataHost);
                }
                c._notes = Polymer.Annotations.parseAnnotations(template);
                Polymer.Annotations.prepElement = null;
                this._processAnnotations(c._notes);
            }
            archetype._notes = c._notes;
            archetype._parentProps = c._parentProps;
        },
        _prepParentProperties: function (archetype, template) {
            var parentProps = this._parentProps = archetype._parentProps;
            if (this._forwardParentProp && parentProps) {
                var proto = archetype._parentPropProto;
                var prop;
                if (!proto) {
                    for (prop in this._instanceProps) {
                        delete parentProps[prop];
                    }
                    proto = archetype._parentPropProto = Object.create(null);
                    if (template != this) {
                        Polymer.Bind.prepareModel(proto);
                        Polymer.Base.prepareModelNotifyPath(proto);
                    }
                    for (prop in parentProps) {
                        var parentProp = this._parentPropPrefix + prop;
                        var effects = [
                            {
                                kind: 'function',
                                effect: this._createForwardPropEffector(prop)
                            },
                            {kind: 'notify'}
                        ];
                        Polymer.Bind._createAccessors(proto, parentProp, effects);
                    }
                }
                if (template != this) {
                    Polymer.Bind.prepareInstance(template);
                    template._forwardParentProp = this._forwardParentProp.bind(this);
                }
                this._extendTemplate(template, proto);
                template._pathEffector = this._pathEffectorImpl.bind(this);
            }
        },
        _createForwardPropEffector: function (prop) {
            return function (source, value) {
                this._forwardParentProp(prop, value);
            };
        },
        _createHostPropEffector: function (prop) {
            var prefix = this._parentPropPrefix;
            return function (source, value) {
                this.dataHost._templatized[prefix + prop] = value;
            };
        },
        _createInstancePropEffector: function (prop) {
            return function (source, value, old, fromAbove) {
                if (!fromAbove) {
                    this.dataHost._forwardInstanceProp(this, prop, value);
                }
            };
        },
        _extendTemplate: function (template, proto) {
            Object.getOwnPropertyNames(proto).forEach(function (n) {
                var val = template[n];
                var pd = Object.getOwnPropertyDescriptor(proto, n);
                Object.defineProperty(template, n, pd);
                if (val !== undefined) {
                    template._propertySetter(n, val);
                }
            });
        },
        _showHideChildren: function (hidden) {
        },
        _forwardInstancePath: function (inst, path, value) {
        },
        _forwardInstanceProp: function (inst, prop, value) {
        },
        _notifyPathUpImpl: function (path, value) {
            var dataHost = this.dataHost;
            var dot = path.indexOf('.');
            var root = dot < 0 ? path : path.slice(0, dot);
            dataHost._forwardInstancePath.call(dataHost, this, path, value);
            if (root in dataHost._parentProps) {
                dataHost._templatized.notifyPath(dataHost._parentPropPrefix + path, value);
            }
        },
        _pathEffectorImpl: function (path, value, fromAbove) {
            if (this._forwardParentPath) {
                if (path.indexOf(this._parentPropPrefix) === 0) {
                    var subPath = path.substring(this._parentPropPrefix.length);
                    this._forwardParentPath(subPath, value);
                }
            }
            Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);
        },
        _constructorImpl: function (model, host) {
            this._rootDataHost = host._getRootDataHost();
            this._setupConfigure(model);
            this._pushHost(host);
            this.root = this.instanceTemplate(this._template);
            this.root.__noContent = !this._notes._hasContent;
            this.root.__styleScoped = true;
            this._popHost();
            this._marshalAnnotatedNodes();
            this._marshalInstanceEffects();
            this._marshalAnnotatedListeners();
            var children = [];
            for (var n = this.root.firstChild; n; n = n.nextSibling) {
                children.push(n);
                n._templateInstance = this;
            }
            this._children = children;
            if (host.__hideTemplateChildren__) {
                this._showHideChildren(true);
            }
            this._tryReady();
        },
        _listenImpl: function (node, eventName, methodName) {
            var model = this;
            var host = this._rootDataHost;
            var handler = host._createEventHandler(node, eventName, methodName);
            var decorated = function (e) {
                e.model = model;
                handler(e);
            };
            host._listen(node, eventName, decorated);
        },
        _scopeElementClassImpl: function (node, value) {
            var host = this._rootDataHost;
            if (host) {
                return host._scopeElementClass(node, value);
            }
        },
        stamp: function (model) {
            model = model || {};
            if (this._parentProps) {
                var templatized = this._templatized;
                for (var prop in this._parentProps) {
                    model[prop] = templatized[this._parentPropPrefix + prop];
                }
            }
            return new this.ctor(model, this);
        },
        modelForElement: function (el) {
            var model;
            while (el) {
                if (model = el._templateInstance) {
                    if (model.dataHost != this) {
                        el = model.dataHost;
                    } else {
                        return model;
                    }
                } else {
                    el = el.parentNode;
                }
            }
        }
    };
    Polymer({
        is: 'dom-template',
        extends: 'template',
        behaviors: [Polymer.Templatizer],
        ready: function () {
            this.templatize(this);
        }
    });
    Polymer._collections = new WeakMap();
    Polymer.Collection = function (userArray) {
        Polymer._collections.set(userArray, this);
        this.userArray = userArray;
        this.store = userArray.slice();
        this.initMap();
    };
    Polymer.Collection.prototype = {
        constructor: Polymer.Collection,
        initMap: function () {
            var omap = this.omap = new WeakMap();
            var pmap = this.pmap = {};
            var s = this.store;
            for (var i = 0; i < s.length; i++) {
                var item = s[i];
                if (item && typeof item == 'object') {
                    omap.set(item, i);
                } else {
                    pmap[item] = i;
                }
            }
        },
        add: function (item) {
            var key = this.store.push(item) - 1;
            if (item && typeof item == 'object') {
                this.omap.set(item, key);
            } else {
                this.pmap[item] = key;
            }
            return '#' + key;
        },
        removeKey: function (key) {
            key = this._parseKey(key);
            this._removeFromMap(this.store[key]);
            delete this.store[key];
        },
        _removeFromMap: function (item) {
            if (item && typeof item == 'object') {
                this.omap.delete(item);
            } else {
                delete this.pmap[item];
            }
        },
        remove: function (item) {
            var key = this.getKey(item);
            this.removeKey(key);
            return key;
        },
        getKey: function (item) {
            var key;
            if (item && typeof item == 'object') {
                key = this.omap.get(item);
            } else {
                key = this.pmap[item];
            }
            if (key != undefined) {
                return '#' + key;
            }
        },
        getKeys: function () {
            return Object.keys(this.store).map(function (key) {
                return '#' + key;
            });
        },
        _parseKey: function (key) {
            if (key[0] == '#') {
                return key.slice(1);
            }
            throw new Error('unexpected key ' + key);
        },
        setItem: function (key, item) {
            key = this._parseKey(key);
            var old = this.store[key];
            if (old) {
                this._removeFromMap(old);
            }
            if (item && typeof item == 'object') {
                this.omap.set(item, key);
            } else {
                this.pmap[item] = key;
            }
            this.store[key] = item;
        },
        getItem: function (key) {
            key = this._parseKey(key);
            return this.store[key];
        },
        getItems: function () {
            var items = [], store = this.store;
            for (var key in store) {
                items.push(store[key]);
            }
            return items;
        },
        _applySplices: function (splices) {
            var keyMap = {}, key, i;
            splices.forEach(function (s) {
                s.addedKeys = [];
                for (i = 0; i < s.removed.length; i++) {
                    key = this.getKey(s.removed[i]);
                    keyMap[key] = keyMap[key] ? null : -1;
                }
                for (i = 0; i < s.addedCount; i++) {
                    var item = this.userArray[s.index + i];
                    key = this.getKey(item);
                    key = key === undefined ? this.add(item) : key;
                    keyMap[key] = keyMap[key] ? null : 1;
                    s.addedKeys.push(key);
                }
            }, this);
            var removed = [];
            var added = [];
            for (var key in keyMap) {
                if (keyMap[key] < 0) {
                    this.removeKey(key);
                    removed.push(key);
                }
                if (keyMap[key] > 0) {
                    added.push(key);
                }
            }
            return [{
                removed: removed,
                added: added
            }];
        }
    };
    Polymer.Collection.get = function (userArray) {
        return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
    };
    Polymer.Collection.applySplices = function (userArray, splices) {
        var coll = Polymer._collections.get(userArray);
        return coll ? coll._applySplices(splices) : null;
    };
    Polymer({
        is: 'dom-repeat',
        extends: 'template',
        properties: {
            items: {type: Array},
            as: {
                type: String,
                value: 'item'
            },
            indexAs: {
                type: String,
                value: 'index'
            },
            sort: {
                type: Function,
                observer: '_sortChanged'
            },
            filter: {
                type: Function,
                observer: '_filterChanged'
            },
            observe: {
                type: String,
                observer: '_observeChanged'
            },
            delay: Number
        },
        behaviors: [Polymer.Templatizer],
        observers: ['_itemsChanged(items.*)'],
        created: function () {
            this._instances = [];
        },
        detached: function () {
            for (var i = 0; i < this._instances.length; i++) {
                this._detachRow(i);
            }
        },
        attached: function () {
            var parentNode = Polymer.dom(this).parentNode;
            for (var i = 0; i < this._instances.length; i++) {
                Polymer.dom(parentNode).insertBefore(this._instances[i].root, this);
            }
        },
        ready: function () {
            this._instanceProps = {__key__: true};
            this._instanceProps[this.as] = true;
            this._instanceProps[this.indexAs] = true;
            if (!this.ctor) {
                this.templatize(this);
            }
        },
        _sortChanged: function () {
            var dataHost = this._getRootDataHost();
            var sort = this.sort;
            this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
                        return dataHost[sort].apply(dataHost, arguments);
                    });
            this._needFullRefresh = true;
            if (this.items) {
                this._debounceTemplate(this._render);
            }
        },
        _filterChanged: function () {
            var dataHost = this._getRootDataHost();
            var filter = this.filter;
            this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
                        return dataHost[filter].apply(dataHost, arguments);
                    });
            this._needFullRefresh = true;
            if (this.items) {
                this._debounceTemplate(this._render);
            }
        },
        _observeChanged: function () {
            this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
        },
        _itemsChanged: function (change) {
            if (change.path == 'items') {
                if (Array.isArray(this.items)) {
                    this.collection = Polymer.Collection.get(this.items);
                } else if (!this.items) {
                    this.collection = null;
                } else {
                    this._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));
                }
                this._keySplices = [];
                this._indexSplices = [];
                this._needFullRefresh = true;
                this._debounceTemplate(this._render);
            } else if (change.path == 'items.splices') {
                this._keySplices = this._keySplices.concat(change.value.keySplices);
                this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
                this._debounceTemplate(this._render);
            } else {
                var subpath = change.path.slice(6);
                this._forwardItemPath(subpath, change.value);
                this._checkObservedPaths(subpath);
            }
        },
        _checkObservedPaths: function (path) {
            if (this._observePaths) {
                path = path.substring(path.indexOf('.') + 1);
                var paths = this._observePaths;
                for (var i = 0; i < paths.length; i++) {
                    if (path.indexOf(paths[i]) === 0) {
                        this._needFullRefresh = true;
                        if (this.delay) {
                            this.debounce('render', this._render, this.delay);
                        } else {
                            this._debounceTemplate(this._render);
                        }
                        return;
                    }
                }
            }
        },
        render: function () {
            this._needFullRefresh = true;
            this._debounceTemplate(this._render);
            this._flushTemplates();
        },
        _render: function () {
            var c = this.collection;
            if (this._needFullRefresh) {
                this._applyFullRefresh();
                this._needFullRefresh = false;
            } else {
                if (this._sortFn) {
                    this._applySplicesUserSort(this._keySplices);
                } else {
                    if (this._filterFn) {
                        this._applyFullRefresh();
                    } else {
                        this._applySplicesArrayOrder(this._indexSplices);
                    }
                }
            }
            this._keySplices = [];
            this._indexSplices = [];
            var keyToIdx = this._keyToInstIdx = {};
            for (var i = 0; i < this._instances.length; i++) {
                var inst = this._instances[i];
                keyToIdx[inst.__key__] = i;
                inst.__setProperty(this.indexAs, i, true);
            }
            this.fire('dom-change');
        },
        _applyFullRefresh: function () {
            var c = this.collection;
            var keys;
            if (this._sortFn) {
                keys = c ? c.getKeys() : [];
            } else {
                keys = [];
                var items = this.items;
                if (items) {
                    for (var i = 0; i < items.length; i++) {
                        keys.push(c.getKey(items[i]));
                    }
                }
            }
            if (this._filterFn) {
                keys = keys.filter(function (a) {
                    return this._filterFn(c.getItem(a));
                }, this);
            }
            if (this._sortFn) {
                keys.sort(function (a, b) {
                    return this._sortFn(c.getItem(a), c.getItem(b));
                }.bind(this));
            }
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var inst = this._instances[i];
                if (inst) {
                    inst.__setProperty('__key__', key, true);
                    inst.__setProperty(this.as, c.getItem(key), true);
                } else {
                    this._instances.push(this._insertRow(i, key));
                }
            }
            for (; i < this._instances.length; i++) {
                this._detachRow(i);
            }
            this._instances.splice(keys.length, this._instances.length - keys.length);
        },
        _keySort: function (a, b) {
            return this.collection.getKey(a) - this.collection.getKey(b);
        },
        _numericSort: function (a, b) {
            return a - b;
        },
        _applySplicesUserSort: function (splices) {
            var c = this.collection;
            var instances = this._instances;
            var keyMap = {};
            var pool = [];
            var sortFn = this._sortFn || this._keySort.bind(this);
            splices.forEach(function (s) {
                for (var i = 0; i < s.removed.length; i++) {
                    var key = s.removed[i];
                    keyMap[key] = keyMap[key] ? null : -1;
                }
                for (var i = 0; i < s.added.length; i++) {
                    var key = s.added[i];
                    keyMap[key] = keyMap[key] ? null : 1;
                }
            }, this);
            var removedIdxs = [];
            var addedKeys = [];
            for (var key in keyMap) {
                if (keyMap[key] === -1) {
                    removedIdxs.push(this._keyToInstIdx[key]);
                }
                if (keyMap[key] === 1) {
                    addedKeys.push(key);
                }
            }
            if (removedIdxs.length) {
                removedIdxs.sort(this._numericSort);
                for (var i = removedIdxs.length - 1; i >= 0; i--) {
                    var idx = removedIdxs[i];
                    if (idx !== undefined) {
                        pool.push(this._detachRow(idx));
                        instances.splice(idx, 1);
                    }
                }
            }
            if (addedKeys.length) {
                if (this._filterFn) {
                    addedKeys = addedKeys.filter(function (a) {
                        return this._filterFn(c.getItem(a));
                    }, this);
                }
                addedKeys.sort(function (a, b) {
                    return this._sortFn(c.getItem(a), c.getItem(b));
                }.bind(this));
                var start = 0;
                for (var i = 0; i < addedKeys.length; i++) {
                    start = this._insertRowUserSort(start, addedKeys[i], pool);
                }
            }
        },
        _insertRowUserSort: function (start, key, pool) {
            var c = this.collection;
            var item = c.getItem(key);
            var end = this._instances.length - 1;
            var idx = -1;
            var sortFn = this._sortFn || this._keySort.bind(this);
            while (start <= end) {
                var mid = start + end >> 1;
                var midKey = this._instances[mid].__key__;
                var cmp = sortFn(c.getItem(midKey), item);
                if (cmp < 0) {
                    start = mid + 1;
                } else if (cmp > 0) {
                    end = mid - 1;
                } else {
                    idx = mid;
                    break;
                }
            }
            if (idx < 0) {
                idx = end + 1;
            }
            this._instances.splice(idx, 0, this._insertRow(idx, key, pool));
            return idx;
        },
        _applySplicesArrayOrder: function (splices) {
            var pool = [];
            var c = this.collection;
            splices.forEach(function (s) {
                for (var i = 0; i < s.removed.length; i++) {
                    var inst = this._detachRow(s.index + i);
                    if (!inst.isPlaceholder) {
                        pool.push(inst);
                    }
                }
                this._instances.splice(s.index, s.removed.length);
                for (var i = 0; i < s.addedKeys.length; i++) {
                    var inst = {
                        isPlaceholder: true,
                        key: s.addedKeys[i]
                    };
                    this._instances.splice(s.index + i, 0, inst);
                }
            }, this);
            for (var i = this._instances.length - 1; i >= 0; i--) {
                var inst = this._instances[i];
                if (inst.isPlaceholder) {
                    this._instances[i] = this._insertRow(i, inst.key, pool, true);
                }
            }
        },
        _detachRow: function (idx) {
            var inst = this._instances[idx];
            if (!inst.isPlaceholder) {
                var parentNode = Polymer.dom(this).parentNode;
                for (var i = 0; i < inst._children.length; i++) {
                    var el = inst._children[i];
                    Polymer.dom(inst.root).appendChild(el);
                }
            }
            return inst;
        },
        _insertRow: function (idx, key, pool, replace) {
            var inst;
            if (inst = pool && pool.pop()) {
                inst.__setProperty(this.as, this.collection.getItem(key), true);
                inst.__setProperty('__key__', key, true);
            } else {
                inst = this._generateRow(idx, key);
            }
            var beforeRow = this._instances[replace ? idx + 1 : idx];
            var beforeNode = beforeRow ? beforeRow._children[0] : this;
            var parentNode = Polymer.dom(this).parentNode;
            Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
            return inst;
        },
        _generateRow: function (idx, key) {
            var model = {__key__: key};
            model[this.as] = this.collection.getItem(key);
            model[this.indexAs] = idx;
            var inst = this.stamp(model);
            return inst;
        },
        _showHideChildren: function (hidden) {
            for (var i = 0; i < this._instances.length; i++) {
                this._instances[i]._showHideChildren(hidden);
            }
        },
        _forwardInstanceProp: function (inst, prop, value) {
            if (prop == this.as) {
                var idx;
                if (this._sortFn || this._filterFn) {
                    idx = this.items.indexOf(this.collection.getItem(inst.__key__));
                } else {
                    idx = inst[this.indexAs];
                }
                this.set('items.' + idx, value);
            }
        },
        _forwardInstancePath: function (inst, path, value) {
            if (path.indexOf(this.as + '.') === 0) {
                this._notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);
            }
        },
        _forwardParentProp: function (prop, value) {
            this._instances.forEach(function (inst) {
                inst.__setProperty(prop, value, true);
            }, this);
        },
        _forwardParentPath: function (path, value) {
            this._instances.forEach(function (inst) {
                inst._notifyPath(path, value, true);
            }, this);
        },
        _forwardItemPath: function (path, value) {
            if (this._keyToInstIdx) {
                var dot = path.indexOf('.');
                var key = path.substring(0, dot < 0 ? path.length : dot);
                var idx = this._keyToInstIdx[key];
                var inst = this._instances[idx];
                if (inst) {
                    if (dot >= 0) {
                        path = this.as + '.' + path.substring(dot + 1);
                        inst._notifyPath(path, value, true);
                    } else {
                        inst.__setProperty(this.as, value, true);
                    }
                }
            }
        },
        itemForElement: function (el) {
            var instance = this.modelForElement(el);
            return instance && instance[this.as];
        },
        keyForElement: function (el) {
            var instance = this.modelForElement(el);
            return instance && instance.__key__;
        },
        indexForElement: function (el) {
            var instance = this.modelForElement(el);
            return instance && instance[this.indexAs];
        }
    });
    Polymer({
        is: 'array-selector',
        properties: {
            items: {
                type: Array,
                observer: 'clearSelection'
            },
            multi: {
                type: Boolean,
                value: false,
                observer: 'clearSelection'
            },
            selected: {
                type: Object,
                notify: true
            },
            selectedItem: {
                type: Object,
                notify: true
            },
            toggle: {
                type: Boolean,
                value: false
            }
        },
        clearSelection: function () {
            if (Array.isArray(this.selected)) {
                for (var i = 0; i < this.selected.length; i++) {
                    this.unlinkPaths('selected.' + i);
                }
            } else {
                this.unlinkPaths('selected');
                this.unlinkPaths('selectedItem');
            }
            if (this.multi) {
                if (!this.selected || this.selected.length) {
                    this.selected = [];
                    this._selectedColl = Polymer.Collection.get(this.selected);
                }
            } else {
                this.selected = null;
                this._selectedColl = null;
            }
            this.selectedItem = null;
        },
        isSelected: function (item) {
            if (this.multi) {
                return this._selectedColl.getKey(item) !== undefined;
            } else {
                return this.selected == item;
            }
        },
        deselect: function (item) {
            if (this.multi) {
                if (this.isSelected(item)) {
                    var skey = this._selectedColl.getKey(item);
                    this.arrayDelete('selected', item);
                    this.unlinkPaths('selected.' + skey);
                }
            } else {
                this.selected = null;
                this.selectedItem = null;
                this.unlinkPaths('selected');
                this.unlinkPaths('selectedItem');
            }
        },
        select: function (item) {
            var icol = Polymer.Collection.get(this.items);
            var key = icol.getKey(item);
            if (this.multi) {
                if (this.isSelected(item)) {
                    if (this.toggle) {
                        this.deselect(item);
                    }
                } else {
                    this.push('selected', item);
                    var skey = this._selectedColl.getKey(item);
                    this.linkPaths('selected.' + skey, 'items.' + key);
                }
            } else {
                if (this.toggle && item == this.selected) {
                    this.deselect();
                } else {
                    this.selected = item;
                    this.selectedItem = item;
                    this.linkPaths('selected', 'items.' + key);
                    this.linkPaths('selectedItem', 'items.' + key);
                }
            }
        }
    });
    Polymer({
        is: 'dom-if',
        extends: 'template',
        properties: {
            'if': {
                type: Boolean,
                value: false,
                observer: '_queueRender'
            },
            restamp: {
                type: Boolean,
                value: false,
                observer: '_queueRender'
            }
        },
        behaviors: [Polymer.Templatizer],
        _queueRender: function () {
            this._debounceTemplate(this._render);
        },
        detached: function () {
            this._teardownInstance();
        },
        attached: function () {
            if (this.if && this.ctor) {
                this.async(this._ensureInstance);
            }
        },
        render: function () {
            this._flushTemplates();
        },
        _render: function () {
            if (this.if) {
                if (!this.ctor) {
                    this.templatize(this);
                }
                this._ensureInstance();
                this._showHideChildren();
            } else if (this.restamp) {
                this._teardownInstance();
            }
            if (!this.restamp && this._instance) {
                this._showHideChildren();
            }
            if (this.if != this._lastIf) {
                this.fire('dom-change');
                this._lastIf = this.if;
            }
        },
        _ensureInstance: function () {
            if (!this._instance) {
                this._instance = this.stamp();
                var root = this._instance.root;
                var parent = Polymer.dom(Polymer.dom(this).parentNode);
                parent.insertBefore(root, this);
            }
        },
        _teardownInstance: function () {
            if (this._instance) {
                var c = this._instance._children;
                if (c) {
                    var parent = Polymer.dom(Polymer.dom(c[0]).parentNode);
                    c.forEach(function (n) {
                        parent.removeChild(n);
                    });
                }
                this._instance = null;
            }
        },
        _showHideChildren: function () {
            var hidden = this.__hideTemplateChildren__ || !this.if;
            if (this._instance) {
                this._instance._showHideChildren(hidden);
            }
        },
        _forwardParentProp: function (prop, value) {
            if (this._instance) {
                this._instance[prop] = value;
            }
        },
        _forwardParentPath: function (path, value) {
            if (this._instance) {
                this._instance._notifyPath(path, value, true);
            }
        }
    });
    Polymer({
        is: 'dom-bind',
        extends: 'template',
        created: function () {
            Polymer.RenderStatus.whenReady(this._markImportsReady.bind(this));
        },
        _ensureReady: function () {
            if (!this._readied) {
                this._readySelf();
            }
        },
        _markImportsReady: function () {
            this._importsReady = true;
            this._ensureReady();
        },
        _registerFeatures: function () {
            this._prepConstructor();
        },
        _insertChildren: function () {
            var parentDom = Polymer.dom(Polymer.dom(this).parentNode);
            parentDom.insertBefore(this.root, this);
        },
        _removeChildren: function () {
            if (this._children) {
                for (var i = 0; i < this._children.length; i++) {
                    this.root.appendChild(this._children[i]);
                }
            }
        },
        _initFeatures: function () {
        },
        _scopeElementClass: function (element, selector) {
            if (this.dataHost) {
                return this.dataHost._scopeElementClass(element, selector);
            } else {
                return selector;
            }
        },
        _prepConfigure: function () {
            var config = {};
            for (var prop in this._propertyEffects) {
                config[prop] = this[prop];
            }
            this._setupConfigure = this._setupConfigure.bind(this, config);
        },
        attached: function () {
            if (this._importsReady) {
                this.render();
            }
        },
        detached: function () {
            this._removeChildren();
        },
        render: function () {
            this._ensureReady();
            if (!this._children) {
                this._template = this;
                this._prepAnnotations();
                this._prepEffects();
                this._prepBehaviors();
                this._prepConfigure();
                this._prepBindings();
                Polymer.Base._initFeatures.call(this);
                this._children = Array.prototype.slice.call(this.root.childNodes);
            }
            this._insertChildren();
            this.fire('dom-change');
        }
    });</script>
    <!--
The `<iron-flex-layout>` component provides simple ways to use [CSS flexible box layout](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes), also known as flexbox. This component provides two different ways to use flexbox:

1. [Layout classes](https://github.com/PolymerElements/iron-flex-layout/tree/master/classes). The layout class stylesheet provides a simple set of class-based flexbox rules. Layout classes let you specify layout properties directly in markup.

2. [Custom CSS mixins](https://github.com/PolymerElements/iron-flex-layout/blob/master/iron-flex-layout.html). The mixin stylesheet includes custom CSS mixins that can be applied inside a CSS rule using the `@apply` function.

A complete [guide](https://elements.polymer-project.org/guides/flex-layout) to `<iron-flex-layout>` is available.

@group Iron Elements
@pseudoElement iron-flex-layout
@demo demo/index.html
-->

    <style>
        /* IE 10 support for HTML5 hidden attr */
        [hidden] {
            display: none !important;
        }
    </style>

    <style is="custom-style">
        :root {

            --layout: {
                display: -ms-flexbox;
                display: -webkit-flex;
                display: flex;
            };

            --layout-inline: {
                display: -ms-inline-flexbox;
                display: -webkit-inline-flex;
                display: inline-flex;
            };

            --layout-horizontal: {
                /* @apply(--layout); */
                display: -ms-flexbox;
                display: -webkit-flex;
                display: flex;

                -ms-flex-direction: row;
                -webkit-flex-direction: row;
                flex-direction: row;
            };

            --layout-horizontal-reverse: {
                -ms-flex-direction: row-reverse;
                -webkit-flex-direction: row-reverse;
                flex-direction: row-reverse;
            };

            --layout-vertical: {
                /* @apply(--layout); */
                display: -ms-flexbox;
                display: -webkit-flex;
                display: flex;

                -ms-flex-direction: column;
                -webkit-flex-direction: column;
                flex-direction: column;
            };

            --layout-vertical-reverse: {
                -ms-flex-direction: column-reverse;
                -webkit-flex-direction: column-reverse;
                flex-direction: column-reverse;
            };

            --layout-wrap: {
                -ms-flex-wrap: wrap;
                -webkit-flex-wrap: wrap;
                flex-wrap: wrap;
            };

            --layout-wrap-reverse: {
                -ms-flex-wrap: wrap-reverse;
                -webkit-flex-wrap: wrap-reverse;
                flex-wrap: wrap-reverse;
            };

            --layout-flex-auto: {
                -ms-flex: 1 1 auto;
                -webkit-flex: 1 1 auto;
                flex: 1 1 auto;
            };

            --layout-flex-none: {
                -ms-flex: none;
                -webkit-flex: none;
                flex: none;
            };

            --layout-flex: {
                -ms-flex: 1 1 0.000000001px;
                -webkit-flex: 1;
                flex: 1;
                -webkit-flex-basis: 0.000000001px;
                flex-basis: 0.000000001px;
            };

            --layout-flex-2: {
                -ms-flex: 2;
                -webkit-flex: 2;
                flex: 2;
            };

            --layout-flex-3: {
                -ms-flex: 3;
                -webkit-flex: 3;
                flex: 3;
            };

            --layout-flex-4: {
                -ms-flex: 4;
                -webkit-flex: 4;
                flex: 4;
            };

            --layout-flex-5: {
                -ms-flex: 5;
                -webkit-flex: 5;
                flex: 5;
            };

            --layout-flex-6: {
                -ms-flex: 6;
                -webkit-flex: 6;
                flex: 6;
            };

            --layout-flex-7: {
                -ms-flex: 7;
                -webkit-flex: 7;
                flex: 7;
            };

            --layout-flex-8: {
                -ms-flex: 8;
                -webkit-flex: 8;
                flex: 8;
            };

            --layout-flex-9: {
                -ms-flex: 9;
                -webkit-flex: 9;
                flex: 9;
            };

            --layout-flex-10: {
                -ms-flex: 10;
                -webkit-flex: 10;
                flex: 10;
            };

            --layout-flex-11: {
                -ms-flex: 11;
                -webkit-flex: 11;
                flex: 11;
            };

            --layout-flex-12: {
                -ms-flex: 12;
                -webkit-flex: 12;
                flex: 12;
            };

            /* alignment in cross axis */

            --layout-start: {
                -ms-flex-align: start;
                -webkit-align-items: flex-start;
                align-items: flex-start;
            };

            --layout-center: {
                -ms-flex-align: center;
                -webkit-align-items: center;
                align-items: center;
            };

            --layout-end: {
                -ms-flex-align: end;
                -webkit-align-items: flex-end;
                align-items: flex-end;
            };

            /* alignment in main axis */

            --layout-start-justified: {
                -ms-flex-pack: start;
                -webkit-justify-content: flex-start;
                justify-content: flex-start;
            };

            --layout-center-justified: {
                -ms-flex-pack: center;
                -webkit-justify-content: center;
                justify-content: center;
            };

            --layout-end-justified: {
                -ms-flex-pack: end;
                -webkit-justify-content: flex-end;
                justify-content: flex-end;
            };

            --layout-around-justified: {
                -ms-flex-pack: around;
                -webkit-justify-content: space-around;
                justify-content: space-around;
            };

            --layout-justified: {
                -ms-flex-pack: justify;
                -webkit-justify-content: space-between;
                justify-content: space-between;
            };

            --layout-center-center: {
                /* @apply(--layout-center --layout-center-justified); */
                -ms-flex-align: center;
                -webkit-align-items: center;
                align-items: center;
                -ms-flex-pack: center;
                -webkit-justify-content: center;
                justify-content: center;
            };

            /* self alignment */

            --layout-self-start: {
                -ms-align-self: flex-start;
                -webkit-align-self: flex-start;
                align-self: flex-start;
            };

            --layout-self-center: {
                -ms-align-self: center;
                -webkit-align-self: center;
                align-self: center;
            };

            --layout-self-end: {
                -ms-align-self: flex-end;
                -webkit-align-self: flex-end;
                align-self: flex-end;
            };

            --layout-self-stretch: {
                -ms-align-self: stretch;
                -webkit-align-self: stretch;
                align-self: stretch;
            };

            /*******************************
              Other Layout
    *******************************/

            --layout-block: {
                display: block;
            };

            --layout-invisible: {
                visibility: hidden !important;
            };

            --layout-relative: {
                position: relative;
            };

            --layout-fit: {
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;
            };

            --layout-scroll: {
                -webkit-overflow-scrolling: touch;
                overflow: auto;
            };

            /* fixed position */

            --layout-fixed-top: {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
            };

            --layout-fixed-right: {
                position: fixed;
                top: 0;
                right: 0;
                bottom: 0;
            };

            --layout-fixed-bottom: {
                position: fixed;
                right: 0;
                bottom: 0;
                left: 0;
            };

            --layout-fixed-left: {
                position: fixed;
                top: 0;
                bottom: 0;
                left: 0;
            };

        }

    </style>
    <style>

        /*******************************
            Flex Layout
  *******************************/

        html /deep/ .layout.horizontal,
        html /deep/ .layout.horizontal-reverse,
        html /deep/ .layout.vertical,
        html /deep/ .layout.vertical-reverse {
            display: -ms-flexbox;
            display: -webkit-flex;
            display: flex;
        }

        html /deep/ .layout.inline {
            display: -ms-inline-flexbox;
            display: -webkit-inline-flex;
            display: inline-flex;
        }

        html /deep/ .layout.horizontal {
            -ms-flex-direction: row;
            -webkit-flex-direction: row;
            flex-direction: row;
        }

        html /deep/ .layout.horizontal-reverse {
            -ms-flex-direction: row-reverse;
            -webkit-flex-direction: row-reverse;
            flex-direction: row-reverse;
        }

        html /deep/ .layout.vertical {
            -ms-flex-direction: column;
            -webkit-flex-direction: column;
            flex-direction: column;
        }

        html /deep/ .layout.vertical-reverse {
            -ms-flex-direction: column-reverse;
            -webkit-flex-direction: column-reverse;
            flex-direction: column-reverse;
        }

        html /deep/ .layout.wrap {
            -ms-flex-wrap: wrap;
            -webkit-flex-wrap: wrap;
            flex-wrap: wrap;
        }

        html /deep/ .layout.wrap-reverse {
            -ms-flex-wrap: wrap-reverse;
            -webkit-flex-wrap: wrap-reverse;
            flex-wrap: wrap-reverse;
        }

        html /deep/ .flex-auto {
            -ms-flex: 1 1 auto;
            -webkit-flex: 1 1 auto;
            flex: 1 1 auto;
        }

        html /deep/ .flex-none {
            -ms-flex: none;
            -webkit-flex: none;
            flex: none;
        }

        html /deep/ .flex,
        html /deep/ .flex-1 {
            -ms-flex: 1;
            -webkit-flex: 1;
            flex: 1;
        }

        html /deep/ .flex-2 {
            -ms-flex: 2;
            -webkit-flex: 2;
            flex: 2;
        }

        html /deep/ .flex-3 {
            -ms-flex: 3;
            -webkit-flex: 3;
            flex: 3;
        }

        html /deep/ .flex-4 {
            -ms-flex: 4;
            -webkit-flex: 4;
            flex: 4;
        }

        html /deep/ .flex-5 {
            -ms-flex: 5;
            -webkit-flex: 5;
            flex: 5;
        }

        html /deep/ .flex-6 {
            -ms-flex: 6;
            -webkit-flex: 6;
            flex: 6;
        }

        html /deep/ .flex-7 {
            -ms-flex: 7;
            -webkit-flex: 7;
            flex: 7;
        }

        html /deep/ .flex-8 {
            -ms-flex: 8;
            -webkit-flex: 8;
            flex: 8;
        }

        html /deep/ .flex-9 {
            -ms-flex: 9;
            -webkit-flex: 9;
            flex: 9;
        }

        html /deep/ .flex-10 {
            -ms-flex: 10;
            -webkit-flex: 10;
            flex: 10;
        }

        html /deep/ .flex-11 {
            -ms-flex: 11;
            -webkit-flex: 11;
            flex: 11;
        }

        html /deep/ .flex-12 {
            -ms-flex: 12;
            -webkit-flex: 12;
            flex: 12;
        }

        /* alignment in cross axis */

        html /deep/ .layout.start {
            -ms-flex-align: start;
            -webkit-align-items: flex-start;
            align-items: flex-start;
        }

        html /deep/ .layout.center,
        html /deep/ .layout.center-center {
            -ms-flex-align: center;
            -webkit-align-items: center;
            align-items: center;
        }

        html /deep/ .layout.end {
            -ms-flex-align: end;
            -webkit-align-items: flex-end;
            align-items: flex-end;
        }

        /* alignment in main axis */

        html /deep/ .layout.start-justified {
            -ms-flex-pack: start;
            -webkit-justify-content: flex-start;
            justify-content: flex-start;
        }

        html /deep/ .layout.center-justified,
        html /deep/ .layout.center-center {
            -ms-flex-pack: center;
            -webkit-justify-content: center;
            justify-content: center;
        }

        html /deep/ .layout.end-justified {
            -ms-flex-pack: end;
            -webkit-justify-content: flex-end;
            justify-content: flex-end;
        }

        html /deep/ .layout.around-justified {
            -ms-flex-pack: around;
            -webkit-justify-content: space-around;
            justify-content: space-around;
        }

        html /deep/ .layout.justified {
            -ms-flex-pack: justify;
            -webkit-justify-content: space-between;
            justify-content: space-between;
        }

        /* self alignment */

        html /deep/ .self-start {
            -ms-align-self: flex-start;
            -webkit-align-self: flex-start;
            align-self: flex-start;
        }

        html /deep/ .self-center {
            -ms-align-self: center;
            -webkit-align-self: center;
            align-self: center;
        }

        html /deep/ .self-end {
            -ms-align-self: flex-end;
            -webkit-align-self: flex-end;
            align-self: flex-end;
        }

        html /deep/ .self-stretch {
            -ms-align-self: stretch;
            -webkit-align-self: stretch;
            align-self: stretch;
        }

        /*******************************
            Other Layout
  *******************************/

        html /deep/ .block {
            display: block;
        }

        /* IE 10 support for HTML5 hidden attr */
        html /deep/ [hidden] {
            display: none !important;
        }

        html /deep/ .invisible {
            visibility: hidden !important;
        }

        html /deep/ .relative {
            position: relative;
        }

        html /deep/ .fit {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        body.fullbleed {
            margin: 0;
            height: 100vh;
        }

        html /deep/ .scroll {
            -webkit-overflow-scrolling: touch;
            overflow: auto;
        }

        .fixed-bottom,
        .fixed-left,
        .fixed-right,
        .fixed-top {
            position: fixed;
        }

        html /deep/ .fixed-top {
            top: 0;
            left: 0;
            right: 0;
        }

        html /deep/ .fixed-right {
            top: 0;
            right: 0;
            botttom: 0;
        }

        html /deep/ .fixed-bottom {
            right: 0;
            bottom: 0;
            left: 0;
        }

        html /deep/ .fixed-left {
            top: 0;
            botttom: 0;
            left: 0;
        }

    </style>
    <style>

        /*******************************
            Flex Layout
  *******************************/

        .layout.horizontal,
        .layout.horizontal-reverse,
        .layout.vertical,
        .layout.vertical-reverse {
            display: -ms-flexbox;
            display: -webkit-flex;
            display: flex;
        }

        .layout.inline {
            display: -ms-inline-flexbox;
            display: -webkit-inline-flex;
            display: inline-flex;
        }

        .layout.horizontal {
            -ms-flex-direction: row;
            -webkit-flex-direction: row;
            flex-direction: row;
        }

        .layout.horizontal-reverse {
            -ms-flex-direction: row-reverse;
            -webkit-flex-direction: row-reverse;
            flex-direction: row-reverse;
        }

        .layout.vertical {
            -ms-flex-direction: column;
            -webkit-flex-direction: column;
            flex-direction: column;
        }

        .layout.vertical-reverse {
            -ms-flex-direction: column-reverse;
            -webkit-flex-direction: column-reverse;
            flex-direction: column-reverse;
        }

        .layout.wrap {
            -ms-flex-wrap: wrap;
            -webkit-flex-wrap: wrap;
            flex-wrap: wrap;
        }

        .layout.wrap-reverse {
            -ms-flex-wrap: wrap-reverse;
            -webkit-flex-wrap: wrap-reverse;
            flex-wrap: wrap-reverse;
        }

        .flex-auto {
            -ms-flex: 1 1 auto;
            -webkit-flex: 1 1 auto;
            flex: 1 1 auto;
        }

        .flex-none {
            -ms-flex: none;
            -webkit-flex: none;
            flex: none;
        }

        .flex,
        .flex-1 {
            -ms-flex: 1;
            -webkit-flex: 1;
            flex: 1;
        }

        .flex-2 {
            -ms-flex: 2;
            -webkit-flex: 2;
            flex: 2;
        }

        .flex-3 {
            -ms-flex: 3;
            -webkit-flex: 3;
            flex: 3;
        }

        .flex-4 {
            -ms-flex: 4;
            -webkit-flex: 4;
            flex: 4;
        }

        .flex-5 {
            -ms-flex: 5;
            -webkit-flex: 5;
            flex: 5;
        }

        .flex-6 {
            -ms-flex: 6;
            -webkit-flex: 6;
            flex: 6;
        }

        .flex-7 {
            -ms-flex: 7;
            -webkit-flex: 7;
            flex: 7;
        }

        .flex-8 {
            -ms-flex: 8;
            -webkit-flex: 8;
            flex: 8;
        }

        .flex-9 {
            -ms-flex: 9;
            -webkit-flex: 9;
            flex: 9;
        }

        .flex-10 {
            -ms-flex: 10;
            -webkit-flex: 10;
            flex: 10;
        }

        .flex-11 {
            -ms-flex: 11;
            -webkit-flex: 11;
            flex: 11;
        }

        .flex-12 {
            -ms-flex: 12;
            -webkit-flex: 12;
            flex: 12;
        }

        /* alignment in cross axis */

        .layout.start {
            -ms-flex-align: start;
            -webkit-align-items: flex-start;
            align-items: flex-start;
        }

        .layout.center,
        .layout.center-center {
            -ms-flex-align: center;
            -webkit-align-items: center;
            align-items: center;
        }

        .layout.end {
            -ms-flex-align: end;
            -webkit-align-items: flex-end;
            align-items: flex-end;
        }

        /* alignment in main axis */

        .layout.start-justified {
            -ms-flex-pack: start;
            -webkit-justify-content: flex-start;
            justify-content: flex-start;
        }

        .layout.center-justified,
        .layout.center-center {
            -ms-flex-pack: center;
            -webkit-justify-content: center;
            justify-content: center;
        }

        .layout.end-justified {
            -ms-flex-pack: end;
            -webkit-justify-content: flex-end;
            justify-content: flex-end;
        }

        .layout.around-justified {
            -ms-flex-pack: around;
            -webkit-justify-content: space-around;
            justify-content: space-around;
        }

        .layout.justified {
            -ms-flex-pack: justify;
            -webkit-justify-content: space-between;
            justify-content: space-between;
        }

        /* self alignment */

        .self-start {
            -ms-align-self: flex-start;
            -webkit-align-self: flex-start;
            align-self: flex-start;
        }

        .self-center {
            -ms-align-self: center;
            -webkit-align-self: center;
            align-self: center;
        }

        .self-end {
            -ms-align-self: flex-end;
            -webkit-align-self: flex-end;
            align-self: flex-end;
        }

        .self-stretch {
            -ms-align-self: stretch;
            -webkit-align-self: stretch;
            align-self: stretch;
        }

        /*******************************
            Other Layout
  *******************************/

        .block {
            display: block;
        }

        /* IE 10 support for HTML5 hidden attr */
        [hidden] {
            display: none !important;
        }

        .invisible {
            visibility: hidden !important;
        }

        .relative {
            position: relative;
        }

        .fit {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        body.fullbleed {
            margin: 0;
            height: 100vh;
        }

        .scroll {
            -webkit-overflow-scrolling: touch;
            overflow: auto;
        }

        /* fixed position */

        .fixed-bottom,
        .fixed-left,
        .fixed-right,
        .fixed-top {
            position: fixed;
        }

        .fixed-top {
            top: 0;
            left: 0;
            right: 0;
        }

        .fixed-right {
            top: 0;
            right: 0;
            bottom: 0;
        }

        .fixed-bottom {
            right: 0;
            bottom: 0;
            left: 0;
        }

        .fixed-left {
            top: 0;
            bottom: 0;
            left: 0;
        }

    </style>
    <!--
The `<paper-styles>` component provides simple ways to use Material Design CSS styles
in your application. The following imports are available:

1. [color.html](https://github.com/PolymerElements/paper-styles/blob/master/color.html):
a complete list of the colors defined in the Material Design [palette](https://www.google.com/design/spec/style/color.html)

2. [default-theme.html](https://github.com/PolymerElements/paper-styles/blob/master/default-theme.html): text,
background and accent colors that match the default Material Design theme

3. [shadow.html](https://github.com/PolymerElements/paper-styles/blob/master/shadow.html): Material Design
[elevation](https://www.google.com/design/spec/what-is-material/elevation-shadows.html) and shadow styles

4. [typography.html](https://github.com/PolymerElements/paper-styles/blob/master/typography.html):
Material Design [font](http://www.google.com/design/spec/style/typography.html#typography-styles) styles and sizes

5. [demo-pages.html](https://github.com/PolymerElements/paper-styles/blob/master/demo-pages.html): generic styles
used in the PolymerElements demo pages

@group Iron Elements
@pseudoElement paper-styles
@demo demo/index.html
-->

    <style is="custom-style">

        :root {

            /* Material Design color palette for Google products */

            --google-red-100: #f4c7c3;
            --google-red-300: #e67c73;
            --google-red-500: #db4437;
            --google-red-700: #c53929;

            --google-blue-100: #c6dafc;
            --google-blue-300: #7baaf7;
            --google-blue-500: #4285f4;
            --google-blue-700: #3367d6;

            --google-green-100: #b7e1cd;
            --google-green-300: #57bb8a;
            --google-green-500: #0f9d58;
            --google-green-700: #0b8043;

            --google-yellow-100: #fce8b2;
            --google-yellow-300: #f7cb4d;
            --google-yellow-500: #f4b400;
            --google-yellow-700: #f09300;

            --google-grey-100: #f5f5f5;
            --google-grey-300: #e0e0e0;
            --google-grey-500: #9e9e9e;
            --google-grey-700: #616161;

            /* Material Design color palette from online spec document */

            --paper-red-50: #ffebee;
            --paper-red-100: #ffcdd2;
            --paper-red-200: #ef9a9a;
            --paper-red-300: #e57373;
            --paper-red-400: #ef5350;
            --paper-red-500: #f44336;
            --paper-red-600: #e53935;
            --paper-red-700: #d32f2f;
            --paper-red-800: #c62828;
            --paper-red-900: #b71c1c;
            --paper-red-a100: #ff8a80;
            --paper-red-a200: #ff5252;
            --paper-red-a400: #ff1744;
            --paper-red-a700: #d50000;

            --paper-pink-50: #fce4ec;
            --paper-pink-100: #f8bbd0;
            --paper-pink-200: #f48fb1;
            --paper-pink-300: #f06292;
            --paper-pink-400: #ec407a;
            --paper-pink-500: #e91e63;
            --paper-pink-600: #d81b60;
            --paper-pink-700: #c2185b;
            --paper-pink-800: #ad1457;
            --paper-pink-900: #880e4f;
            --paper-pink-a100: #ff80ab;
            --paper-pink-a200: #ff4081;
            --paper-pink-a400: #f50057;
            --paper-pink-a700: #c51162;

            --paper-purple-50: #f3e5f5;
            --paper-purple-100: #e1bee7;
            --paper-purple-200: #ce93d8;
            --paper-purple-300: #ba68c8;
            --paper-purple-400: #ab47bc;
            --paper-purple-500: #9c27b0;
            --paper-purple-600: #8e24aa;
            --paper-purple-700: #7b1fa2;
            --paper-purple-800: #6a1b9a;
            --paper-purple-900: #4a148c;
            --paper-purple-a100: #ea80fc;
            --paper-purple-a200: #e040fb;
            --paper-purple-a400: #d500f9;
            --paper-purple-a700: #aa00ff;

            --paper-deep-purple-50: #ede7f6;
            --paper-deep-purple-100: #d1c4e9;
            --paper-deep-purple-200: #b39ddb;
            --paper-deep-purple-300: #9575cd;
            --paper-deep-purple-400: #7e57c2;
            --paper-deep-purple-500: #673ab7;
            --paper-deep-purple-600: #5e35b1;
            --paper-deep-purple-700: #512da8;
            --paper-deep-purple-800: #4527a0;
            --paper-deep-purple-900: #311b92;
            --paper-deep-purple-a100: #b388ff;
            --paper-deep-purple-a200: #7c4dff;
            --paper-deep-purple-a400: #651fff;
            --paper-deep-purple-a700: #6200ea;

            --paper-indigo-50: #e8eaf6;
            --paper-indigo-100: #c5cae9;
            --paper-indigo-200: #9fa8da;
            --paper-indigo-300: #7986cb;
            --paper-indigo-400: #5c6bc0;
            --paper-indigo-500: #3f51b5;
            --paper-indigo-600: #3949ab;
            --paper-indigo-700: #303f9f;
            --paper-indigo-800: #283593;
            --paper-indigo-900: #1a237e;
            --paper-indigo-a100: #8c9eff;
            --paper-indigo-a200: #536dfe;
            --paper-indigo-a400: #3d5afe;
            --paper-indigo-a700: #304ffe;

            --paper-blue-50: #e3f2fd;
            --paper-blue-100: #bbdefb;
            --paper-blue-200: #90caf9;
            --paper-blue-300: #64b5f6;
            --paper-blue-400: #42a5f5;
            --paper-blue-500: #2196f3;
            --paper-blue-600: #1e88e5;
            --paper-blue-700: #1976d2;
            --paper-blue-800: #1565c0;
            --paper-blue-900: #0d47a1;
            --paper-blue-a100: #82b1ff;
            --paper-blue-a200: #448aff;
            --paper-blue-a400: #2979ff;
            --paper-blue-a700: #2962ff;

            --paper-light-blue-50: #e1f5fe;
            --paper-light-blue-100: #b3e5fc;
            --paper-light-blue-200: #81d4fa;
            --paper-light-blue-300: #4fc3f7;
            --paper-light-blue-400: #29b6f6;
            --paper-light-blue-500: #03a9f4;
            --paper-light-blue-600: #039be5;
            --paper-light-blue-700: #0288d1;
            --paper-light-blue-800: #0277bd;
            --paper-light-blue-900: #01579b;
            --paper-light-blue-a100: #80d8ff;
            --paper-light-blue-a200: #40c4ff;
            --paper-light-blue-a400: #00b0ff;
            --paper-light-blue-a700: #0091ea;

            --paper-cyan-50: #e0f7fa;
            --paper-cyan-100: #b2ebf2;
            --paper-cyan-200: #80deea;
            --paper-cyan-300: #4dd0e1;
            --paper-cyan-400: #26c6da;
            --paper-cyan-500: #00bcd4;
            --paper-cyan-600: #00acc1;
            --paper-cyan-700: #0097a7;
            --paper-cyan-800: #00838f;
            --paper-cyan-900: #006064;
            --paper-cyan-a100: #84ffff;
            --paper-cyan-a200: #18ffff;
            --paper-cyan-a400: #00e5ff;
            --paper-cyan-a700: #00b8d4;

            --paper-teal-50: #e0f2f1;
            --paper-teal-100: #b2dfdb;
            --paper-teal-200: #80cbc4;
            --paper-teal-300: #4db6ac;
            --paper-teal-400: #26a69a;
            --paper-teal-500: #009688;
            --paper-teal-600: #00897b;
            --paper-teal-700: #00796b;
            --paper-teal-800: #00695c;
            --paper-teal-900: #004d40;
            --paper-teal-a100: #a7ffeb;
            --paper-teal-a200: #64ffda;
            --paper-teal-a400: #1de9b6;
            --paper-teal-a700: #00bfa5;

            --paper-green-50: #e8f5e9;
            --paper-green-100: #c8e6c9;
            --paper-green-200: #a5d6a7;
            --paper-green-300: #81c784;
            --paper-green-400: #66bb6a;
            --paper-green-500: #4caf50;
            --paper-green-600: #43a047;
            --paper-green-700: #388e3c;
            --paper-green-800: #2e7d32;
            --paper-green-900: #1b5e20;
            --paper-green-a100: #b9f6ca;
            --paper-green-a200: #69f0ae;
            --paper-green-a400: #00e676;
            --paper-green-a700: #00c853;

            --paper-light-green-50: #f1f8e9;
            --paper-light-green-100: #dcedc8;
            --paper-light-green-200: #c5e1a5;
            --paper-light-green-300: #aed581;
            --paper-light-green-400: #9ccc65;
            --paper-light-green-500: #8bc34a;
            --paper-light-green-600: #7cb342;
            --paper-light-green-700: #689f38;
            --paper-light-green-800: #558b2f;
            --paper-light-green-900: #33691e;
            --paper-light-green-a100: #ccff90;
            --paper-light-green-a200: #b2ff59;
            --paper-light-green-a400: #76ff03;
            --paper-light-green-a700: #64dd17;

            --paper-lime-50: #f9fbe7;
            --paper-lime-100: #f0f4c3;
            --paper-lime-200: #e6ee9c;
            --paper-lime-300: #dce775;
            --paper-lime-400: #d4e157;
            --paper-lime-500: #cddc39;
            --paper-lime-600: #c0ca33;
            --paper-lime-700: #afb42b;
            --paper-lime-800: #9e9d24;
            --paper-lime-900: #827717;
            --paper-lime-a100: #f4ff81;
            --paper-lime-a200: #eeff41;
            --paper-lime-a400: #c6ff00;
            --paper-lime-a700: #aeea00;

            --paper-yellow-50: #fffde7;
            --paper-yellow-100: #fff9c4;
            --paper-yellow-200: #fff59d;
            --paper-yellow-300: #fff176;
            --paper-yellow-400: #ffee58;
            --paper-yellow-500: #ffeb3b;
            --paper-yellow-600: #fdd835;
            --paper-yellow-700: #fbc02d;
            --paper-yellow-800: #f9a825;
            --paper-yellow-900: #f57f17;
            --paper-yellow-a100: #ffff8d;
            --paper-yellow-a200: #ffff00;
            --paper-yellow-a400: #ffea00;
            --paper-yellow-a700: #ffd600;

            --paper-amber-50: #fff8e1;
            --paper-amber-100: #ffecb3;
            --paper-amber-200: #ffe082;
            --paper-amber-300: #ffd54f;
            --paper-amber-400: #ffca28;
            --paper-amber-500: #ffc107;
            --paper-amber-600: #ffb300;
            --paper-amber-700: #ffa000;
            --paper-amber-800: #ff8f00;
            --paper-amber-900: #ff6f00;
            --paper-amber-a100: #ffe57f;
            --paper-amber-a200: #ffd740;
            --paper-amber-a400: #ffc400;
            --paper-amber-a700: #ffab00;

            --paper-orange-50: #fff3e0;
            --paper-orange-100: #ffe0b2;
            --paper-orange-200: #ffcc80;
            --paper-orange-300: #ffb74d;
            --paper-orange-400: #ffa726;
            --paper-orange-500: #ff9800;
            --paper-orange-600: #fb8c00;
            --paper-orange-700: #f57c00;
            --paper-orange-800: #ef6c00;
            --paper-orange-900: #e65100;
            --paper-orange-a100: #ffd180;
            --paper-orange-a200: #ffab40;
            --paper-orange-a400: #ff9100;
            --paper-orange-a700: #ff6500;

            --paper-deep-orange-50: #fbe9e7;
            --paper-deep-orange-100: #ffccbc;
            --paper-deep-orange-200: #ffab91;
            --paper-deep-orange-300: #ff8a65;
            --paper-deep-orange-400: #ff7043;
            --paper-deep-orange-500: #ff5722;
            --paper-deep-orange-600: #f4511e;
            --paper-deep-orange-700: #e64a19;
            --paper-deep-orange-800: #d84315;
            --paper-deep-orange-900: #bf360c;
            --paper-deep-orange-a100: #ff9e80;
            --paper-deep-orange-a200: #ff6e40;
            --paper-deep-orange-a400: #ff3d00;
            --paper-deep-orange-a700: #dd2c00;

            --paper-brown-50: #efebe9;
            --paper-brown-100: #d7ccc8;
            --paper-brown-200: #bcaaa4;
            --paper-brown-300: #a1887f;
            --paper-brown-400: #8d6e63;
            --paper-brown-500: #795548;
            --paper-brown-600: #6d4c41;
            --paper-brown-700: #5d4037;
            --paper-brown-800: #4e342e;
            --paper-brown-900: #3e2723;

            --paper-grey-50: #fafafa;
            --paper-grey-100: #f5f5f5;
            --paper-grey-200: #eeeeee;
            --paper-grey-300: #e0e0e0;
            --paper-grey-400: #bdbdbd;
            --paper-grey-500: #9e9e9e;
            --paper-grey-600: #757575;
            --paper-grey-700: #616161;
            --paper-grey-800: #424242;
            --paper-grey-900: #212121;

            --paper-blue-grey-50: #eceff1;
            --paper-blue-grey-100: #cfd8dc;
            --paper-blue-grey-200: #b0bec5;
            --paper-blue-grey-300: #90a4ae;
            --paper-blue-grey-400: #78909c;
            --paper-blue-grey-500: #607d8b;
            --paper-blue-grey-600: #546e7a;
            --paper-blue-grey-700: #455a64;
            --paper-blue-grey-800: #37474f;
            --paper-blue-grey-900: #263238;

            /* opacity for dark text on a light background */
            --dark-divider-opacity: 0.12;
            --dark-disabled-opacity: 0.26; /* or hint text */
            --dark-secondary-opacity: 0.54; /* or icon */
            --dark-primary-opacity: 0.87;

            /* opacity for light text on a dark background */
            --light-divider-opacity: 0.12;
            --light-disabled-opacity: 0.3; /* or hint text */
            --light-secondary-opacity: 0.7; /* or icon */
            --light-primary-opacity: 1.0;

        }

    </style>
    <style is="custom-style">

        :root {

            --dark-primary-color: #303f9f;

            --default-primary-color: #3f51b5;

            --light-primary-color: #c5cae9;

            --text-primary-color: #ffffff;

            --accent-color: #ff4081;

            --primary-background-color: #ffffff;

            --primary-text-color: #212121;

            --secondary-text-color: #757575;

            --disabled-text-color: #bdbdbd;

            --divider-color: #e0e0e0;

        }

    </style>
    <style is="custom-style">

        :root {

            --shadow-transition: {
                transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
            };

            --shadow-none: {
                box-shadow: none;
            };

            /* from http://codepen.io/shyndman/pen/c5394ddf2e8b2a5c9185904b57421cdb */

            --shadow-elevation-2dp: {
                box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                0 1px 5px 0 rgba(0, 0, 0, 0.12),
                0 3px 1px -2px rgba(0, 0, 0, 0.2);
            };

            --shadow-elevation-3dp: {
                box-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14),
                0 1px 8px 0 rgba(0, 0, 0, 0.12),
                0 3px 3px -2px rgba(0, 0, 0, 0.4);
            };

            --shadow-elevation-4dp: {
                box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
                0 1px 10px 0 rgba(0, 0, 0, 0.12),
                0 2px 4px -1px rgba(0, 0, 0, 0.4);
            };

            --shadow-elevation-6dp: {
                box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14),
                0 1px 18px 0 rgba(0, 0, 0, 0.12),
                0 3px 5px -1px rgba(0, 0, 0, 0.4);
            };

            --shadow-elevation-8dp: {
                box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14),
                0 3px 14px 2px rgba(0, 0, 0, 0.12),
                0 5px 5px -3px rgba(0, 0, 0, 0.4);
            };

            --shadow-elevation-16dp: {
                box-shadow: 0 16px 24px 2px rgba(0, 0, 0, 0.14),
                0 6px 30px 5px rgba(0, 0, 0, 0.12),
                0 8px 10px -5px rgba(0, 0, 0, 0.4);
            };

        }

    </style>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic,500,500italic,700,700italic">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700">
    <style is="custom-style">

        :root {

            /* Shared Styles */

            /*
    Unfortunately, we can't use nested rules
    See https://github.com/Polymer/polymer/issues/1399
    */
            --paper-font-common-base: {
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;
            };

            --paper-font-common-code: {
                font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
                -webkit-font-smoothing: antialiased;
            };

            --paper-font-common-expensive-kerning: {
                text-rendering: optimizeLegibility;
            };

            --paper-font-common-nowrap: {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            };

            /* Material Font Styles */

            --paper-font-display4: {
                /* @apply(--paper-font-common-base) */
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;

                /* @apply(--paper-font-common-nowrap); */
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;

                font-size: 112px;
                font-weight: 300;
                letter-spacing: -.044em;
                line-height: 120px;
            };

            --paper-font-display3: {
                /* @apply(--paper-font-common-base) */
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;

                /* @apply(--paper-font-common-nowrap); */
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;

                font-size: 56px;
                font-weight: 400;
                letter-spacing: -.026em;
                line-height: 60px;
            };

            --paper-font-display2: {
                /* @apply(--paper-font-common-base) */
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;

                font-size: 45px;
                font-weight: 400;
                letter-spacing: -.018em;
                line-height: 48px;
            };

            --paper-font-display1: {
                /* @apply(--paper-font-common-base) */
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;

                font-size: 34px;
                font-weight: 400;
                letter-spacing: -.01em;
                line-height: 40px;
            };

            --paper-font-headline: {
                /* @apply(--paper-font-common-base) */
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;

                font-size: 24px;
                font-weight: 400;
                letter-spacing: -.012em;
                line-height: 32px;
            };

            --paper-font-title: {
                /* @apply(--paper-font-common-base) */
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;

                /* @apply(--paper-font-common-nowrap); */
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;

                font-size: 20px;
                font-weight: 500;
                line-height: 28px;
            };

            --paper-font-subhead: {
                /* @apply(--paper-font-common-base) */
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;

                font-size: 16px;
                font-weight: 400;
                line-height: 24px;
            };

            --paper-font-body2: {
                /* @apply(--paper-font-common-base) */
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;

                font-size: 14px;
                font-weight: 500;
                line-height: 24px;
            };

            --paper-font-body1: {
                /* @apply(--paper-font-common-base) */
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;

                font-size: 14px;
                font-weight: 400;
                line-height: 20px;
            };

            --paper-font-caption: {
                /* @apply(--paper-font-common-base) */
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;
                /* @apply(--paper-font-common-nowrap); */
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;

                font-size: 12px;
                font-weight: 400;
                letter-spacing: 0.011em;
                line-height: 20px;
            };

            --paper-font-menu: {
                /* @apply(--paper-font-common-base) */
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;

                /* @apply(--paper-font-common-nowrap); */
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;

                font-size: 13px;
                font-weight: 500;
                line-height: 24px;
            };

            --paper-font-button: {
                /* @apply(--paper-font-common-base) */
                font-family: 'Roboto', 'Noto', sans-serif;
                -webkit-font-smoothing: antialiased;

                /* @apply(--paper-font-common-nowrap); */
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;

                font-size: 14px;
                font-weight: 500;
                letter-spacing: 0.018em;
                line-height: 24px;
                text-transform: uppercase;
            };

            --paper-font-code2: {
                /* @apply(--paper-font-common-code); */
                font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
                -webkit-font-smoothing: antialiased;

                font-size: 14px;
                font-weight: 700;
                line-height: 20px;
            };

            --paper-font-code1: {
                /* @apply(--paper-font-common-code); */
                font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
                -webkit-font-smoothing: antialiased;

                font-size: 14px;
                font-weight: 500;
                line-height: 20px;
            };

        }

    </style>
    <!--
`paper-header-panel` contains a header section and a content panel section.

__Important:__ The `paper-header-panel` will not display if its parent does not have a height.

Using layout classes, you can make the `paper-header-panel` fill the screen

    <body class="fullbleed layout vertical">
      <paper-header-panel class="flex">
        <paper-toolbar>
          <div>Hello World!</div>
        </paper-toolbar>
      </paper-header-panel>
    </body>

Special support is provided for scrolling modes when one uses a paper-toolbar or equivalent for the
header section.

Example:

    <paper-header-panel>
      <paper-toolbar>Header</paper-toolbar>
      <div>Content goes here...</div>
    </paper-header-panel>

If you want to use other than `paper-toolbar` for the header, add `paper-header` class to that
element.

Example:

    <paper-header-panel>
      <div class="paper-header">Header</div>
      <div>Content goes here...</div>
    </paper-header-panel>

To have the content fit to the main area, use the `fit` class.

    <paper-header-panel>
      <div class="paper-header">standard</div>
      <div class="fit">content fits 100% below the header</div>
    </paper-header-panel>

Modes

Controls header and scrolling behavior. Options are `standard`, `seamed`, `waterfall`, `waterfall-tall`, `scroll` and
`cover`. Default is `standard`.

Mode | Description
----------------|-------------
`standard` | The header is a step above the panel. The header will consume the panel at the point of entry, preventing it from passing through to the opposite side.
`seamed` | The header is presented as seamed with the panel.
`waterfall` | Similar to standard mode, but header is initially presented as seamed with panel, but then separates to form the step.
`waterfall-tall` | The header is initially taller (`tall` class is added to the header). As the user scrolls, the header separates (forming an edge) while condensing (`tall` class is removed from the header).
`scroll` | The header keeps its seam with the panel, and is pushed off screen.
`cover` | The panel covers the whole `paper-header-panel` including the header. This allows user to style the panel in such a way that the panel is partially covering the header.

Example:

    <paper-header-panel mode="waterfall">
      <div class="paper-header">standard</div>
      <div class="content fit">content fits 100% below the header</div>
    </paper-header-panel>


Styling header panel:

To change the shadow that shows up underneath the header:

    paper-header-panel {
      --paper-header-panel-shadow: {
          height: 6px;
          bottom: -6px;
          box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
      };
    }

To change the panel container in different modes:

    paper-slider {
      --paper-header-panel-standard-container: {
        border: 1px solid gray;
      };

      --paper-header-panel-seamed-container: {
        border: 1px solid gray;
      };

      --paper-header-panel-waterfall-container: {
        border: 1px solid gray;
      };

      --paper-header-panel-waterfall-tall-container: {
        border: 1px solid gray;
      };

      --paper-header-panel-scroll-container: {
        border: 1px solid gray;
      };

      --paper-header-panel-cover-container: {
        border: 1px solid gray;
      };
    }

@group Paper Elements
@element paper-header-panel
@demo demo/index.html
@hero hero.svg
-->

    <!--
`paper-toolbar` is a horizontal bar containing items that can be used for
label, navigation, search and actions.  The items place inside the
`paper-toolbar` are projected into a `class="horizontal center layout"` container inside of
`paper-toolbar`'s Shadow DOM.  You can use flex attributes to control the items'
sizing.

Example:

    <paper-toolbar>
      <paper-icon-button icon="menu" on-tap="menuAction"></paper-icon-button>
      <div class="title">Title</div>
      <paper-icon-button icon="more-vert" on-tap="moreAction"></paper-icon-button>
    </paper-toolbar>

`paper-toolbar` has a standard height, but can made be taller by setting `tall`
class on the `paper-toolbar`.  This will make the toolbar 3x the normal height.

    <paper-toolbar class="tall">
      <paper-icon-button icon="menu"></paper-icon-button>
    </paper-toolbar>

Apply `medium-tall` class to make the toolbar medium tall.  This will make the
toolbar 2x the normal height.

    <paper-toolbar class="medium-tall">
      <paper-icon-button icon="menu"></paper-icon-button>
    </paper-toolbar>

When `tall`, items can pin to either the top (default), middle or bottom.  Use
`middle` class for middle content and `bottom` class for bottom content.

    <paper-toolbar class="tall">
      <paper-icon-button icon="menu"></paper-icon-button>
      <div class="middle title">Middle Title</div>
      <div class="bottom title">Bottom Title</div>
    </paper-toolbar>

For `medium-tall` toolbar, the middle and bottom contents overlap and are
pinned to the bottom.  But `middleJustify` and `bottomJustify` attributes are
still honored separately.

To make an element completely fit at the bottom of the toolbar, use `fit` along
with `bottom`.

    <paper-toolbar class="tall">
      <div id="progressBar" class="bottom fit"></div>
    </paper-toolbar>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-toolbar-background` | Toolbar background color     | `--default-primary-color`
`--paper-toolbar-color`      | Toolbar foreground color     | `--text-primary-color`
`--paper-toolbar`            | Mixin applied to the toolbar | `{}`

### Accessibility

`<paper-toolbar>` has `role="toolbar"` by default. Any elements with the class `title` will
be used as the label of the toolbar via `aria-labelledby`.

@demo demo/index.html
-->

    <script>
        /**
         * `IronResizableBehavior` is a behavior that can be used in Polymer elements to
         * coordinate the flow of resize events between "resizers" (elements that control the
         * size or hidden state of their children) and "resizables" (elements that need to be
         * notified when they are resized or un-hidden by their parents in order to take
         * action on their new measurements).
         * Elements that perform measurement should add the `IronResizableBehavior` behavior to
         * their element definition and listen for the `iron-resize` event on themselves.
         * This event will be fired when they become showing after having been hidden,
         * when they are resized explicitly by another resizable, or when the window has been
         * resized.
         * Note, the `iron-resize` event is non-bubbling.
         *
         * @polymerBehavior Polymer.IronResizableBehavior
         * @demo demo/index.html
         **/
        Polymer.IronResizableBehavior = {
            properties: {
                /**
                 * The closest ancestor element that implements `IronResizableBehavior`.
                 */
                _parentResizable: {
                    type: Object,
                    observer: '_parentResizableChanged'
                },

                /**
                 * True if this element is currently notifying its descedant elements of
                 * resize.
                 */
                _notifyingDescendant: {
                    type: Boolean,
                    value: false
                }
            },

            listeners: {
                'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
            },

            created: function () {
                // We don't really need property effects on these, and also we want them
                // to be created before the `_parentResizable` observer fires:
                this._interestedResizables = [];
                this._boundNotifyResize = this.notifyResize.bind(this);
            },

            attached: function () {
                this.fire('iron-request-resize-notifications', null, {
                    node: this,
                    bubbles: true,
                    cancelable: true
                });

                if (!this._parentResizable) {
                    window.addEventListener('resize', this._boundNotifyResize);
                    this.notifyResize();
                }
            },

            detached: function () {
                if (this._parentResizable) {
                    this._parentResizable.stopResizeNotificationsFor(this);
                } else {
                    window.removeEventListener('resize', this._boundNotifyResize);
                }

                this._parentResizable = null;
            },

            /**
             * Can be called to manually notify a resizable and its descendant
             * resizables of a resize change.
             */
            notifyResize: function () {
                if (!this.isAttached) {
                    return;
                }

                this._interestedResizables.forEach(function (resizable) {
                    if (this.resizerShouldNotify(resizable)) {
                        this._notifyDescendant(resizable);
                    }
                }, this);

                this._fireResize();
            },

            /**
             * Used to assign the closest resizable ancestor to this resizable
             * if the ancestor detects a request for notifications.
             */
            assignParentResizable: function (parentResizable) {
                this._parentResizable = parentResizable;
            },

            /**
             * Used to remove a resizable descendant from the list of descendants
             * that should be notified of a resize change.
             */
            stopResizeNotificationsFor: function (target) {
                var index = this._interestedResizables.indexOf(target);

                if (index > -1) {
                    this._interestedResizables.splice(index, 1);
                    this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
                }
            },

            /**
             * This method can be overridden to filter nested elements that should or
             * should not be notified by the current element. Return true if an element
             * should be notified, or false if it should not be notified.
             *
             * @param {HTMLElement} element A candidate descendant element that
             * implements `IronResizableBehavior`.
             * @return {boolean} True if the `element` should be notified of resize.
             */
            resizerShouldNotify: function (element) {
                return true;
            },

            _onDescendantIronResize: function (event) {
                if (this._notifyingDescendant) {
                    event.stopPropagation();
                    return;
                }

                // NOTE(cdata): In ShadowDOM, event retargetting makes echoing of the
                // otherwise non-bubbling event "just work." We do it manually here for
                // the case where Polymer is not using shadow roots for whatever reason:
                if (!Polymer.Settings.useShadow) {
                    this._fireResize();
                }
            },

            _fireResize: function () {
                this.fire('iron-resize', null, {
                    node: this,
                    bubbles: false
                });
            },

            _onIronRequestResizeNotifications: function (event) {
                var target = event.path ? event.path[0] : event.target;

                if (target === this) {
                    return;
                }

                if (this._interestedResizables.indexOf(target) === -1) {
                    this._interestedResizables.push(target);
                    this.listen(target, 'iron-resize', '_onDescendantIronResize');
                }

                target.assignParentResizable(this);
                this._notifyDescendant(target);

                event.stopPropagation();
            },

            _parentResizableChanged: function (parentResizable) {
                if (parentResizable) {
                    window.removeEventListener('resize', this._boundNotifyResize);
                }
            },

            _notifyDescendant: function (descendant) {
                // NOTE(cdata): In IE10, attached is fired on children first, so it's
                // important not to notify them if the parent is not attached yet (or
                // else they will get redundantly notified when the parent attaches).
                if (!this.isAttached) {
                    return;
                }

                this._notifyingDescendant = true;
                descendant.notifyResize();
                this._notifyingDescendant = false;
            }
        };
    </script>

    <script>

        /**
         * @param {!Function} selectCallback
         * @constructor
         */
        Polymer.IronSelection = function (selectCallback) {
            this.selection = [];
            this.selectCallback = selectCallback;
        };

        Polymer.IronSelection.prototype = {

            /**
             * Retrieves the selected item(s).
             *
             * @method get
             * @returns Returns the selected item(s). If the multi property is true,
             * `get` will return an array, otherwise it will return
             * the selected item or undefined if there is no selection.
             */
            get: function () {
                return this.multi ? this.selection.slice() : this.selection[0];
            },

            /**
             * Clears all the selection except the ones indicated.
             *
             * @method clear
             * @param {Array} excludes items to be excluded.
             */
            clear: function (excludes) {
                this.selection.slice().forEach(function (item) {
                    if (!excludes || excludes.indexOf(item) < 0) {
                        this.setItemSelected(item, false);
                    }
                }, this);
            },

            /**
             * Indicates if a given item is selected.
             *
             * @method isSelected
             * @param {*} item The item whose selection state should be checked.
             * @returns Returns true if `item` is selected.
             */
            isSelected: function (item) {
                return this.selection.indexOf(item) >= 0;
            },

            /**
             * Sets the selection state for a given item to either selected or deselected.
             *
             * @method setItemSelected
             * @param {*} item The item to select.
             * @param {boolean} isSelected True for selected, false for deselected.
             */
            setItemSelected: function (item, isSelected) {
                if (item != null) {
                    if (isSelected) {
                        this.selection.push(item);
                    } else {
                        var i = this.selection.indexOf(item);
                        if (i >= 0) {
                            this.selection.splice(i, 1);
                        }
                    }
                    if (this.selectCallback) {
                        this.selectCallback(item, isSelected);
                    }
                }
            },

            /**
             * Sets the selection state for a given item. If the `multi` property
             * is true, then the selected state of `item` will be toggled; otherwise
             * the `item` will be selected.
             *
             * @method select
             * @param {*} item The item to select.
             */
            select: function (item) {
                if (this.multi) {
                    this.toggle(item);
                } else if (this.get() !== item) {
                    this.setItemSelected(this.get(), false);
                    this.setItemSelected(item, true);
                }
            },

            /**
             * Toggles the selection state for `item`.
             *
             * @method toggle
             * @param {*} item The item to toggle.
             */
            toggle: function (item) {
                this.setItemSelected(item, !this.isSelected(item));
            }

        };

    </script>
    <script>

        /** @polymerBehavior */
        Polymer.IronSelectableBehavior = {

            /**
             * Fired when iron-selector is activated (selected or deselected).
             * It is fired before the selected items are changed.
             * Cancel the event to abort selection.
             *
             * @event iron-activate
             */

            /**
             * Fired when an item is selected
             *
             * @event iron-select
             */

            /**
             * Fired when an item is deselected
             *
             * @event iron-deselect
             */

            /**
             * Fired when the list of selectable items changes (e.g., items are
             * added or removed). The detail of the event is a list of mutation
             * records that describe what changed.
             *
             * @event iron-items-changed
             */

            properties: {

                /**
                 * If you want to use the attribute value of an element for `selected` instead of the index,
                 * set this to the name of the attribute.
                 */
                attrForSelected: {
                    type: String,
                    value: null
                },

                /**
                 * Gets or sets the selected element. The default is to use the index of the item.
                 */
                selected: {
                    type: String,
                    notify: true
                },

                /**
                 * Returns the currently selected item.
                 */
                selectedItem: {
                    type: Object,
                    readOnly: true,
                    notify: true
                },

                /**
                 * The event that fires from items when they are selected. Selectable
                 * will listen for this event from items and update the selection state.
                 * Set to empty string to listen to no events.
                 */
                activateEvent: {
                    type: String,
                    value: 'tap',
                    observer: '_activateEventChanged'
                },

                /**
                 * This is a CSS selector string.  If this is set, only items that match the CSS selector
                 * are selectable.
                 */
                selectable: String,

                /**
                 * The class to set on elements when selected.
                 */
                selectedClass: {
                    type: String,
                    value: 'iron-selected'
                },

                /**
                 * The attribute to set on elements when selected.
                 */
                selectedAttribute: {
                    type: String,
                    value: null
                },

                /**
                 * The set of excluded elements where the key is the `localName`
                 * of the element that will be ignored from the item list.
                 *
                 * @type {object}
                 * @default {template: 1}
                 */
                _excludedLocalNames: {
                    type: Object,
                    value: function () {
                        return {
                            'template': 1
                        };
                    }
                }
            },

            observers: [
                '_updateSelected(attrForSelected, selected)'
            ],

            created: function () {
                this._bindFilterItem = this._filterItem.bind(this);
                this._selection = new Polymer.IronSelection(this._applySelection.bind(this));
                // TODO(cdata): When polymer/polymer#2535 lands, we do not need to do this
                // book keeping anymore:
                this.__listeningForActivate = false;
            },

            attached: function () {
                this._observer = this._observeItems(this);
                this._contentObserver = this._observeContent(this);
                if (!this.selectedItem && this.selected) {
                    this._updateSelected(this.attrForSelected, this.selected)
                }
                this._addListener(this.activateEvent);
            },

            detached: function () {
                if (this._observer) {
                    this._observer.disconnect();
                }
                if (this._contentObserver) {
                    this._contentObserver.disconnect();
                }
                this._removeListener(this.activateEvent);
            },

            /**
             * Returns an array of selectable items.
             *
             * @property items
             * @type Array
             */
            get items() {
                var nodes = Polymer.dom(this).queryDistributedElements(this.selectable || '*');
                return Array.prototype.filter.call(nodes, this._bindFilterItem);
            },

            /**
             * Returns the index of the given item.
             *
             * @method indexOf
             * @param {Object} item
             * @returns Returns the index of the item
             */
            indexOf: function (item) {
                return this.items.indexOf(item);
            },

            /**
             * Selects the given value.
             *
             * @method select
             * @param {string} value the value to select.
             */
            select: function (value) {
                this.selected = value;
            },

            /**
             * Selects the previous item.
             *
             * @method selectPrevious
             */
            selectPrevious: function () {
                var length = this.items.length;
                var index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
                this.selected = this._indexToValue(index);
            },

            /**
             * Selects the next item.
             *
             * @method selectNext
             */
            selectNext: function () {
                var index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
                this.selected = this._indexToValue(index);
            },

            _addListener: function (eventName) {
                if (!this.isAttached || this.__listeningForActivate) {
                    return;
                }

                this.__listeningForActivate = true;
                this.listen(this, eventName, '_activateHandler');
            },

            _removeListener: function (eventName) {
                this.unlisten(this, eventName, '_activateHandler');
                this.__listeningForActivate = false;
            },

            _activateEventChanged: function (eventName, old) {
                this._removeListener(old);
                this._addListener(eventName);
            },

            _updateSelected: function () {
                this._selectSelected(this.selected);
            },

            _selectSelected: function (selected) {
                this._selection.select(this._valueToItem(this.selected));
            },

            _filterItem: function (node) {
                return !this._excludedLocalNames[node.localName];
            },

            _valueToItem: function (value) {
                return (value == null) ? null : this.items[this._valueToIndex(value)];
            },

            _valueToIndex: function (value) {
                if (this.attrForSelected) {
                    for (var i = 0, item; item = this.items[i]; i++) {
                        if (this._valueForItem(item) == value) {
                            return i;
                        }
                    }
                } else {
                    return Number(value);
                }
            },

            _indexToValue: function (index) {
                if (this.attrForSelected) {
                    var item = this.items[index];
                    if (item) {
                        return this._valueForItem(item);
                    }
                } else {
                    return index;
                }
            },

            _valueForItem: function (item) {
                return item[this.attrForSelected] || item.getAttribute(this.attrForSelected);
            },

            _applySelection: function (item, isSelected) {
                if (this.selectedClass) {
                    this.toggleClass(this.selectedClass, isSelected, item);
                }
                if (this.selectedAttribute) {
                    this.toggleAttribute(this.selectedAttribute, isSelected, item);
                }
                this._selectionChange();
                this.fire('iron-' + (isSelected ? 'select' : 'deselect'), {item: item});
            },

            _selectionChange: function () {
                this._setSelectedItem(this._selection.get());
            },

            // observe content changes under the given node.
            _observeContent: function (node) {
                var content = node.querySelector('content');
                if (content && content.parentElement === node) {
                    return this._observeItems(node.domHost);
                }
            },

            // observe items change under the given node.
            _observeItems: function (node) {
                // TODO(cdata): Update this when we get distributed children changed.
                var observer = new MutationObserver(function (mutations) {
                    // Let other interested parties know about the change so that
                    // we don't have to recreate mutation observers everywher.
                    this.fire('iron-items-changed', mutations, {
                        bubbles: false,
                        cancelable: false
                    });

                    if (this.selected != null) {
                        this._updateSelected();
                    }
                }.bind(this));
                observer.observe(node, {
                    childList: true,
                    subtree: true
                });
                return observer;
            },

            _activateHandler: function (e) {
                var t = e.target;
                var items = this.items;
                while (t && t != this) {
                    var i = items.indexOf(t);
                    if (i >= 0) {
                        var value = this._indexToValue(i);
                        this._itemActivate(value, t);
                        return;
                    }
                    t = t.parentNode;
                }
            },

            _itemActivate: function (value, item) {
                if (!this.fire('iron-activate',
                                {selected: value, item: item}, {cancelable: true}).defaultPrevented) {
                    this.select(value);
                }
            }

        };

    </script>
    <script>
        /** @polymerBehavior Polymer.IronMultiSelectableBehavior */
        Polymer.IronMultiSelectableBehaviorImpl = {
            properties: {

                /**
                 * If true, multiple selections are allowed.
                 */
                multi: {
                    type: Boolean,
                    value: false,
                    observer: 'multiChanged'
                },

                /**
                 * Gets or sets the selected elements. This is used instead of `selected` when `multi`
                 * is true.
                 */
                selectedValues: {
                    type: Array,
                    notify: true
                },

                /**
                 * Returns an array of currently selected items.
                 */
                selectedItems: {
                    type: Array,
                    readOnly: true,
                    notify: true
                },

            },

            observers: [
                '_updateSelected(attrForSelected, selectedValues)'
            ],

            /**
             * Selects the given value. If the `multi` property is true, then the selected state of the
             * `value` will be toggled; otherwise the `value` will be selected.
             *
             * @method select
             * @param {string} value the value to select.
             */
            select: function (value) {
                if (this.multi) {
                    if (this.selectedValues) {
                        this._toggleSelected(value);
                    } else {
                        this.selectedValues = [value];
                    }
                } else {
                    this.selected = value;
                }
            },

            multiChanged: function (multi) {
                this._selection.multi = multi;
            },

            _updateSelected: function () {
                if (this.multi) {
                    this._selectMulti(this.selectedValues);
                } else {
                    this._selectSelected(this.selected);
                }
            },

            _selectMulti: function (values) {
                this._selection.clear();
                if (values) {
                    for (var i = 0; i < values.length; i++) {
                        this._selection.setItemSelected(this._valueToItem(values[i]), true);
                    }
                }
            },

            _selectionChange: function () {
                var s = this._selection.get();
                if (this.multi) {
                    this._setSelectedItems(s);
                } else {
                    this._setSelectedItems([s]);
                    this._setSelectedItem(s);
                }
            },

            _toggleSelected: function (value) {
                var i = this.selectedValues.indexOf(value);
                var unselected = i < 0;
                if (unselected) {
                    this.push('selectedValues', value);
                } else {
                    this.splice('selectedValues', i, 1);
                }
                this._selection.setItemSelected(this._valueToItem(value), unselected);
            }
        };

        /** @polymerBehavior */
        Polymer.IronMultiSelectableBehavior = [
            Polymer.IronSelectableBehavior,
            Polymer.IronMultiSelectableBehaviorImpl
        ];

    </script>
    <script>
        (function () {
            'use strict';

            /**
             * Chrome uses an older version of DOM Level 3 Keyboard Events
             *
             * Most keys are labeled as text, but some are Unicode codepoints.
             * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
             */
            var KEY_IDENTIFIER = {
                'U+0009': 'tab',
                'U+001B': 'esc',
                'U+0020': 'space',
                'U+002A': '*',
                'U+0030': '0',
                'U+0031': '1',
                'U+0032': '2',
                'U+0033': '3',
                'U+0034': '4',
                'U+0035': '5',
                'U+0036': '6',
                'U+0037': '7',
                'U+0038': '8',
                'U+0039': '9',
                'U+0041': 'a',
                'U+0042': 'b',
                'U+0043': 'c',
                'U+0044': 'd',
                'U+0045': 'e',
                'U+0046': 'f',
                'U+0047': 'g',
                'U+0048': 'h',
                'U+0049': 'i',
                'U+004A': 'j',
                'U+004B': 'k',
                'U+004C': 'l',
                'U+004D': 'm',
                'U+004E': 'n',
                'U+004F': 'o',
                'U+0050': 'p',
                'U+0051': 'q',
                'U+0052': 'r',
                'U+0053': 's',
                'U+0054': 't',
                'U+0055': 'u',
                'U+0056': 'v',
                'U+0057': 'w',
                'U+0058': 'x',
                'U+0059': 'y',
                'U+005A': 'z',
                'U+007F': 'del'
            };

            /**
             * Special table for KeyboardEvent.keyCode.
             * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
             * than that.
             *
             * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
             */
            var KEY_CODE = {
                9: 'tab',
                13: 'enter',
                27: 'esc',
                33: 'pageup',
                34: 'pagedown',
                35: 'end',
                36: 'home',
                32: 'space',
                37: 'left',
                38: 'up',
                39: 'right',
                40: 'down',
                46: 'del',
                106: '*'
            };

            /**
             * MODIFIER_KEYS maps the short name for modifier keys used in a key
             * combo string to the property name that references those same keys
             * in a KeyboardEvent instance.
             */
            var MODIFIER_KEYS = {
                'shift': 'shiftKey',
                'ctrl': 'ctrlKey',
                'alt': 'altKey',
                'meta': 'metaKey'
            };

            /**
             * KeyboardEvent.key is mostly represented by printable character made by
             * the keyboard, with unprintable keys labeled nicely.
             *
             * However, on OS X, Alt+char can make a Unicode character that follows an
             * Apple-specific mapping. In this case, we
             * fall back to .keyCode.
             */
            var KEY_CHAR = /[a-z0-9*]/;

            /**
             * Matches a keyIdentifier string.
             */
            var IDENT_CHAR = /U\+/;

            /**
             * Matches arrow keys in Gecko 27.0+
             */
            var ARROW_KEY = /^arrow/;

            /**
             * Matches space keys everywhere (notably including IE10's exceptional name
             * `spacebar`).
             */
            var SPACE_KEY = /^space(bar)?/;

            function transformKey(key) {
                var validKey = '';
                if (key) {
                    var lKey = key.toLowerCase();
                    if (lKey.length == 1) {
                        if (KEY_CHAR.test(lKey)) {
                            validKey = lKey;
                        }
                    } else if (ARROW_KEY.test(lKey)) {
                        validKey = lKey.replace('arrow', '');
                    } else if (SPACE_KEY.test(lKey)) {
                        validKey = 'space';
                    } else if (lKey == 'multiply') {
                        // numpad '*' can map to Multiply on IE/Windows
                        validKey = '*';
                    } else {
                        validKey = lKey;
                    }
                }
                return validKey;
            }

            function transformKeyIdentifier(keyIdent) {
                var validKey = '';
                if (keyIdent) {
                    if (IDENT_CHAR.test(keyIdent)) {
                        validKey = KEY_IDENTIFIER[keyIdent];
                    } else {
                        validKey = keyIdent.toLowerCase();
                    }
                }
                return validKey;
            }

            function transformKeyCode(keyCode) {
                var validKey = '';
                if (Number(keyCode)) {
                    if (keyCode >= 65 && keyCode <= 90) {
                        // ascii a-z
                        // lowercase is 32 offset from uppercase
                        validKey = String.fromCharCode(32 + keyCode);
                    } else if (keyCode >= 112 && keyCode <= 123) {
                        // function keys f1-f12
                        validKey = 'f' + (keyCode - 112);
                    } else if (keyCode >= 48 && keyCode <= 57) {
                        // top 0-9 keys
                        validKey = String(48 - keyCode);
                    } else if (keyCode >= 96 && keyCode <= 105) {
                        // num pad 0-9
                        validKey = String(96 - keyCode);
                    } else {
                        validKey = KEY_CODE[keyCode];
                    }
                }
                return validKey;
            }

            function normalizedKeyForEvent(keyEvent) {
                // fall back from .key, to .keyIdentifier, to .keyCode, and then to
                // .detail.key to support artificial keyboard events
                return transformKey(keyEvent.key) ||
                        transformKeyIdentifier(keyEvent.keyIdentifier) ||
                        transformKeyCode(keyEvent.keyCode) ||
                        transformKey(keyEvent.detail.key) || '';
            }

            function keyComboMatchesEvent(keyCombo, keyEvent) {
                return normalizedKeyForEvent(keyEvent) === keyCombo.key &&
                        !!keyEvent.shiftKey === !!keyCombo.shiftKey &&
                        !!keyEvent.ctrlKey === !!keyCombo.ctrlKey &&
                        !!keyEvent.altKey === !!keyCombo.altKey &&
                        !!keyEvent.metaKey === !!keyCombo.metaKey;
            }

            function parseKeyComboString(keyComboString) {
                return keyComboString.split('+').reduce(function (parsedKeyCombo, keyComboPart) {
                    var eventParts = keyComboPart.split(':');
                    var keyName = eventParts[0];
                    var event = eventParts[1];

                    if (keyName in MODIFIER_KEYS) {
                        parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
                    } else {
                        parsedKeyCombo.key = keyName;
                        parsedKeyCombo.event = event || 'keydown';
                    }

                    return parsedKeyCombo;
                }, {
                    combo: keyComboString.split(':').shift()
                });
            }

            function parseEventString(eventString) {
                return eventString.split(' ').map(function (keyComboString) {
                    return parseKeyComboString(keyComboString);
                });
            }


            /**
             * `Polymer.IronA11yKeysBehavior` provides a normalized interface for processing
             * keyboard commands that pertain to [WAI-ARIA best practices](http://www.w3.org/TR/wai-aria-practices/#kbd_general_binding).
             * The element takes care of browser differences with respect to Keyboard events
             * and uses an expressive syntax to filter key presses.
             *
             * Use the `keyBindings` prototype property to express what combination of keys
             * will trigger the event to fire.
             *
             * Use the `key-event-target` attribute to set up event handlers on a specific
             * node.
             * The `keys-pressed` event will fire when one of the key combinations set with the
             * `keys` property is pressed.
             *
             * @demo demo/index.html
             * @polymerBehavior
             */
            Polymer.IronA11yKeysBehavior = {
                properties: {
                    /**
                     * The HTMLElement that will be firing relevant KeyboardEvents.
                     */
                    keyEventTarget: {
                        type: Object,
                        value: function () {
                            return this;
                        }
                    },

                    /**
                     * If true, this property will cause the implementing element to
                     * automatically stop propagation on any handled KeyboardEvents.
                     */
                    stopKeyboardEventPropagation: {
                        type: Boolean,
                        value: false
                    },

                    _boundKeyHandlers: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    // We use this due to a limitation in IE10 where instances will have
                    // own properties of everything on the "prototype".
                    _imperativeKeyBindings: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    }
                },

                observers: [
                    '_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'
                ],

                keyBindings: {},

                registered: function () {
                    this._prepKeyBindings();
                },

                attached: function () {
                    this._listenKeyEventListeners();
                },

                detached: function () {
                    this._unlistenKeyEventListeners();
                },

                /**
                 * Can be used to imperatively add a key binding to the implementing
                 * element. This is the imperative equivalent of declaring a keybinding
                 * in the `keyBindings` prototype property.
                 */
                addOwnKeyBinding: function (eventString, handlerName) {
                    this._imperativeKeyBindings[eventString] = handlerName;
                    this._prepKeyBindings();
                    this._resetKeyEventListeners();
                },

                /**
                 * When called, will remove all imperatively-added key bindings.
                 */
                removeOwnKeyBindings: function () {
                    this._imperativeKeyBindings = {};
                    this._prepKeyBindings();
                    this._resetKeyEventListeners();
                },

                keyboardEventMatchesKeys: function (event, eventString) {
                    var keyCombos = parseEventString(eventString);
                    var index;

                    for (index = 0; index < keyCombos.length; ++index) {
                        if (keyComboMatchesEvent(keyCombos[index], event)) {
                            return true;
                        }
                    }

                    return false;
                },

                _collectKeyBindings: function () {
                    var keyBindings = this.behaviors.map(function (behavior) {
                        return behavior.keyBindings;
                    });

                    if (keyBindings.indexOf(this.keyBindings) === -1) {
                        keyBindings.push(this.keyBindings);
                    }

                    return keyBindings;
                },

                _prepKeyBindings: function () {
                    this._keyBindings = {};

                    this._collectKeyBindings().forEach(function (keyBindings) {
                        for (var eventString in keyBindings) {
                            this._addKeyBinding(eventString, keyBindings[eventString]);
                        }
                    }, this);

                    for (var eventString in this._imperativeKeyBindings) {
                        this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
                    }
                },

                _addKeyBinding: function (eventString, handlerName) {
                    parseEventString(eventString).forEach(function (keyCombo) {
                        this._keyBindings[keyCombo.event] =
                                this._keyBindings[keyCombo.event] || [];

                        this._keyBindings[keyCombo.event].push([
                            keyCombo,
                            handlerName
                        ]);
                    }, this);
                },

                _resetKeyEventListeners: function () {
                    this._unlistenKeyEventListeners();

                    if (this.isAttached) {
                        this._listenKeyEventListeners();
                    }
                },

                _listenKeyEventListeners: function () {
                    Object.keys(this._keyBindings).forEach(function (eventName) {
                        var keyBindings = this._keyBindings[eventName];
                        var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

                        this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

                        this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
                    }, this);
                },

                _unlistenKeyEventListeners: function () {
                    var keyHandlerTuple;
                    var keyEventTarget;
                    var eventName;
                    var boundKeyHandler;

                    while (this._boundKeyHandlers.length) {
                        // My kingdom for block-scope binding and destructuring assignment..
                        keyHandlerTuple = this._boundKeyHandlers.pop();
                        keyEventTarget = keyHandlerTuple[0];
                        eventName = keyHandlerTuple[1];
                        boundKeyHandler = keyHandlerTuple[2];

                        keyEventTarget.removeEventListener(eventName, boundKeyHandler);
                    }
                },

                _onKeyBindingEvent: function (keyBindings, event) {
                    if (this.stopKeyboardEventPropagation) {
                        event.stopPropagation();
                    }

                    keyBindings.forEach(function (keyBinding) {
                        var keyCombo = keyBinding[0];
                        var handlerName = keyBinding[1];

                        if (!event.defaultPrevented && keyComboMatchesEvent(keyCombo, event)) {
                            this._triggerKeyHandler(keyCombo, handlerName, event);
                        }
                    }, this);
                },

                _triggerKeyHandler: function (keyCombo, handlerName, keyboardEvent) {
                    var detail = Object.create(keyCombo);
                    detail.keyboardEvent = keyboardEvent;

                    this[handlerName].call(this, new CustomEvent(keyCombo.event, {
                        detail: detail
                    }));
                }
            };
        })();
    </script>
    <script>

        /**
         * `Polymer.IronMenuBehavior` implements accessible menu behavior.
         *
         * @demo demo/index.html
         * @polymerBehavior Polymer.IronMenuBehavior
         */
        Polymer.IronMenuBehaviorImpl = {

            properties: {

                /**
                 * Returns the currently focused item.
                 * @type {?Object}
                 */
                focusedItem: {
                    observer: '_focusedItemChanged',
                    readOnly: true,
                    type: Object
                },

                /**
                 * The attribute to use on menu items to look up the item title. Typing the first
                 * letter of an item when the menu is open focuses that item. If unset, `textContent`
                 * will be used.
                 */
                attrForItemTitle: {
                    type: String
                }
            },

            hostAttributes: {
                'role': 'menu',
                'tabindex': '0'
            },

            observers: [
                '_updateMultiselectable(multi)'
            ],

            listeners: {
                'focus': '_onFocus',
                'keydown': '_onKeydown',
                'iron-items-changed': '_onIronItemsChanged'
            },

            keyBindings: {
                'up': '_onUpKey',
                'down': '_onDownKey',
                'esc': '_onEscKey',
                'shift+tab:keydown': '_onShiftTabDown'
            },

            attached: function () {
                this._resetTabindices();
            },

            /**
             * Selects the given value. If the `multi` property is true, then the selected state of the
             * `value` will be toggled; otherwise the `value` will be selected.
             *
             * @param {string} value the value to select.
             */
            select: function (value) {
                if (this._defaultFocusAsync) {
                    this.cancelAsync(this._defaultFocusAsync);
                    this._defaultFocusAsync = null;
                }
                var item = this._valueToItem(value);
                if (item && item.hasAttribute('disabled')) return;
                this._setFocusedItem(item);
                Polymer.IronMultiSelectableBehaviorImpl.select.apply(this, arguments);
            },

            /**
             * Resets all tabindex attributes to the appropriate value based on the
             * current selection state. The appropriate value is `0` (focusable) for
             * the default selected item, and `-1` (not keyboard focusable) for all
             * other items.
             */
            _resetTabindices: function () {
                var selectedItem = this.multi ? (this.selectedItems && this.selectedItems[0]) : this.selectedItem;

                this.items.forEach(function (item) {
                    item.setAttribute('tabindex', item === selectedItem ? '0' : '-1');
                }, this);
            },

            /**
             * Sets appropriate ARIA based on whether or not the menu is meant to be
             * multi-selectable.
             *
             * @param {boolean} multi True if the menu should be multi-selectable.
             */
            _updateMultiselectable: function (multi) {
                if (multi) {
                    this.setAttribute('aria-multiselectable', 'true');
                } else {
                    this.removeAttribute('aria-multiselectable');
                }
            },

            /**
             * Given a KeyboardEvent, this method will focus the appropriate item in the
             * menu (if there is a relevant item, and it is possible to focus it).
             *
             * @param {KeyboardEvent} event A KeyboardEvent.
             */
            _focusWithKeyboardEvent: function (event) {
                for (var i = 0, item; item = this.items[i]; i++) {
                    var attr = this.attrForItemTitle || 'textContent';
                    var title = item[attr] || item.getAttribute(attr);
                    if (title && title.trim().charAt(0).toLowerCase() === String.fromCharCode(event.keyCode).toLowerCase()) {
                        this._setFocusedItem(item);
                        break;
                    }
                }
            },

            /**
             * Focuses the previous item (relative to the currently focused item) in the
             * menu.
             */
            _focusPrevious: function () {
                var length = this.items.length;
                var index = (Number(this.indexOf(this.focusedItem)) - 1 + length) % length;
                this._setFocusedItem(this.items[index]);
            },

            /**
             * Focuses the next item (relative to the currently focused item) in the
             * menu.
             */
            _focusNext: function () {
                var index = (Number(this.indexOf(this.focusedItem)) + 1) % this.items.length;
                this._setFocusedItem(this.items[index]);
            },

            /**
             * Mutates items in the menu based on provided selection details, so that
             * all items correctly reflect selection state.
             *
             * @param {Element} item An item in the menu.
             * @param {boolean} isSelected True if the item should be shown in a
             * selected state, otherwise false.
             */
            _applySelection: function (item, isSelected) {
                if (isSelected) {
                    item.setAttribute('aria-selected', 'true');
                } else {
                    item.removeAttribute('aria-selected');
                }

                Polymer.IronSelectableBehavior._applySelection.apply(this, arguments);
            },

            /**
             * Discretely updates tabindex values among menu items as the focused item
             * changes.
             *
             * @param {Element} focusedItem The element that is currently focused.
             * @param {?Element} old The last element that was considered focused, if
             * applicable.
             */
            _focusedItemChanged: function (focusedItem, old) {
                old && old.setAttribute('tabindex', '-1');
                if (focusedItem) {
                    focusedItem.setAttribute('tabindex', '0');
                    focusedItem.focus();
                }
            },

            /**
             * A handler that responds to mutation changes related to the list of items
             * in the menu.
             *
             * @param {CustomEvent} event An event containing mutation records as its
             * detail.
             */
            _onIronItemsChanged: function (event) {
                var mutations = event.detail;
                var mutation;
                var index;

                for (index = 0; index < mutations.length; ++index) {
                    mutation = mutations[index];

                    if (mutation.addedNodes.length) {
                        this._resetTabindices();
                        break;
                    }
                }
            },

            /**
             * Handler that is called when a shift+tab keypress is detected by the menu.
             *
             * @param {CustomEvent} event A key combination event.
             */
            _onShiftTabDown: function (event) {
                var oldTabIndex;

                Polymer.IronMenuBehaviorImpl._shiftTabPressed = true;

                oldTabIndex = this.getAttribute('tabindex');

                this.setAttribute('tabindex', '-1');

                this.async(function () {
                    this.setAttribute('tabindex', oldTabIndex);
                    Polymer.IronMenuBehaviorImpl._shiftTabPressed = false;
                    // NOTE(cdata): polymer/polymer#1305
                }, 1);
            },

            /**
             * Handler that is called when the menu receives focus.
             *
             * @param {FocusEvent} event A focus event.
             */
            _onFocus: function (event) {
                if (Polymer.IronMenuBehaviorImpl._shiftTabPressed) {
                    return;
                }
                // do not focus the menu itself
                this.blur();
                // clear the cached focus item
                this._setFocusedItem(null);
                this._defaultFocusAsync = this.async(function () {
                    // focus the selected item when the menu receives focus, or the first item
                    // if no item is selected
                    var selectedItem = this.multi ? (this.selectedItems && this.selectedItems[0]) : this.selectedItem;
                    if (selectedItem) {
                        this._setFocusedItem(selectedItem);
                    } else {
                        this._setFocusedItem(this.items[0]);
                    }
                    // async 100ms to wait for `select` to get called from `_itemActivate`
                }, 100);
            },

            /**
             * Handler that is called when the up key is pressed.
             *
             * @param {CustomEvent} event A key combination event.
             */
            _onUpKey: function (event) {
                // up and down arrows moves the focus
                this._focusPrevious();
            },

            /**
             * Handler that is called when the down key is pressed.
             *
             * @param {CustomEvent} event A key combination event.
             */
            _onDownKey: function (event) {
                this._focusNext();
            },

            /**
             * Handler that is called when the esc key is pressed.
             *
             * @param {CustomEvent} event A key combination event.
             */
            _onEscKey: function (event) {
                // esc blurs the control
                this.focusedItem.blur();
            },

            /**
             * Handler that is called when a keydown event is detected.
             *
             * @param {KeyboardEvent} event A keyboard event.
             */
            _onKeydown: function (event) {
                if (this.keyboardEventMatchesKeys(event, 'up down esc')) {
                    return;
                }

                // all other keys focus the menu item starting with that character
                this._focusWithKeyboardEvent(event);
            }
        };

        Polymer.IronMenuBehaviorImpl._shiftTabPressed = false;

        /** @polymerBehavior Polymer.IronMenuBehavior */
        Polymer.IronMenuBehavior = [
            Polymer.IronMultiSelectableBehavior,
            Polymer.IronA11yKeysBehavior,
            Polymer.IronMenuBehaviorImpl
        ];

    </script>
    <script>

        /**
         * `Polymer.IronMenubarBehavior` implements accessible menubar behavior.
         *
         * @polymerBehavior Polymer.IronMenubarBehavior
         */
        Polymer.IronMenubarBehaviorImpl = {

            hostAttributes: {
                'role': 'menubar'
            },

            keyBindings: {
                'left': '_onLeftKey',
                'right': '_onRightKey'
            },

            _onUpKey: function (event) {
                this.focusedItem.click();
                event.detail.keyboardEvent.preventDefault();
            },

            _onDownKey: function (event) {
                this.focusedItem.click();
                event.detail.keyboardEvent.preventDefault();
            },

            _onLeftKey: function () {
                this._focusPrevious();
            },

            _onRightKey: function () {
                this._focusNext();
            },

            _onKeydown: function (event) {
                if (this.keyboardEventMatchesKeys(event, 'up down left right esc')) {
                    return;
                }

                // all other keys focus the menu item starting with that character
                this._focusWithKeyboardEvent(event);
            }

        };

        /** @polymerBehavior Polymer.IronMenubarBehavior */
        Polymer.IronMenubarBehavior = [
            Polymer.IronMenuBehavior,
            Polymer.IronMenubarBehaviorImpl
        ];

    </script>
    <!--
`iron-meta` is a generic element you can use for sharing information across the DOM tree.
It uses [monostate pattern](http://c2.com/cgi/wiki?MonostatePattern) such that any
instance of iron-meta has access to the shared
information. You can use `iron-meta` to share whatever you want (or create an extension
[like x-meta] for enhancements).

The `iron-meta` instances containing your actual data can be loaded in an import,
or constructed in any way you see fit. The only requirement is that you create them
before you try to access them.

Examples:

If I create an instance like this:

    <iron-meta key="info" value="foo/bar"></iron-meta>

Note that value="foo/bar" is the metadata I've defined. I could define more
attributes or use child nodes to define additional metadata.

Now I can access that element (and it's metadata) from any iron-meta instance
via the byKey method, e.g.

    meta.byKey('info').getAttribute('value').

Pure imperative form would be like:

    document.createElement('iron-meta').byKey('info').getAttribute('value');

Or, in a Polymer element, you can include a meta in your template:

    <iron-meta id="meta"></iron-meta>
    ...
    this.$.meta.byKey('info').getAttribute('value');

@group Iron Elements
@demo demo/index.html
@hero hero.svg
@element iron-meta
-->

    <script>

        (function () {

            // monostate data
            var metaDatas = {};
            var metaArrays = {};
            var singleton = null;

            Polymer.IronMeta = Polymer({

                is: 'iron-meta',

                properties: {

                    /**
                     * The type of meta-data.  All meta-data of the same type is stored
                     * together.
                     */
                    type: {
                        type: String,
                        value: 'default',
                        observer: '_typeChanged'
                    },

                    /**
                     * The key used to store `value` under the `type` namespace.
                     */
                    key: {
                        type: String,
                        observer: '_keyChanged'
                    },

                    /**
                     * The meta-data to store or retrieve.
                     */
                    value: {
                        type: Object,
                        notify: true,
                        observer: '_valueChanged'
                    },

                    /**
                     * If true, `value` is set to the iron-meta instance itself.
                     */
                    self: {
                        type: Boolean,
                        observer: '_selfChanged'
                    },

                    /**
                     * Array of all meta-data values for the given type.
                     */
                    list: {
                        type: Array,
                        notify: true
                    }

                },

                hostAttributes: {
                    hidden: true
                },

                /**
                 * Only runs if someone invokes the factory/constructor directly
                 * e.g. `new Polymer.IronMeta()`
                 */
                factoryImpl: function (config) {
                    if (config) {
                        for (var n in config) {
                            switch (n) {
                                case 'type':
                                case 'key':
                                case 'value':
                                    this[n] = config[n];
                                    break;
                            }
                        }
                    }
                },

                created: function () {
                    // TODO(sjmiles): good for debugging?
                    this._metaDatas = metaDatas;
                    this._metaArrays = metaArrays;
                },

                _keyChanged: function (key, old) {
                    this._resetRegistration(old);
                },

                _valueChanged: function (value) {
                    this._resetRegistration(this.key);
                },

                _selfChanged: function (self) {
                    if (self) {
                        this.value = this;
                    }
                },

                _typeChanged: function (type) {
                    this._unregisterKey(this.key);
                    if (!metaDatas[type]) {
                        metaDatas[type] = {};
                    }
                    this._metaData = metaDatas[type];
                    if (!metaArrays[type]) {
                        metaArrays[type] = [];
                    }
                    this.list = metaArrays[type];
                    this._registerKeyValue(this.key, this.value);
                },

                /**
                 * Retrieves meta data value by key.
                 *
                 * @method byKey
                 * @param {string} key The key of the meta-data to be returned.
                 * @return {*}
                 */
                byKey: function (key) {
                    return this._metaData && this._metaData[key];
                },

                _resetRegistration: function (oldKey) {
                    this._unregisterKey(oldKey);
                    this._registerKeyValue(this.key, this.value);
                },

                _unregisterKey: function (key) {
                    this._unregister(key, this._metaData, this.list);
                },

                _registerKeyValue: function (key, value) {
                    this._register(key, value, this._metaData, this.list);
                },

                _register: function (key, value, data, list) {
                    if (key && data && value !== undefined) {
                        data[key] = value;
                        list.push(value);
                    }
                },

                _unregister: function (key, data, list) {
                    if (key && data) {
                        if (key in data) {
                            var value = data[key];
                            delete data[key];
                            this.arrayDelete(list, value);
                        }
                    }
                }

            });

            Polymer.IronMeta.getIronMeta = function getIronMeta() {
                if (singleton === null) {
                    singleton = new Polymer.IronMeta();
                }
                return singleton;
            };

            /**
             `iron-meta-query` can be used to access infomation stored in `iron-meta`.

             Examples:

             If I create an instance like this:

             <iron-meta key="info" value="foo/bar"></iron-meta>

             Note that value="foo/bar" is the metadata I've defined. I could define more
             attributes or use child nodes to define additional metadata.

             Now I can access that element (and it's metadata) from any `iron-meta-query` instance:

             var value = new Polymer.IronMetaQuery({key: 'info'}).value;

             @group Polymer Iron Elements
             @element iron-meta-query
             */
            Polymer.IronMetaQuery = Polymer({

                is: 'iron-meta-query',

                properties: {

                    /**
                     * The type of meta-data.  All meta-data of the same type is stored
                     * together.
                     */
                    type: {
                        type: String,
                        value: 'default',
                        observer: '_typeChanged'
                    },

                    /**
                     * Specifies a key to use for retrieving `value` from the `type`
                     * namespace.
                     */
                    key: {
                        type: String,
                        observer: '_keyChanged'
                    },

                    /**
                     * The meta-data to store or retrieve.
                     */
                    value: {
                        type: Object,
                        notify: true,
                        readOnly: true
                    },

                    /**
                     * Array of all meta-data values for the given type.
                     */
                    list: {
                        type: Array,
                        notify: true
                    }

                },

                /**
                 * Actually a factory method, not a true constructor. Only runs if
                 * someone invokes it directly (via `new Polymer.IronMeta()`);
                 */
                factoryImpl: function (config) {
                    if (config) {
                        for (var n in config) {
                            switch (n) {
                                case 'type':
                                case 'key':
                                    this[n] = config[n];
                                    break;
                            }
                        }
                    }
                },

                created: function () {
                    // TODO(sjmiles): good for debugging?
                    this._metaDatas = metaDatas;
                    this._metaArrays = metaArrays;
                },

                _keyChanged: function (key) {
                    this._setValue(this._metaData && this._metaData[key]);
                },

                _typeChanged: function (type) {
                    this._metaData = metaDatas[type];
                    this.list = metaArrays[type];
                    if (this.key) {
                        this._keyChanged(this.key);
                    }
                },

                /**
                 * Retrieves meta data value by key.
                 * @param {string} key The key of the meta-data to be returned.
                 * @return {*}
                 */
                byKey: function (key) {
                    return this._metaData && this._metaData[key];
                }

            });

        })();
    </script>
    <!--

The `iron-icon` element displays an icon. By default an icon renders as a 24px square.

Example using src:

    <iron-icon src="star.png"></iron-icon>

Example setting size to 32px x 32px:

    <iron-icon class="big" src="big_star.png"></iron-icon>

    <style is="custom-style">
      .big {
        --iron-icon-height: 32px;
        --iron-icon-width: 32px;
      }
    </style>

The iron elements include several sets of icons.
To use the default set of icons, import `iron-icons.html` and use the `icon` attribute to specify an icon:

    <link rel="import" href="/components/iron-icons/iron-icons.html">

    <iron-icon icon="menu"></iron-icon>

To use a different built-in set of icons, import the specific `iron-icons/<iconset>-icons.html`, and
specify the icon as `<iconset>:<icon>`. For example, to use a communication icon, you would
use:

    <link rel="import" href="/components/iron-icons/communication-icons.html">

    <iron-icon icon="communication:email"></iron-icon>

You can also create custom icon sets of bitmap or SVG icons.

Example of using an icon named `cherry` from a custom iconset with the ID `fruit`:

    <iron-icon icon="fruit:cherry"></iron-icon>

See [iron-iconset](iron-iconset) and [iron-iconset-svg](iron-iconset-svg) for more information about
how to create a custom iconset.

See the [iron-icons demo](iron-icons?view=demo:demo/index.html) to see the icons available
in the various iconsets.


### Styling

The following custom properties are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--iron-icon-width` | Width of the icon | `24px`
`--iron-icon-height` | Height of the icon | `24px`
`--iron-icon-fill-color` | Fill color of the svg icon | `currentcolor`
`--iron-icon-stroke-color` | Stroke color of the svg icon | none

@group Iron Elements
@element iron-icon
@demo demo/index.html
@hero hero.svg
@homepage polymer.github.io
-->

    <script>

        /**
         * @demo demo/index.html
         * @polymerBehavior
         */
        Polymer.IronControlState = {

            properties: {

                /**
                 * If true, the element currently has focus.
                 */
                focused: {
                    type: Boolean,
                    value: false,
                    notify: true,
                    readOnly: true,
                    reflectToAttribute: true
                },

                /**
                 * If true, the user cannot interact with this element.
                 */
                disabled: {
                    type: Boolean,
                    value: false,
                    notify: true,
                    observer: '_disabledChanged',
                    reflectToAttribute: true
                },

                _oldTabIndex: {
                    type: Number
                },

                _boundFocusBlurHandler: {
                    type: Function,
                    value: function () {
                        return this._focusBlurHandler.bind(this);
                    }
                }

            },

            observers: [
                '_changedControlState(focused, disabled)'
            ],

            ready: function () {
                this.addEventListener('focus', this._boundFocusBlurHandler, true);
                this.addEventListener('blur', this._boundFocusBlurHandler, true);
            },

            _focusBlurHandler: function (event) {
                // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
                // eventually become `this` due to retargeting; if we are not in
                // ShadowDOM land, `event.target` will eventually become `this` due
                // to the second conditional which fires a synthetic event (that is also
                // handled). In either case, we can disregard `event.path`.

                if (event.target === this) {
                    var focused = event.type === 'focus';
                    this._setFocused(focused);
                } else if (!this.shadowRoot) {
                    this.fire(event.type, {sourceEvent: event}, {
                        node: this,
                        bubbles: event.bubbles,
                        cancelable: event.cancelable
                    });
                }
            },

            _disabledChanged: function (disabled, old) {
                this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
                this.style.pointerEvents = disabled ? 'none' : '';
                if (disabled) {
                    this._oldTabIndex = this.tabIndex;
                    this.focused = false;
                    this.tabIndex = -1;
                } else if (this._oldTabIndex !== undefined) {
                    this.tabIndex = this._oldTabIndex;
                }
            },

            _changedControlState: function () {
                // _controlStateChanged is abstract, follow-on behaviors may implement it
                if (this._controlStateChanged) {
                    this._controlStateChanged();
                }
            }

        };

    </script>
    <script>

        /**
         * @demo demo/index.html
         * @polymerBehavior Polymer.IronButtonState
         */
        Polymer.IronButtonStateImpl = {

            properties: {

                /**
                 * If true, the user is currently holding down the button.
                 */
                pressed: {
                    type: Boolean,
                    readOnly: true,
                    value: false,
                    reflectToAttribute: true,
                    observer: '_pressedChanged'
                },

                /**
                 * If true, the button toggles the active state with each tap or press
                 * of the spacebar.
                 */
                toggles: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },

                /**
                 * If true, the button is a toggle and is currently in the active state.
                 */
                active: {
                    type: Boolean,
                    value: false,
                    notify: true,
                    reflectToAttribute: true
                },

                /**
                 * True if the element is currently being pressed by a "pointer," which
                 * is loosely defined as mouse or touch input (but specifically excluding
                 * keyboard input).
                 */
                pointerDown: {
                    type: Boolean,
                    readOnly: true,
                    value: false
                },

                /**
                 * True if the input device that caused the element to receive focus
                 * was a keyboard.
                 */
                receivedFocusFromKeyboard: {
                    type: Boolean,
                    readOnly: true
                },

                /**
                 * The aria attribute to be set if the button is a toggle and in the
                 * active state.
                 */
                ariaActiveAttribute: {
                    type: String,
                    value: 'aria-pressed',
                    observer: '_ariaActiveAttributeChanged'
                }
            },

            listeners: {
                down: '_downHandler',
                up: '_upHandler',
                tap: '_tapHandler'
            },

            observers: [
                '_detectKeyboardFocus(focused)',
                '_activeChanged(active, ariaActiveAttribute)'
            ],

            keyBindings: {
                'enter:keydown': '_asyncClick',
                'space:keydown': '_spaceKeyDownHandler',
                'space:keyup': '_spaceKeyUpHandler',
            },

            _mouseEventRe: /^mouse/,

            _tapHandler: function () {
                if (this.toggles) {
                    // a tap is needed to toggle the active state
                    this._userActivate(!this.active);
                } else {
                    this.active = false;
                }
            },

            _detectKeyboardFocus: function (focused) {
                this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
            },

            // to emulate native checkbox, (de-)activations from a user interaction fire
            // 'change' events
            _userActivate: function (active) {
                if (this.active !== active) {
                    this.active = active;
                    this.fire('change');
                }
            },

            _downHandler: function (event) {
                this._setPointerDown(true);
                this._setPressed(true);
                this._setReceivedFocusFromKeyboard(false);
            },

            _upHandler: function () {
                this._setPointerDown(false);
                this._setPressed(false);
            },

            _spaceKeyDownHandler: function (event) {
                var keyboardEvent = event.detail.keyboardEvent;
                keyboardEvent.preventDefault();
                keyboardEvent.stopImmediatePropagation();
                this._setPressed(true);
            },

            _spaceKeyUpHandler: function () {
                if (this.pressed) {
                    this._asyncClick();
                }
                this._setPressed(false);
            },

            // trigger click asynchronously, the asynchrony is useful to allow one
            // event handler to unwind before triggering another event
            _asyncClick: function () {
                this.async(function () {
                    this.click();
                }, 1);
            },

            // any of these changes are considered a change to button state

            _pressedChanged: function (pressed) {
                this._changedButtonState();
            },

            _ariaActiveAttributeChanged: function (value, oldValue) {
                if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
                    this.removeAttribute(oldValue);
                }
            },

            _activeChanged: function (active, ariaActiveAttribute) {
                if (this.toggles) {
                    this.setAttribute(this.ariaActiveAttribute,
                            active ? 'true' : 'false');
                } else {
                    this.removeAttribute(this.ariaActiveAttribute);
                }
                this._changedButtonState();
            },

            _controlStateChanged: function () {
                if (this.disabled) {
                    this._setPressed(false);
                } else {
                    this._changedButtonState();
                }
            },

            // provide hook for follow-on behaviors to react to button-state

            _changedButtonState: function () {
                if (this._buttonStateChanged) {
                    this._buttonStateChanged(); // abstract
                }
            }

        };

        /** @polymerBehavior */
        Polymer.IronButtonState = [
            Polymer.IronA11yKeysBehavior,
            Polymer.IronButtonStateImpl
        ];

    </script>
    <!--
Material design: [Surface reaction](https://www.google.com/design/spec/animation/responsive-interaction.html#responsive-interaction-surface-reaction)

`paper-ripple` provides a visual effect that other paper elements can
use to simulate a rippling effect emanating from the point of contact.  The
effect can be visualized as a concentric circle with motion.

Example:

    <div style="position:relative">
      <paper-ripple></paper-ripple>
    </div>

Note, it's important that the parent container of the ripple be relative position, otherwise
the ripple will emanate outside of the desired container.

`paper-ripple` listens to "mousedown" and "mouseup" events so it would display ripple
effect when touches on it.  You can also defeat the default behavior and
manually route the down and up actions to the ripple element.  Note that it is
important if you call `downAction()` you will have to make sure to call
`upAction()` so that `paper-ripple` would end the animation loop.

Example:

    <paper-ripple id="ripple" style="pointer-events: none;"></paper-ripple>
    ...
    downAction: function(e) {
      this.$.ripple.downAction({x: e.x, y: e.y});
    },
    upAction: function(e) {
      this.$.ripple.upAction();
    }

Styling ripple effect:

  Use CSS color property to style the ripple:

    paper-ripple {
      color: #4285f4;
    }

  Note that CSS color property is inherited so it is not required to set it on
  the `paper-ripple` element directly.

By default, the ripple is centered on the point of contact.  Apply the `recenters`
attribute to have the ripple grow toward the center of its container.

    <paper-ripple recenters></paper-ripple>

You can also  center the ripple inside its container from the start.

    <paper-ripple center></paper-ripple>

Apply `circle` class to make the rippling effect within a circle.

    <paper-ripple class="circle"></paper-ripple>

@group Paper Elements
@element paper-ripple
@hero hero.svg
@demo demo/index.html
-->

    <script>

        /**
         * `Polymer.PaperRippleBehavior` dynamically implements a ripple
         * when the element has focus via pointer or keyboard.
         *
         * NOTE: This behavior is intended to be used in conjunction with and after
         * `Polymer.IronButtonState` and `Polymer.IronControlState`.
         *
         * @polymerBehavior Polymer.PaperRippleBehavior
         */
        Polymer.PaperRippleBehavior = {

            properties: {
                /**
                 * If true, the element will not produce a ripple effect when interacted
                 * with via the pointer.
                 */
                noink: {
                    type: Boolean,
                    observer: '_noinkChanged'
                },

                /**
                 * @type {Element|undefined}
                 */
                _rippleContainer: {
                    type: Object,
                }
            },

            /**
             * Ensures a `<paper-ripple>` element is available when the element is
             * focused.
             */
            _buttonStateChanged: function () {
                if (this.focused) {
                    this.ensureRipple();
                }
            },

            /**
             * In addition to the functionality provided in `IronButtonState`, ensures
             * a ripple effect is created when the element is in a `pressed` state.
             */
            _downHandler: function (event) {
                Polymer.IronButtonStateImpl._downHandler.call(this, event);
                if (this.pressed) {
                    this.ensureRipple(event);
                }
            },

            /**
             * Ensures this element contains a ripple effect. For startup efficiency
             * the ripple effect is dynamically on demand when needed.
             * @param {!Event=} opt_triggeringEvent (optional) event that triggered the
             * ripple.
             */
            ensureRipple: function (opt_triggeringEvent) {
                if (!this.hasRipple()) {
                    this._ripple = this._createRipple();
                    this._ripple.noink = this.noink;
                    var rippleContainer = this._rippleContainer || this.root;
                    if (rippleContainer) {
                        Polymer.dom(rippleContainer).appendChild(this._ripple);
                    }
                    var domContainer = rippleContainer === this.shadyRoot ? this :
                            rippleContainer;
                    if (opt_triggeringEvent) {
                        var target = opt_triggeringEvent.target;
                        if (domContainer.contains(/** @type {Node} */(target))) {
                            this._ripple.uiDownAction(opt_triggeringEvent);
                        }
                    }
                }
            },

            /**
             * Returns the `<paper-ripple>` element used by this element to create
             * ripple effects. The element's ripple is created on demand, when
             * necessary, and calling this method will force the
             * ripple to be created.
             */
            getRipple: function () {
                this.ensureRipple();
                return this._ripple;
            },

            /**
             * Returns true if this element currently contains a ripple effect.
             * @return {boolean}
             */
            hasRipple: function () {
                return Boolean(this._ripple);
            },

            /**
             * Create the element's ripple effect via creating a `<paper-ripple>`.
             * Override this method to customize the ripple element.
             * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
             */
            _createRipple: function () {
                return /** @type {!PaperRippleElement} */ (
                        document.createElement('paper-ripple'));
            },

            _noinkChanged: function (noink) {
                if (this.hasRipple()) {
                    this._ripple.noink = noink;
                }
            }

        };

    </script>
    <script>

        /** @polymerBehavior Polymer.PaperButtonBehavior */
        Polymer.PaperButtonBehaviorImpl = {

            properties: {

                /**
                 * The z-depth of this element, from 0-5. Setting to 0 will remove the
                 * shadow, and each increasing number greater than 0 will be "deeper"
                 * than the last.
                 *
                 * @attribute elevation
                 * @type number
                 * @default 1
                 */
                elevation: {
                    type: Number,
                    reflectToAttribute: true,
                    readOnly: true
                }

            },

            observers: [
                '_calculateElevation(focused, disabled, active, pressed, receivedFocusFromKeyboard)',
                '_computeKeyboardClass(receivedFocusFromKeyboard)'
            ],

            hostAttributes: {
                role: 'button',
                tabindex: '0',
                animated: true
            },

            _calculateElevation: function () {
                var e = 1;
                if (this.disabled) {
                    e = 0;
                } else if (this.active || this.pressed) {
                    e = 4;
                } else if (this.receivedFocusFromKeyboard) {
                    e = 3;
                }
                this._setElevation(e);
            },

            _computeKeyboardClass: function (receivedFocusFromKeyboard) {
                this.classList.toggle('keyboard-focus', receivedFocusFromKeyboard);
            },

            /**
             * In addition to `IronButtonState` behavior, when space key goes down,
             * create a ripple down effect.
             *
             * @param {!KeyboardEvent} event .
             */
            _spaceKeyDownHandler: function (event) {
                Polymer.IronButtonStateImpl._spaceKeyDownHandler.call(this, event);
                if (this.hasRipple()) {
                    this._ripple.uiDownAction();
                }
            },

            /**
             * In addition to `IronButtonState` behavior, when space key goes up,
             * create a ripple up effect.
             *
             * @param {!KeyboardEvent} event .
             */
            _spaceKeyUpHandler: function (event) {
                Polymer.IronButtonStateImpl._spaceKeyUpHandler.call(this, event);
                if (this.hasRipple()) {
                    this._ripple.uiUpAction();
                }
            }

        };

        /** @polymerBehavior */
        Polymer.PaperButtonBehavior = [
            Polymer.IronButtonState,
            Polymer.IronControlState,
            Polymer.PaperRippleBehavior,
            Polymer.PaperButtonBehaviorImpl
        ];

    </script>
    <script>

        /**
         * `Polymer.PaperInkyFocusBehavior` implements a ripple when the element has keyboard focus.
         *
         * @polymerBehavior Polymer.PaperInkyFocusBehaviorImpl
         */
        Polymer.PaperInkyFocusBehaviorImpl = {

            observers: [
                '_focusedChanged(receivedFocusFromKeyboard)'
            ],

            _focusedChanged: function (receivedFocusFromKeyboard) {
                if (receivedFocusFromKeyboard) {
                    this.ensureRipple();
                }
                if (this.hasRipple()) {
                    this._ripple.holdDown = receivedFocusFromKeyboard;
                }
            },

            _createRipple: function () {
                var ripple = Polymer.PaperRippleBehavior._createRipple();
                ripple.id = 'ink';
                ripple.setAttribute('center', '');
                ripple.classList.add('circle');
                return ripple;
            }

        };

        /** @polymerBehavior Polymer.PaperInkyFocusBehavior */
        Polymer.PaperInkyFocusBehavior = [
            Polymer.IronButtonState,
            Polymer.IronControlState,
            Polymer.PaperRippleBehavior,
            Polymer.PaperInkyFocusBehaviorImpl
        ];

    </script>
    <!--
Material design: [Icon toggles](https://www.google.com/design/spec/components/buttons.html#buttons-toggle-buttons)

`paper-icon-button` is a button with an image placed at the center. When the user touches
the button, a ripple effect emanates from the center of the button.

`paper-icon-button` includes a default icon set.  Use `icon` to specify which icon
from the icon set to use.

    <paper-icon-button icon="menu"></paper-icon-button>

See [`iron-iconset`](#iron-iconset) for more information about
how to use a custom icon set.

Example:

    <link href="path/to/iron-icons/iron-icons.html" rel="import">

    <paper-icon-button icon="favorite"></paper-icon-button>
    <paper-icon-button src="star.png"></paper-icon-button>

### Styling

Style the button with CSS as you would a normal DOM element. If you are using the icons
provided by `iron-icons`, they will inherit the foreground color of the button.

    /* make a red "favorite" button */
    <paper-icon-button icon="favorite" style="color: red;"></paper-icon-button>

By default, the ripple is the same color as the foreground at 25% opacity. You may
customize the color using the `--paper-icon-button-ink-color` custom property.

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-icon-button-disabled-text` | The color of the disabled button | `--disabled-text-color`
`--paper-icon-button-ink-color` | Selected/focus ripple color | `--primary-text-color`
`--paper-icon-button` | Mixin for a button | `{}`
`--paper-icon-button-disabled` | Mixin for a disabled button | `{}`

@group Paper Elements
@element paper-icon-button
@demo demo/index.html
-->

    <script>
        /**
         * The `iron-iconset-svg` element allows users to define their own icon sets
         * that contain svg icons. The svg icon elements should be children of the
         * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
         *
         * Using svg elements to create icons has a few advantages over traditional
         * bitmap graphics like jpg or png. Icons that use svg are vector based so
         * they are resolution independent and should look good on any device. They
         * are stylable via css. Icons can be themed, colorized, and even animated.
         *
         * Example:
         *
         *     <iron-iconset-svg name="my-svg-icons" size="24">
         *       <svg>
         *         <defs>
         *           <g id="shape">
         *             <rect x="50" y="50" width="50" height="50" />
         *             <circle cx="50" cy="50" r="50" />
         *           </g>
         *         </defs>
         *       </svg>
         *     </iron-iconset-svg>
         *
         * This will automatically register the icon set "my-svg-icons" to the iconset
         * database.  To use these icons from within another element, make a
         * `iron-iconset` element and call the `byId` method
         * to retrieve a given iconset. To apply a particular icon inside an
         * element use the `applyIcon` method. For example:
         *
         *     iconset.applyIcon(iconNode, 'car');
         *
         * @element iron-iconset-svg
         * @demo demo/index.html
         * @implements {Polymer.Iconset}
         */
        Polymer({
            is: 'iron-iconset-svg',

            properties: {

                /**
                 * The name of the iconset.
                 */
                name: {
                    type: String,
                    observer: '_nameChanged'
                },

                /**
                 * The size of an individual icon. Note that icons must be square.
                 */
                size: {
                    type: Number,
                    value: 24
                }

            },

            attached: function () {
                this.style.display = 'none';
            },

            /**
             * Construct an array of all icon names in this iconset.
             *
             * @return {!Array} Array of icon names.
             */
            getIconNames: function () {
                this._icons = this._createIconMap();
                return Object.keys(this._icons).map(function (n) {
                    return this.name + ':' + n;
                }, this);
            },

            /**
             * Applies an icon to the given element.
             *
             * An svg icon is prepended to the element's shadowRoot if it exists,
             * otherwise to the element itself.
             *
             * @method applyIcon
             * @param {Element} element Element to which the icon is applied.
             * @param {string} iconName Name of the icon to apply.
             * @return {?Element} The svg element which renders the icon.
             */
            applyIcon: function (element, iconName) {
                // insert svg element into shadow root, if it exists
                element = element.root || element;
                // Remove old svg element
                this.removeIcon(element);
                // install new svg element
                var svg = this._cloneIcon(iconName);
                if (svg) {
                    var pde = Polymer.dom(element);
                    pde.insertBefore(svg, pde.childNodes[0]);
                    return element._svgIcon = svg;
                }
                return null;
            },

            /**
             * Remove an icon from the given element by undoing the changes effected
             * by `applyIcon`.
             *
             * @param {Element} element The element from which the icon is removed.
             */
            removeIcon: function (element) {
                // Remove old svg element
                if (element._svgIcon) {
                    Polymer.dom(element).removeChild(element._svgIcon);
                    element._svgIcon = null;
                }
            },

            /**
             *
             * When name is changed, register iconset metadata
             *
             */
            _nameChanged: function () {
                new Polymer.IronMeta({type: 'iconset', key: this.name, value: this});
                this.async(function () {
                    this.fire('iron-iconset-added', this, {node: window});
                });
            },

            /**
             * Create a map of child SVG elements by id.
             *
             * @return {!Object} Map of id's to SVG elements.
             */
            _createIconMap: function () {
                // Objects chained to Object.prototype (`{}`) have members. Specifically,
                // on FF there is a `watch` method that confuses the icon map, so we
                // need to use a null-based object here.
                var icons = Object.create(null);
                Polymer.dom(this).querySelectorAll('[id]')
                        .forEach(function (icon) {
                            icons[icon.id] = icon;
                        });
                return icons;
            },

            /**
             * Produce installable clone of the SVG element matching `id` in this
             * iconset, or `undefined` if there is no matching element.
             *
             * @return {Element} Returns an installable clone of the SVG element
             * matching `id`.
             */
            _cloneIcon: function (id) {
                // create the icon map on-demand, since the iconset itself has no discrete
                // signal to know when it's children are fully parsed
                this._icons = this._icons || this._createIconMap();
                return this._prepareSvgClone(this._icons[id], this.size);
            },

            /**
             * @param {Element} sourceSvg
             * @param {number} size
             * @return {Element}
             */
            _prepareSvgClone: function (sourceSvg, size) {
                if (sourceSvg) {
                    var content = sourceSvg.cloneNode(true),
                            svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
                            viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size;
                    svg.setAttribute('viewBox', viewBox);
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    // TODO(dfreedm): `pointer-events: none` works around https://crbug.com/370136
                    // TODO(sjmiles): inline style may not be ideal, but avoids requiring a shadow-root
                    svg.style.cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';
                    svg.appendChild(content).removeAttribute('id');
                    return svg;
                }
                return null;
            }

        });
    </script>
    <!--
`paper-tab` is styled to look like a tab.  It should be used in conjunction with
`paper-tabs`.

Example:

    <paper-tabs selected="0">
      <paper-tab>TAB 1</paper-tab>
      <paper-tab>TAB 2</paper-tab>
      <paper-tab>TAB 3</paper-tab>
    </paper-tabs>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-tab-ink` | Ink color | `--paper-yellow-a100`
`--paper-tab` | Mixin applied to the tab | `{}`
`--paper-tab-content` | Mixin applied to the tab content | `{}`

-->

    <!--
Material design: [Tabs](https://www.google.com/design/spec/components/tabs.html)

`paper-tabs` makes it easy to explore and switch between different views or functional aspects of
an app, or to browse categorized data sets.

Use `selected` property to get or set the selected tab.

Example:

    <paper-tabs selected="0">
      <paper-tab>TAB 1</paper-tab>
      <paper-tab>TAB 2</paper-tab>
      <paper-tab>TAB 3</paper-tab>
    </paper-tabs>

See <a href="#paper-tab">paper-tab</a> for more information about
`paper-tab`.

A common usage for `paper-tabs` is to use it along with `iron-pages` to switch
between different views.

    <paper-tabs selected="{{selected}}">
      <paper-tab>Tab 1</paper-tab>
      <paper-tab>Tab 2</paper-tab>
      <paper-tab>Tab 3</paper-tab>
    </paper-tabs>

    <iron-pages selected="{{selected}}">
      <div>Page 1</div>
      <div>Page 2</div>
      <div>Page 3</div>
    </iron-pages>


To use links in tabs, add `link` attribute to `paper-tab` and put an `<a>`
element in `paper-tab`.

Example:

    <paper-tabs selected="0">
      <paper-tab link>
        <a href="#link1" class="horizontal center-center layout">TAB ONE</a>
      </paper-tab>
      <paper-tab link>
        <a href="#link2" class="horizontal center-center layout">TAB TWO</a>
      </paper-tab>
      <paper-tab link>
        <a href="#link3" class="horizontal center-center layout">TAB THREE</a>
      </paper-tab>
    </paper-tabs>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-tabs-selection-bar-color` | Color for the selection bar | `--paper-yellow-a100`
`--paper-tabs` | Mixin applied to the tabs | `{}`

@hero hero.svg
@demo demo/index.html
-->

    <!--
Material design: [Cards](https://www.google.com/design/spec/components/cards.html)

`paper-material` is a container that renders two shadows on top of each other to
create the effect of a lifted piece of paper.

Example:

    <paper-material elevation="1">
      ... content ...
    </paper-material>

@group Paper Elements
@demo demo/index.html
-->

    <!--
Material design: [Buttons](https://www.google.com/design/spec/components/buttons.html)

`paper-button` is a button. When the user touches the button, a ripple effect emanates
from the point of contact. It may be flat or raised. A raised button is styled with a
shadow.

Example:

    <paper-button>Flat button</paper-button>
    <paper-button raised>Raised button</paper-button>
    <paper-button noink>No ripple effect</paper-button>
    <paper-button toggles>Toggle-able button</paper-button>

A button that has `toggles` true will remain `active` after being clicked (and
will have an `active` attribute set). For more information, see the `Polymer.IronButtonState`
behavior.

You may use custom DOM in the button body to create a variety of buttons. For example, to
create a button with an icon and some text:

    <paper-button>
      <iron-icon icon="favorite"></iron-icon>
      custom button content
    </paper-button>

### Styling

Style the button with CSS as you would a normal DOM element.

    paper-button.fancy {
      background: green;
      color: yellow;
    }

    paper-button.fancy:hover {
      background: lime;
    }

    paper-button[disabled],
    paper-button[toggles][active] {
      background: red;
    }

By default, the ripple is the same color as the foreground at 25% opacity. You may
customize the color using the `--paper-button-ink-color` custom property.

The following custom properties and mixins are also available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-button-ink-color` | Background color of the ripple | `Based on the button's color`
`--paper-button` | Mixin applied to the button | `{}`
`--paper-button-disabled` | Mixin applied to the disabled button. Note that you can also use the `paper-button[disabled]` selector | `{}`
`--paper-button-flat-keyboard-focus` | Mixin applied to a flat button after it's been focused using the keyboard | `{}`
`--paper-button-raised-keyboard-focus` | Mixin applied to a raised button after it's been focused using the keyboard | `{}`

@demo demo/index.html
-->

    <!--
Material design: [Progress & activity](https://www.google.com/design/spec/components/progress-activity.html)

Element providing material design circular spinner.

    <paper-spinner active></paper-spinner>

The default spinner cycles between four layers of colors; by default they are
blue, red, yellow and green. It can be customized so that it uses one color only
by setting all the layer colors to the same value.

### Accessibility

Alt attribute should be set to provide adequate context for accessibility. If not provided,
it defaults to 'loading'.
Empty alt can be provided to mark the element as decorative if alternative content is provided
in another form (e.g. a text block following the spinner).

    <paper-spinner alt="Loading contacts list" active></paper-spinner>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-spinner-layer-1-color` | Color of the first spinner rotation | `--google-blue-500`
`--paper-spinner-layer-2-color` | Color of the second spinner rotation | `--google-red-500`
`--paper-spinner-layer-3-color` | Color of the third spinner rotation | `--google-yellow-500`
`--paper-spinner-layer-4-color` | Color of the fourth spinner rotation | `--google-green-500`

@group Paper Elements
@element paper-spinner
@hero hero.svg
@demo demo/index.html
-->

    <!--
Material design: [Floating Action Button](https://www.google.com/design/spec/components/buttons-floating-action-button.html)

`paper-fab` is a floating action button. It contains an image placed in the center and
comes in two sizes: regular size and a smaller size by applying the attribute `mini`. When
the user touches the button, a ripple effect emanates from the center of the button.

You may import `iron-icons` to use with this element, or provide a URL to a custom icon.
See `iron-iconset` for more information about how to use a custom icon set.

Example:

    <link href="path/to/iron-icons/iron-icons.html" rel="import">

    <paper-fab icon="add"></paper-fab>
    <paper-fab mini icon="favorite"></paper-fab>
    <paper-fab src="star.png"></paper-fab>


### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-fab-background` | The background color of the button | `--accent-color`
`--paper-fab-keyboard-focus-background` | The background color of the button when focused | `--paper-pink-900`
`--paper-fab-disabled-background` | The background color of the button when it's disabled | `--paper-grey-300`
`--paper-fab-disabled-text` | The text color of the button when it's disabled | `--paper-grey-500`
`--paper-fab` | Mixin applied to the button | `{}`
`--paper-fab-mini` | Mixin applied to a mini button | `{}`
`--paper-fab-disabled` | Mixin applied to a disabled button | `{}`
`--paper-fab-iron-icon` | Mixin applied to the iron-icon within the button | `{}`

@group Paper Elements
@demo demo/index.html

-->

    <script>

        /**
         * `Use Polymer.IronValidatableBehavior` to implement an element that validates user input.
         * Use the related `Polymer.IronValidatorBehavior` to add custom validation logic to an iron-input.
         *
         * By default, an `<iron-form>` element validates its fields when the user presses the submit button.
         * To validate a form imperatively, call the form's `validate()` method, which in turn will
         * call `validate()` on all its children. By using `Polymer.IronValidatableBehavior`, your
         * custom element will get a public `validate()`, which
         * will return the validity of the element, and a corresponding `invalid` attribute,
         * which can be used for styling.
         *
         * To implement the custom validation logic of your element, you must override
         * the protected `_getValidity()` method of this behaviour, rather than `validate()`.
         * See [this](https://github.com/PolymerElements/iron-form/blob/master/demo/simple-element.html)
         * for an example.
         *
         * ### Accessibility
         *
         * Changing the `invalid` property, either manually or by calling `validate()` will update the
         * `aria-invalid` attribute.
         *
         * @demo demo/index.html
         * @polymerBehavior
         */
        Polymer.IronValidatableBehavior = {

            properties: {

                /**
                 * Namespace for this validator.
                 */
                validatorType: {
                    type: String,
                    value: 'validator'
                },

                /**
                 * Name of the validator to use.
                 */
                validator: {
                    type: String
                },

                /**
                 * True if the last call to `validate` is invalid.
                 */
                invalid: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Boolean,
                    value: false
                },

                _validatorMeta: {
                    type: Object
                }

            },

            observers: [
                '_invalidChanged(invalid)'
            ],

            get _validator() {
                return this._validatorMeta && this._validatorMeta.byKey(this.validator);
            },

            ready: function () {
                this._validatorMeta = new Polymer.IronMeta({type: this.validatorType});
            },

            _invalidChanged: function () {
                if (this.invalid) {
                    this.setAttribute('aria-invalid', 'true');
                } else {
                    this.removeAttribute('aria-invalid');
                }
            },

            /**
             * @return {boolean} True if the validator `validator` exists.
             */
            hasValidator: function () {
                return this._validator != null;
            },

            /**
             * Returns true if the `value` is valid, and updates `invalid`. If you want
             * your element to have custom validation logic, do not override this method;
             * override `_getValidity(value)` instead.

             * @param {Object} value The value to be validated. By default, it is passed
             * to the validator's `validate()` function, if a validator is set.
             * @return {boolean} True if `value` is valid.
             */
            validate: function (value) {
                this.invalid = !this._getValidity(value);
                return !this.invalid;
            },

            /**
             * Returns true if `value` is valid.  By default, it is passed
             * to the validator's `validate()` function, if a validator is set. You
             * should override this method if you want to implement custom validity
             * logic for your element.
             *
             * @param {Object} value The value to be validated.
             * @return {boolean} True if `value` is valid.
             */

            _getValidity: function (value) {
                if (this.hasValidator()) {
                    return this._validator.validate(value);
                }
                return true;
            }
        };

    </script>
    <script>

        /*
         `<iron-input>` adds two-way binding and custom validators using `Polymer.IronValidatorBehavior`
         to `<input>`.

         ### Two-way binding

         By default you can only get notified of changes to an `input`'s `value` due to user input:

         <input value="{{myValue::input}}">

         `iron-input` adds the `bind-value` property that mirrors the `value` property, and can be used
         for two-way data binding. `bind-value` will notify if it is changed either by user input or by script.

         <input is="iron-input" bind-value="{{myValue}}">

         ### Custom validators

         You can use custom validators that implement `Polymer.IronValidatorBehavior` with `<iron-input>`.

         <input is="iron-input" validator="my-custom-validator">

         ### Stopping invalid input

         It may be desirable to only allow users to enter certain characters. You can use the
         `prevent-invalid-input` and `allowed-pattern` attributes together to accomplish this. This feature
         is separate from validation, and `allowed-pattern` does not affect how the input is validated.

        <!-- only allow characters that match [0-9] -->
        <
        input
        is = "iron-input"
        prevent - invalid - input
        allowed - pattern = "[0-9]" >

        @
        hero
        hero.svg
        @
        demo
        demo / index.html
        * /

        Polymer({

            is: 'iron-input',

            extends: 'input',

            behaviors: [
                Polymer.IronValidatableBehavior
            ],

            properties: {

                /**
                 * Use this property instead of `value` for two-way data binding.
                 */
                bindValue: {
                    observer: '_bindValueChanged',
                    type: String
                },

                /**
                 * Set to true to prevent the user from entering invalid input. The new input characters are
                 * matched with `allowedPattern` if it is set, otherwise it will use the `pattern` attribute if
                 * set, or the `type` attribute (only supported for `type=number`).
                 */
                preventInvalidInput: {
                    type: Boolean
                },

                /**
                 * Regular expression to match valid input characters.
                 */
                allowedPattern: {
                    type: String
                },

                _previousValidInput: {
                    type: String,
                    value: ''
                },

                _patternAlreadyChecked: {
                    type: Boolean,
                    value: false
                }

            },

            listeners: {
                'input': '_onInput',
                'keypress': '_onKeypress'
            },

            get _patternRegExp() {
                var pattern;
                if (this.allowedPattern) {
                    pattern = new RegExp(this.allowedPattern);
                } else if (this.pattern) {
                    pattern = new RegExp(this.pattern);
                } else {
                    switch (this.type) {
                        case 'number':
                            pattern = /[0-9.,e-]/;
                            break;
                    }
                }
                return pattern;
            },

            ready: function () {
                this.bindValue = this.value;
            },

            /**
             * @suppress {checkTypes}
             */
            _bindValueChanged: function () {
                if (this.value !== this.bindValue) {
                    this.value = !(this.bindValue || this.bindValue === 0) ? '' : this.bindValue;
                }
                // manually notify because we don't want to notify until after setting value
                this.fire('bind-value-changed', {value: this.bindValue});
            },

            _onInput: function () {
                // Need to validate each of the characters pasted if they haven't
                // been validated inside `_onKeypress` already.
                if (this.preventInvalidInput && !this._patternAlreadyChecked) {
                    var valid = this._checkPatternValidity();
                    if (!valid) {
                        this.value = this._previousValidInput;
                    }
                }

                this.bindValue = this.value;
                this._previousValidInput = this.value;
                this._patternAlreadyChecked = false;
            },

            _isPrintable: function (event) {
                // What a control/printable character is varies wildly based on the browser.
                // - most control characters (arrows, backspace) do not send a `keypress` event
                //   in Chrome, but the *do* on Firefox
                // - in Firefox, when they do send a `keypress` event, control chars have
                //   a charCode = 0, keyCode = xx (for ex. 40 for down arrow)
                // - printable characters always send a keypress event.
                // - in Firefox, printable chars always have a keyCode = 0. In Chrome, the keyCode
                //   always matches the charCode.
                // None of this makes any sense.

                // For these keys, ASCII code == browser keycode.
                var anyNonPrintable =
                        (event.keyCode == 8) ||  // backspace
                        (event.keyCode == 9) ||  // tab
                        (event.keyCode == 13) ||  // enter
                        (event.keyCode == 27);     // escape

                // For these keys, make sure it's a browser keycode and not an ASCII code.
                var mozNonPrintable =
                        (event.keyCode == 19) ||  // pause
                        (event.keyCode == 20) ||  // caps lock
                        (event.keyCode == 45) ||  // insert
                        (event.keyCode == 46) ||  // delete
                        (event.keyCode == 144) ||  // num lock
                        (event.keyCode == 145) ||  // scroll lock
                        (event.keyCode > 32 && event.keyCode < 41) || // page up/down, end, home, arrows
                        (event.keyCode > 111 && event.keyCode < 124); // fn keys

                return !anyNonPrintable && !(event.charCode == 0 && mozNonPrintable);
            },

            _onKeypress: function (event) {
                if (!this.preventInvalidInput && this.type !== 'number') {
                    return;
                }
                var regexp = this._patternRegExp;
                if (!regexp) {
                    return;
                }

                // Handle special keys and backspace
                if (event.metaKey || event.ctrlKey || event.altKey)
                    return;

                // Check the pattern either here or in `_onInput`, but not in both.
                this._patternAlreadyChecked = true;

                var thisChar = String.fromCharCode(event.charCode);
                if (this._isPrintable(event) && !regexp.test(thisChar)) {
                    event.preventDefault();
                }
            },

            _checkPatternValidity: function () {
                var regexp = this._patternRegExp;
                if (!regexp) {
                    return true;
                }
                for (var i = 0; i < this.value.length; i++) {
                    if (!regexp.test(this.value[i])) {
                        return false;
                    }
                }
                return true;
            },

            /**
             * Returns true if `value` is valid. The validator provided in `validator` will be used first,
             * then any constraints.
             * @return {boolean} True if the value is valid.
             */
            validate: function () {
                // Empty, non-required input is valid.
                if (!this.required && this.value == '') {
                    this.invalid = false;
                    return true;
                }

                var valid;
                if (this.hasValidator()) {
                    valid = Polymer.IronValidatableBehavior.validate.call(this, this.value);
                } else {
                    this.invalid = !this.validity.valid;
                    valid = this.validity.valid;
                }
                this.fire('iron-input-validate');
                return valid;
            }

        });

        /*
         The `iron-input-validate` event is fired whenever `validate()` is called.
         @event iron-input-validate
         */

    </script>
    <script>
        /**
         Polymer.IronFormElementBehavior enables a custom element to be included
         in an `iron-form`.

         @demo demo/index.html
         @polymerBehavior
         */
        Polymer.IronFormElementBehavior = {

            properties: {
                /**
                 * Fired when the element is added to an `iron-form`.
                 *
                 * @event iron-form-element-register
                 */

                /**
                 * Fired when the element is removed from an `iron-form`.
                 *
                 * @event iron-form-element-unregister
                 */

                /**
                 * The name of this element.
                 */
                name: {
                    type: String
                },

                /**
                 * The value for this element.
                 */
                value: {
                    notify: true,
                    type: String
                },

                /**
                 * Set to true to mark the input as required. If used in a form, a
                 * custom element that uses this behavior should also use
                 * Polymer.IronValidatableBehavior and define a custom validation method.
                 * Otherwise, a `required` element will always be considered valid.
                 * It's also strongly recommended to provide a visual style for the element
                 * when its value is invalid.
                 */
                required: {
                    type: Boolean,
                    value: false
                },

                /**
                 * The form that the element is registered to.
                 */
                _parentForm: {
                    type: Object
                }
            },

            attached: function () {
                // Note: the iron-form that this element belongs to will set this
                // element's _parentForm property when handling this event.
                this.fire('iron-form-element-register');
            },

            detached: function () {
                if (this._parentForm) {
                    this._parentForm.fire('iron-form-element-unregister', {target: this});
                }
            }

        };

    </script>
    <script>

        /**
         * Use `Polymer.PaperInputBehavior` to implement inputs with `<paper-input-container>`. This
         * behavior is implemented by `<paper-input>`. It exposes a number of properties from
         * `<paper-input-container>` and `<input is="iron-input">` and they should be bound in your
         * template.
         *
         * The input element can be accessed by the `inputElement` property if you need to access
         * properties or methods that are not exposed.
         * @polymerBehavior Polymer.PaperInputBehavior
         */
        Polymer.PaperInputBehaviorImpl = {

            properties: {
                /**
                 * Fired when the input changes due to user interaction.
                 *
                 * @event change
                 */

                /**
                 * The label for this input. Bind this to `<paper-input-container>`'s `label` property.
                 */
                label: {
                    type: String
                },

                /**
                 * The value for this input. Bind this to the `<input is="iron-input">`'s `bindValue`
                 * property, or the value property of your input that is `notify:true`.
                 */
                value: {
                    notify: true,
                    type: String
                },

                /**
                 * Set to true to disable this input. Bind this to both the `<paper-input-container>`'s
                 * and the input's `disabled` property.
                 */
                disabled: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Returns true if the value is invalid. Bind this to both the `<paper-input-container>`'s
                 * and the input's `invalid` property.
                 */
                invalid: {
                    type: Boolean,
                    value: false,
                    notify: true
                },

                /**
                 * Set to true to prevent the user from entering invalid input. Bind this to the
                 * `<input is="iron-input">`'s `preventInvalidInput` property.
                 */
                preventInvalidInput: {
                    type: Boolean
                },

                /**
                 * Set this to specify the pattern allowed by `preventInvalidInput`. Bind this to the
                 * `<input is="iron-input">`'s `allowedPattern` property.
                 */
                allowedPattern: {
                    type: String
                },

                /**
                 * The type of the input. The supported types are `text`, `number` and `password`. Bind this
                 * to the `<input is="iron-input">`'s `type` property.
                 */
                type: {
                    type: String
                },

                /**
                 * The datalist of the input (if any). This should match the id of an existing `<datalist>`. Bind this
                 * to the `<input is="iron-input">`'s `list` property.
                 */
                list: {
                    type: String
                },

                /**
                 * A pattern to validate the `input` with. Bind this to the `<input is="iron-input">`'s
                 * `pattern` property.
                 */
                pattern: {
                    type: String
                },

                /**
                 * Set to true to mark the input as required. Bind this to the `<input is="iron-input">`'s
                 * `required` property.
                 */
                required: {
                    type: Boolean,
                    value: false
                },

                /**
                 * The error message to display when the input is invalid. Bind this to the
                 * `<paper-input-error>`'s content, if using.
                 */
                errorMessage: {
                    type: String
                },

                /**
                 * Set to true to show a character counter.
                 */
                charCounter: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Set to true to disable the floating label. Bind this to the `<paper-input-container>`'s
                 * `noLabelFloat` property.
                 */
                noLabelFloat: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Set to true to always float the label. Bind this to the `<paper-input-container>`'s
                 * `alwaysFloatLabel` property.
                 */
                alwaysFloatLabel: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Set to true to auto-validate the input value. Bind this to the `<paper-input-container>`'s
                 * `autoValidate` property.
                 */
                autoValidate: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Name of the validator to use. Bind this to the `<input is="iron-input">`'s `validator`
                 * property.
                 */
                validator: {
                    type: String
                },

                // HTMLInputElement attributes for binding if needed

                /**
                 * Bind this to the `<input is="iron-input">`'s `autocomplete` property.
                 */
                autocomplete: {
                    type: String,
                    value: 'off'
                },

                /**
                 * Bind this to the `<input is="iron-input">`'s `autofocus` property.
                 */
                autofocus: {
                    type: Boolean
                },

                /**
                 * Bind this to the `<input is="iron-input">`'s `inputmode` property.
                 */
                inputmode: {
                    type: String
                },

                /**
                 * Bind this to the `<input is="iron-input">`'s `minlength` property.
                 */
                minlength: {
                    type: Number
                },

                /**
                 * The maximum length of the input value. Bind this to the `<input is="iron-input">`'s
                 * `maxlength` property.
                 */
                maxlength: {
                    type: Number
                },

                /**
                 * The minimum (numeric or date-time) input value.
                 * Bind this to the `<input is="iron-input">`'s `min` property.
                 */
                min: {
                    type: String
                },

                /**
                 * The maximum (numeric or date-time) input value.
                 * Can be a String (e.g. `"2000-1-1"`) or a Number (e.g. `2`).
                 * Bind this to the `<input is="iron-input">`'s `max` property.
                 */
                max: {
                    type: String
                },

                /**
                 * Limits the numeric or date-time increments.
                 * Bind this to the `<input is="iron-input">`'s `step` property.
                 */
                step: {
                    type: String
                },

                /**
                 * Bind this to the `<input is="iron-input">`'s `name` property.
                 */
                name: {
                    type: String
                },

                /**
                 * A placeholder string in addition to the label. If this is set, the label will always float.
                 */
                placeholder: {
                    type: String,
                    // need to set a default so _computeAlwaysFloatLabel is run
                    value: ''
                },

                /**
                 * Bind this to the `<input is="iron-input">`'s `readonly` property.
                 */
                readonly: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Bind this to the `<input is="iron-input">`'s `size` property.
                 */
                size: {
                    type: Number
                },

                // Nonstandard attributes for binding if needed

                /**
                 * Bind this to the `<input is="iron-input">`'s `autocapitalize` property.
                 */
                autocapitalize: {
                    type: String,
                    value: 'none'
                },

                /**
                 * Bind this to the `<input is="iron-input">`'s `autocorrect` property.
                 */
                autocorrect: {
                    type: String,
                    value: 'off'
                },

                /**
                 * Bind this to the `<input is="iron-input">`'s `autosave` property, used with type=search.
                 */
                autosave: {
                    type: String
                },

                /**
                 * Bind this to the `<input is="iron-input">`'s `results` property, , used with type=search.
                 */
                results: {
                    type: Number
                },

                /**
                 * Bind this to the `<input is="iron-input">`'s `accept` property, , used with type=file.
                 */
                accept: {
                    type: String
                },

                /**
                 * Bind this to the `<input is="iron-input">`'s `multiple` property, , used with type=file.
                 */
                multiple: {
                    type: Boolean
                },

                _ariaDescribedBy: {
                    type: String,
                    value: ''
                }

            },

            listeners: {
                'addon-attached': '_onAddonAttached'
            },

            observers: [
                '_focusedControlStateChanged(focused)'
            ],

            /**
             * Returns a reference to the input element.
             */
            get inputElement() {
                return this.$.input;
            },

            attached: function () {
                this._updateAriaLabelledBy();
            },

            _appendStringWithSpace: function (str, more) {
                if (str) {
                    str = str + ' ' + more;
                } else {
                    str = more;
                }
                return str;
            },

            _onAddonAttached: function (event) {
                var target = event.path ? event.path[0] : event.target;
                if (target.id) {
                    this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, target.id);
                } else {
                    var id = 'paper-input-add-on-' + Math.floor((Math.random() * 100000));
                    target.id = id;
                    this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, id);
                }
            },

            /**
             * Validates the input element and sets an error style if needed.
             *
             * @return {boolean}
             */
            validate: function () {
                return this.inputElement.validate();
            },

            /**
             * If `autoValidate` is true, then validates the element.
             */
            _handleAutoValidate: function () {
                if (this.autoValidate)
                    this.validate();
            },

            /**
             * Restores the cursor to its original position after updating the value.
             * @param {string} newValue The value that should be saved.
             */
            updateValueAndPreserveCaret: function (newValue) {
                // Not all elements might have selection, and even if they have the
                // right properties, accessing them might throw an exception (like for
                // <input type=number>)
                try {
                    var start = this.inputElement.selectionStart;
                    this.value = newValue;

                    // The cursor automatically jumps to the end after re-setting the value,
                    // so restore it to its original position.
                    this.inputElement.selectionStart = start;
                    this.inputElement.selectionEnd = start;
                } catch (e) {
                    // Just set the value and give up on the caret.
                    this.value = newValue;
                }
            },

            _computeAlwaysFloatLabel: function (alwaysFloatLabel, placeholder) {
                return placeholder || alwaysFloatLabel;
            },

            _focusedControlStateChanged: function (focused) {
                // IronControlState stops the focus and blur events in order to redispatch them on the host
                // element, but paper-input-container listens to those events. Since there are more
                // pending work on focus/blur in IronControlState, I'm putting in this hack to get the
                // input focus state working for now.
                if (!this.$.container) {
                    this.$.container = Polymer.dom(this.root).querySelector('paper-input-container');
                    if (!this.$.container) {
                        return;
                    }
                }
                if (focused) {
                    this.$.container._onFocus();
                } else {
                    this.$.container._onBlur();
                }
            },

            _updateAriaLabelledBy: function () {
                var label = Polymer.dom(this.root).querySelector('label');
                if (!label) {
                    this._ariaLabelledBy = '';
                    return;
                }
                var labelledBy;
                if (label.id) {
                    labelledBy = label.id;
                } else {
                    labelledBy = 'paper-input-label-' + new Date().getUTCMilliseconds();
                    label.id = labelledBy;
                }
                this._ariaLabelledBy = labelledBy;
            },

            _onChange: function (event) {
                // In the Shadow DOM, the `change` event is not leaked into the
                // ancestor tree, so we must do this manually.
                // See https://w3c.github.io/webcomponents/spec/shadow/#events-that-are-not-leaked-into-ancestor-trees.
                if (this.shadowRoot) {
                    this.fire(event.type, {sourceEvent: event}, {
                        node: this,
                        bubbles: event.bubbles,
                        cancelable: event.cancelable
                    });
                }
            }

        };

        /** @polymerBehavior */
        Polymer.PaperInputBehavior = [Polymer.IronControlState, Polymer.PaperInputBehaviorImpl];

    </script>
    <!--
`<paper-input-container>` is a container for a `<label>`, an `<input is="iron-input">` or
`<iron-autogrow-textarea>` and optional add-on elements such as an error message or character
counter, used to implement Material Design text fields.

For example:

    <paper-input-container>
      <label>Your name</label>
      <input is="iron-input">
    </paper-input-container>

### Listening for input changes

By default, it listens for changes on the `bind-value` attribute on its children nodes and perform
tasks such as auto-validating and label styling when the `bind-value` changes. You can configure
the attribute it listens to with the `attr-for-value` attribute.

### Using a custom input element

You can use a custom input element in a `<paper-input-container>`, for example to implement a
compound input field like a social security number input. The custom input element should have the
`paper-input-input` class, have a `notify:true` value property and optionally implements
`Polymer.IronValidatableBehavior` if it is validatable.

    <paper-input-container attr-for-value="ssn-value">
      <label>Social security number</label>
      <ssn-input class="paper-input-input"></ssn-input>
    </paper-input-container>

### Validation

If the `auto-validate` attribute is set, the input container will validate the input and update
the container styling when the input value changes.

### Add-ons

Add-ons are child elements of a `<paper-input-container>` with the `add-on` attribute and
implements the `Polymer.PaperInputAddonBehavior` behavior. They are notified when the input value
or validity changes, and may implement functionality such as error messages or character counters.
They appear at the bottom of the input.

### Prefixes and suffixes
These are child elements of a `<paper-input-container>` with the `prefix`
or `suffix` attribute, and are displayed inline with the input, before or after.

    <paper-input-container>
      <div prefix>$</div>
      <label>Total</label>
      <input is="iron-input">
      <paper-icon-button suffix icon="clear"></paper-icon-button>
    </paper-input-container>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-input-container-color` | Label and underline color when the input is not focused | `--secondary-text-color`
`--paper-input-container-focus-color` | Label and underline color when the input is focused | `--default-primary-color`
`--paper-input-container-invalid-color` | Label and underline color when the input is is invalid | `--google-red-500`
`--paper-input-container-input-color` | Input foreground color | `--primary-text-color`
`--paper-input-container` | Mixin applied to the container | `{}`
`--paper-input-container-disabled` | Mixin applied to the container when it's disabled | `{}`
`--paper-input-container-label` | Mixin applied to the label | `{}`
`--paper-input-container-label-focus` | Mixin applied to the label when the input is focused | `{}`
`--paper-input-container-input` | Mixin applied to the input | `{}`
`--paper-input-container-underline` | Mixin applied to the underline | `{}`
`--paper-input-container-underline-focus` | Mixin applied to the underline when the input is focued | `{}`
`--paper-input-container-underline-disabled` | Mixin applied to the underline when the input is disabled | `{}`
`--paper-input-prefix` | Mixin applied to the input prefix | `{}`
`--paper-input-suffix` | Mixin applied to the input suffix | `{}`

This element is `display:block` by default, but you can set the `inline` attribute to make it
`display:inline-block`.
-->
    <script>

        /**
         * Use `Polymer.PaperInputAddonBehavior` to implement an add-on for `<paper-input-container>`. A
         * add-on appears below the input, and may display information based on the input value and
         * validity such as a character counter or an error message.
         * @polymerBehavior
         */
        Polymer.PaperInputAddonBehavior = {

            hostAttributes: {
                'add-on': ''
            },

            attached: function () {
                this.fire('addon-attached');
            },

            /**
             * The function called by `<paper-input-container>` when the input value or validity changes.
             * @param {{
     *   inputElement: (Node|undefined),
     *   value: (string|undefined),
     *   invalid: (boolean|undefined)
     * }} state All properties are optional -
             *     inputElement: The input element.
             *     value: The input value.
             *     invalid: True if the input value is invalid.
             */
            update: function (state) {
            }

        };

    </script>
    <!--
`<paper-input-error>` is an error message for use with `<paper-input-container>`. The error is
displayed when the `<paper-input-container>` is `invalid`.

    <paper-input-container>
      <input is="iron-input" pattern="[0-9]*">
      <paper-input-error>Only numbers are allowed!</paper-input-error>
    </paper-input-container>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-input-container-invalid-color` | The foreground color of the error | `--google-red-500`
`--paper-input-error`                   | Mixin applied to the error        | `{}`
-->
    <!--
`<paper-input-char-counter>` is a character counter for use with `<paper-input-container>`. It
shows the number of characters entered in the input and the max length if it is specified.

    <paper-input-container>
      <input is="iron-input" maxlength="20">
      <paper-input-char-counter></paper-input-char-counter>
    </paper-input-container>

### Styling

The following mixin is available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-input-char-counter` | Mixin applied to the element | `{}`
-->
    <!--
Material design: [Text fields](https://www.google.com/design/spec/components/text-fields.html)

`<paper-input>` is a single-line text field with Material Design styling.

    <paper-input label="Input label"></paper-input>

It may include an optional error message or character counter.

    <paper-input error-message="Invalid input!" label="Input label"></paper-input>
    <paper-input char-counter label="Input label"></paper-input>

It can also include custom prefix or suffix elements, which are displayed
before or after the text input itself. In order for an element to be
considered as a prefix, it must have the `prefix` attribute (and similarly
for `suffix`).

    <paper-input label="total">
      <div prefix>$</div>
      <paper-icon-button suffix icon="clear"></paper-icon-button>
    </paper-input>

A `paper-input` can use the native `type=search` or `type=file` features.
However, since we can't control the native styling of the input, in these cases
it's recommended to use a placeholder text, or `always-float-label`,
as to not overlap the native UI (search icon, file button, etc.).

    <paper-input label="search!" type="search"
        placeholder="search for cats" autosave="test" results="5">
    </paper-input>

See `Polymer.PaperInputBehavior` for more API docs.

### Styling

See `Polymer.PaperInputContainer` for a list of custom properties used to
style this element.

@group Paper Elements
@element paper-input
@hero hero.svg
@demo demo/index.html
-->

    <!--
Material design: [Cards](https://www.google.com/design/spec/components/cards.html)

`paper-card` is a container with a drop shadow.

Example:

    <paper-card heading="Card Title">
      <div class="card-content">Some content</div>
      <div class="card-actions">
        <paper-button>Some action</paper-button>
      </div>
    </paper-card>

Example - top card image:

    <paper-card heading="Card Title" image="/path/to/image.png">
      ...
    </paper-card>

### Accessibility

By default, the `aria-label` will be set to the value of the `heading` attribute.

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--paper-card-header-color` | The color of the header text | `#000`
`--paper-card-header` | Mixin applied to the card header section | `{}`
`--paper-card-header-text` | Mixin applied to the title in the card header section | `{}`
`--paper-card-header-image` | Mixin applied to the image in the card header section | `{}`
`--paper-card-header-image-text` | Mixin applied to the text overlapping the image in the card header section | `{}`
`--paper-card-content` | Mixin applied to the card content section| `{}`
`--paper-card-actions` | Mixin applied to the card action section | `{}`
`--paper-card` | Mixin applied to the card | `{}`

@group Paper Elements
@element paper-card
@demo demo/index.html
-->

    <!--
`iron-media-query` can be used to data bind to a CSS media query.
The `query` property is a bare CSS media query.
The `query-matches` property is a boolean representing whether the page matches that media query.

Example:

    <iron-media-query query="(min-width: 600px)" query-matches="{{queryMatches}}"></iron-media-query>

@group Iron Elements
@demo demo/index.html
@hero hero.svg
@element iron-media-query
-->

    <script>

        Polymer({

            is: 'iron-media-query',

            properties: {

                /**
                 * The Boolean return value of the media query.
                 */
                queryMatches: {
                    type: Boolean,
                    value: false,
                    readOnly: true,
                    notify: true
                },

                /**
                 * The CSS media query to evaluate.
                 */
                query: {
                    type: String,
                    observer: 'queryChanged'
                },

                /**
                 * @type {function(MediaQueryList)}
                 */
                _boundMQHandler: {
                    value: function () {
                        return this.queryHandler.bind(this);
                    }
                },

                /**
                 * @type {MediaQueryList}
                 */
                _mq: {
                    value: null
                }
            },

            attached: function () {
                this.queryChanged();
            },

            detached: function () {
                this._remove();
            },

            _add: function () {
                if (this._mq) {
                    this._mq.addListener(this._boundMQHandler);
                }
            },

            _remove: function () {
                if (this._mq) {
                    this._mq.removeListener(this._boundMQHandler);
                }
                this._mq = null;
            },

            queryChanged: function () {
                this._remove();
                var query = this.query;
                if (!query) {
                    return;
                }
                if (query[0] !== '(') {
                    query = '(' + query + ')';
                }
                this._mq = window.matchMedia(query);
                this._add();
                this.queryHandler(this._mq);
            },

            queryHandler: function (mq) {
                this._setQueryMatches(mq.matches);
            }

        });

    </script>
    <script>
        /**
         `iron-selector` is an element which can be used to manage a list of elements
         that can be selected.  Tapping on the item will make the item selected.  The `selected` indicates
         which item is being selected.  The default is to use the index of the item.

         Example:

         <iron-selector selected="0">
         <div>Item 1</div>
         <div>Item 2</div>
         <div>Item 3</div>
         </iron-selector>

         If you want to use the attribute value of an element for `selected` instead of the index,
         set `attrForSelected` to the name of the attribute.  For example, if you want to select item by
         `name`, set `attrForSelected` to `name`.

         Example:

         <iron-selector attr-for-selected="name" selected="foo">
         <div name="foo">Foo</div>
         <div name="bar">Bar</div>
         <div name="zot">Zot</div>
         </iron-selector>

         `iron-selector` is not styled. Use the `iron-selected` CSS class to style the selected element.

         Example:

         <style>
         .iron-selected {
          background: #eee;
        }
         </style>

         ...

         <iron-selector selected="0">
         <div>Item 1</div>
         <div>Item 2</div>
         <div>Item 3</div>
         </iron-selector>

         @demo demo/index.html
         */

        Polymer({

            is: 'iron-selector',

            behaviors: [
                Polymer.IronMultiSelectableBehavior
            ]

        });

    </script>
    <!--
`paper-drawer-panel` contains a drawer panel and a main panel.  The drawer
and the main panel are side-by-side with drawer on the left.  When the browser
window size is smaller than the `responsiveWidth`, `paper-drawer-panel`
changes to narrow layout.  In narrow layout, the drawer will be stacked on top
of the main panel.  The drawer will slide in/out to hide/reveal the main
panel.

Use the attribute `drawer` to indicate that the element is the drawer panel and
`main` to indicate that the element is the main panel.

Example:

    <paper-drawer-panel>
      <div drawer> Drawer panel... </div>
      <div main> Main panel... </div>
    </paper-drawer-panel>

The drawer and the main panels are not scrollable.  You can set CSS overflow
property on the elements to make them scrollable or use `paper-header-panel`.

Example:

    <paper-drawer-panel>
      <paper-header-panel drawer>
        <paper-toolbar></paper-toolbar>
        <div> Drawer content... </div>
      </paper-header-panel>
      <paper-header-panel main>
        <paper-toolbar></paper-toolbar>
        <div> Main content... </div>
      </paper-header-panel>
    </paper-drawer-panel>

An element that should toggle the drawer will automatically do so if it's
given the `paper-drawer-toggle` attribute.  Also this element will automatically
be hidden in wide layout.

Example:

    <paper-drawer-panel>
      <paper-header-panel drawer>
        <paper-toolbar>
          <div>Application</div>
        </paper-toolbar>
        <div> Drawer content... </div>
      </paper-header-panel>
      <paper-header-panel main>
        <paper-toolbar>
          <paper-icon-button icon="menu" paper-drawer-toggle></paper-icon-button>
          <div>Title</div>
        </paper-toolbar>
        <div> Main content... </div>
      </paper-header-panel>
    </paper-drawer-panel>

To position the drawer to the right, add `right-drawer` attribute.

    <paper-drawer-panel right-drawer>
      <div drawer> Drawer panel... </div>
      <div main> Main panel... </div>
    </paper-drawer-panel>

Styling `paper-drawer-panel`

To change the main container:

    paper-drawer-panel {
      --paper-drawer-panel-main-container: {
        background-color: gray;
      };
    }

To change the drawer container when it's in the left side:

    paper-drawer-panel {
      --paper-drawer-panel-left-drawer-container: {
        background-color: white;
      };
    }

To change the drawer container when it's in the right side:

    paper-drawer-panel {
      --paper-drawer-panel-right-drawer-container: {
        background-color: white;
      };
    }

@group Paper elements
@element paper-drawer-panel
@demo demo/index.html
@hero hero.svg
-->

</head>
<body>
<div hidden="" by-vulcanize="">
    <dom-module id="paper-header-panel" assetpath="../components/paper-header-panel/">

        <style>
            /**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE
The complete set of authors may be found at http://polymer.github.io/AUTHORS
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS
*/

            :host {
                --paper-header-panel-shadow: {
                    height: 6px;
                    bottom: -6px;
                    box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
                };

                @apply(--layout-vertical);

                position: relative;
                height: 100%;
            }

            #mainContainer {
                @apply(--layout-flex);

                position: relative;
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
            }

            #mainPanel {
                @apply(--layout-vertical);
                @apply(--layout-flex);

                position: relative;
            }

            /*
 * mode: scroll
 */
            :host([mode=scroll]) #mainContainer {
                @apply(--paper-header-panel-scroll-container);

                overflow: visible;
            }

            :host([mode=scroll]) {
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
            }

            /*
 * mode: cover
 */
            :host([mode=cover]) #mainContainer {
                @apply(--paper-header-panel-cover-container);

                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;
            }

            :host([mode=cover]) #mainPanel {
                position: static;
            }

            /*
 * mode: standard
 */
            :host([mode=standard]) #mainContainer {
                @apply(--paper-header-panel-standard-container);
            }

            /*
 * mode: seamed
 */
            :host([mode=seamed]) #mainContainer {
                @apply(--paper-header-panel-seamed-container);
            }

            /*
 * mode: waterfall
 */
            :host([mode=waterfall]) #mainContainer {
                @apply(--paper-header-panel-waterfall-container);
            }

            /*
 * mode: waterfall-tall
 */
            :host([mode=waterfall-tall]) #mainContainer {
                @apply(--paper-header-panel-waterfall-tall-container);
            }

            #dropShadow {
                @apply(--paper-header-panel-shadow);

                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 6px;
                pointer-events: none;

                -webkit-transition: opacity 0.5s;
                transition: opacity 0.5s;

                opacity: 0;
            }

            #dropShadow.has-shadow {
                opacity: 1;
            }

        </style>

        <template>
            <content id="headerContent" select="paper-toolbar, .paper-header"></content>

            <div id="mainPanel">
                <div id="mainContainer" class$="[[_computeMainContainerClass(mode)]]">
                    <content id="mainContent" select="*"></content>
                </div>
                <div id="dropShadow"></div>
            </div>
        </template>

    </dom-module>

    <script>

        (function () {

            'use strict';

            var SHADOW_WHEN_SCROLLING = 1;
            var SHADOW_ALWAYS = 2;


            var MODE_CONFIGS = {

                outerScroll: {
                    'scroll': true
                },

                shadowMode: {
                    'standard': SHADOW_ALWAYS,
                    'waterfall': SHADOW_WHEN_SCROLLING,
                    'waterfall-tall': SHADOW_WHEN_SCROLLING
                },

                tallMode: {
                    'waterfall-tall': true
                }
            };

            Polymer({

                is: 'paper-header-panel',

                /**
                 * Fired when the content has been scrolled.  `event.detail.target` returns
                 * the scrollable element which you can use to access scroll info such as
                 * `scrollTop`.
                 *
                 *     <paper-header-panel on-content-scroll="scrollHandler">
                 *       ...
                 *     </paper-header-panel>
                 *
                 *
                 *     scrollHandler: function(event) {
       *       var scroller = event.detail.target;
       *       console.log(scroller.scrollTop);
       *     }
                 *
                 * @event content-scroll
                 */

                properties: {

                    /**
                     * Controls header and scrolling behavior. Options are
                     * `standard`, `seamed`, `waterfall`, `waterfall-tall`, `scroll` and
                     * `cover`. Default is `standard`.
                     *
                     * `standard`: The header is a step above the panel. The header will consume the
                     * panel at the point of entry, preventing it from passing through to the
                     * opposite side.
                     *
                     * `seamed`: The header is presented as seamed with the panel.
                     *
                     * `waterfall`: Similar to standard mode, but header is initially presented as
                     * seamed with panel, but then separates to form the step.
                     *
                     * `waterfall-tall`: The header is initially taller (`tall` class is added to
                     * the header).  As the user scrolls, the header separates (forming an edge)
                     * while condensing (`tall` class is removed from the header).
                     *
                     * `scroll`: The header keeps its seam with the panel, and is pushed off screen.
                     *
                     * `cover`: The panel covers the whole `paper-header-panel` including the
                     * header. This allows user to style the panel in such a way that the panel is
                     * partially covering the header.
                     *
                     *     <paper-header-panel mode="cover">
                     *       <paper-toolbar class="tall">
                     *         <core-icon-button icon="menu"></core-icon-button>
                     *       </paper-toolbar>
                     *       <div class="content"></div>
                     *     </paper-header-panel>
                     */
                    mode: {
                        type: String,
                        value: 'standard',
                        observer: '_modeChanged',
                        reflectToAttribute: true
                    },

                    /**
                     * If true, the drop-shadow is always shown no matter what mode is set to.
                     */
                    shadow: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * The class used in waterfall-tall mode.  Change this if the header
                     * accepts a different class for toggling height, e.g. "medium-tall"
                     */
                    tallClass: {
                        type: String,
                        value: 'tall'
                    },

                    /**
                     * If true, the scroller is at the top
                     */
                    atTop: {
                        type: Boolean,
                        value: true,
                        readOnly: true
                    }
                },

                observers: [
                    '_computeDropShadowHidden(atTop, mode, shadow)'
                ],

                ready: function () {
                    this.scrollHandler = this._scroll.bind(this);
                    this._addListener();

                    // Run `scroll` logic once to initialze class names, etc.
                    this._keepScrollingState();
                },

                detached: function () {
                    this._removeListener();
                },

                /**
                 * Returns the header element
                 *
                 * @property header
                 * @type Object
                 */
                get header() {
                    return Polymer.dom(this.$.headerContent).getDistributedNodes()[0];
                },

                /**
                 * Returns the scrollable element.
                 *
                 * @property scroller
                 * @type Object
                 */
                get scroller() {
                    return this._getScrollerForMode(this.mode);
                },

                /**
                 * Returns true if the scroller has a visible shadow.
                 *
                 * @property visibleShadow
                 * @type Boolean
                 */
                get visibleShadow() {
                    return this.$.dropShadow.classList.contains('has-shadow');
                },

                _computeDropShadowHidden: function (atTop, mode, shadow) {

                    var shadowMode = MODE_CONFIGS.shadowMode[mode];

                    if (this.shadow) {
                        this.toggleClass('has-shadow', true, this.$.dropShadow);

                    } else if (shadowMode === SHADOW_ALWAYS) {
                        this.toggleClass('has-shadow', true, this.$.dropShadow);

                    } else if (shadowMode === SHADOW_WHEN_SCROLLING && !atTop) {
                        this.toggleClass('has-shadow', true, this.$.dropShadow);

                    } else {
                        this.toggleClass('has-shadow', false, this.$.dropShadow);

                    }
                },

                _computeMainContainerClass: function (mode) {
                    // TODO:  It will be useful to have a utility for classes
                    // e.g. Polymer.Utils.classes({ foo: true });

                    var classes = {};

                    classes['flex'] = mode !== 'cover';

                    return Object.keys(classes).filter(
                            function (className) {
                                return classes[className];
                            }).join(' ');
                },

                _addListener: function () {
                    this.scroller.addEventListener('scroll', this.scrollHandler, false);
                },

                _removeListener: function () {
                    this.scroller.removeEventListener('scroll', this.scrollHandler);
                },

                _modeChanged: function (newMode, oldMode) {
                    var configs = MODE_CONFIGS;
                    var header = this.header;
                    var animateDuration = 200;

                    if (header) {
                        // in tallMode it may add tallClass to the header; so do the cleanup
                        // when mode is changed from tallMode to not tallMode
                        if (configs.tallMode[oldMode] && !configs.tallMode[newMode]) {
                            header.classList.remove(this.tallClass);
                            this.async(function () {
                                header.classList.remove('animate');
                            }, animateDuration);
                        } else {
                            header.classList.toggle('animate', configs.tallMode[newMode]);
                        }
                    }
                    this._keepScrollingState();
                },

                _keepScrollingState: function () {
                    var main = this.scroller;
                    var header = this.header;

                    this._setAtTop(main.scrollTop === 0);

                    if (header && this.tallClass && MODE_CONFIGS.tallMode[this.mode]) {
                        this.toggleClass(this.tallClass, this.atTop ||
                                header.classList.contains(this.tallClass) &&
                                main.scrollHeight < this.offsetHeight, header);
                    }
                },

                _scroll: function () {
                    this._keepScrollingState();
                    this.fire('content-scroll', {target: this.scroller}, {bubbles: false});
                },

                _getScrollerForMode: function (mode) {
                    return MODE_CONFIGS.outerScroll[mode] ?
                            this : this.$.mainContainer;
                }

            });

        })();

    </script>
    <dom-module id="paper-toolbar" assetpath="../components/paper-toolbar/">

        <style>
            :host {
                /* technical */
                display: block;
                position: relative;
                box-sizing: border-box;
                -moz-box-sizing: border-box;

                /* size */
                height: 64px;

                background: var(--paper-toolbar-background, --default-primary-color);
                color: var(--paper-toolbar-color, --text-primary-color);

                @apply(--paper-toolbar);
            }

            :host(.animate) {
                /* transition */
                transition: height 0.18s ease-in;
            }

            :host(.medium-tall) {
                height: 128px;
            }

            :host(.tall) {
                height: 192px;
            }

            .toolbar-tools {
                position: relative;
                height: 64px;
                padding: 0 16px;
                pointer-events: none;
            }

            /*
     * TODO: Where should media query breakpoints live so they can be shared between elements?
     */

            @media (max-width: 639px) {
                :host {
                    height: 56px;
                }

                :host(.medium-tall) {
                    height: 112px;
                }

                :host(.tall) {
                    height: 168px;
                }

                .toolbar-tools {
                    height: 56px;
                }
            }

            #topBar {
                position: relative;
            }

            /* middle bar */
            #middleBar {
                position: absolute;
                top: 0;
                right: 0;
                left: 0;
            }

            :host(.tall) #middleBar,
            :host(.medium-tall) #middleBar {
                -webkit-transform: translateY(100%);
                transform: translateY(100%);
            }

            /* bottom bar */
            #bottomBar {
                position: absolute;
                right: 0;
                bottom: 0;
                left: 0;
            }

            /*
     * make elements (e.g. buttons) respond to mouse/touch events
     *
     * `.toolbar-tools` disables touch events so multiple toolbars can stack and not
     * absorb events. All children must have pointer events re-enabled to work as
     * expected.
     */
            .toolbar-tools > ::content > *:not([disabled]) {
                pointer-events: auto;
            }

            .toolbar-tools > ::content .title {
                @apply(--paper-font-title);
                @apply(--layout-flex);

                pointer-events: none;
                text-overflow: ellipsis;
                white-space: nowrap;
                overflow: hidden;

                /*
       * Polymer/polymer/issues/1525
       * --paper-font-title defines a `font-weight`
       * let's override its value, but we need `important!`
       * because all mixins are resolved in rule's selector that has higher precedence
       * than the current selector.
       */
                font-weight: 400 !important;
            }

            /**
     * TODO: Refactor these selectors
     * Work in progress.
     */
            .toolbar-tools > ::content paper-icon-button[icon=menu] {
                margin-right: 24px;
            }

            .toolbar-tools > ::content > .title,
            .toolbar-tools > ::content[select=".middle"] > .title,
            .toolbar-tools > ::content[select=".bottom"] > .title {
                margin-left: 56px;
            }

            .toolbar-tools > ::content > paper-icon-button + .title,
            .toolbar-tools > ::content[select=".middle"] paper-icon-button + .title,
            .toolbar-tools > ::content[select=".bottom"] paper-icon-button + .title {
                margin-left: 0;
            }

            .toolbar-tools > ::content > .fit {
                position: absolute;
                top: auto;
                right: 0;
                bottom: 0;
                left: 0;
                width: auto;
                margin: 0;
            }

        </style>

        <template>

            <div id="topBar" class$="[[_computeBarClassName(justify)]]">
                <content select=":not(.middle):not(.bottom)"></content>
            </div>

            <div id="middleBar" class$="[[_computeBarClassName(middleJustify)]]">
                <content select=".middle"></content>
            </div>

            <div id="bottomBar" class$="[[_computeBarClassName(bottomJustify)]]">
                <content select=".bottom"></content>
            </div>

        </template>

    </dom-module>

    <script>

        (function () {

            'use strict';

            function classNames(obj) {
                var classNames = [];
                for (var key in obj) {
                    if (obj.hasOwnProperty(key) && obj[key]) {
                        classNames.push(key);
                    }
                }

                return classNames.join(' ');
            }

            Polymer({

                is: 'paper-toolbar',

                hostAttributes: {
                    'role': 'toolbar'
                },

                properties: {

                    /**
                     * Controls how the items are aligned horizontally when they are placed
                     * at the bottom.
                     * Options are `start`, `center`, `end`, `justified` and `around`.
                     *
                     * @attribute bottomJustify
                     * @type string
                     * @default ''
                     */
                    bottomJustify: {
                        type: String,
                        value: ''
                    },

                    /**
                     * Controls how the items are aligned horizontally.
                     * Options are `start`, `center`, `end`, `justified` and `around`.
                     *
                     * @attribute justify
                     * @type string
                     * @default ''
                     */
                    justify: {
                        type: String,
                        value: ''
                    },

                    /**
                     * Controls how the items are aligned horizontally when they are placed
                     * in the middle.
                     * Options are `start`, `center`, `end`, `justified` and `around`.
                     *
                     * @attribute middleJustify
                     * @type string
                     * @default ''
                     */
                    middleJustify: {
                        type: String,
                        value: ''
                    }

                },

                attached: function () {
                    this._observer = this._observe(this);
                    this._updateAriaLabelledBy();
                },

                detached: function () {
                    if (this._observer) {
                        this._observer.disconnect();
                    }
                },

                _observe: function (node) {
                    var observer = new MutationObserver(function () {
                        this._updateAriaLabelledBy();
                    }.bind(this));
                    observer.observe(node, {
                        childList: true,
                        subtree: true
                    });
                    return observer;
                },

                _updateAriaLabelledBy: function () {
                    var labelledBy = [];
                    var contents = Polymer.dom(this.root).querySelectorAll('content');
                    for (var content, index = 0; content = contents[index]; index++) {
                        var nodes = Polymer.dom(content).getDistributedNodes();
                        for (var node, jndex = 0; node = nodes[jndex]; jndex++) {
                            if (node.classList && node.classList.contains('title')) {
                                if (node.id) {
                                    labelledBy.push(node.id);
                                } else {
                                    var id = 'paper-toolbar-label-' + Math.floor(Math.random() * 10000);
                                    node.id = id;
                                    labelledBy.push(id);
                                }
                            }
                        }
                    }
                    if (labelledBy.length > 0) {
                        this.setAttribute('aria-labelledby', labelledBy.join(' '));
                    }
                },

                _computeBarClassName: function (barJustify) {
                    var classObj = {
                        'center': true,
                        'horizontal': true,
                        'layout': true,
                        'toolbar-tools': true
                    };

                    // If a blank string or any falsy value is given, no other class name is
                    // added.
                    if (barJustify) {
                        var justifyClassName = (barJustify === 'justified') ?
                                barJustify :
                        barJustify + '-justified';

                        classObj[justifyClassName] = true;
                    }

                    return classNames(classObj);
                }

            });

        }());

    </script>
    <dom-module id="iron-icon" assetpath="../components/iron-icon/">

        <style>
            :host {
                @apply(--layout-inline);
                @apply(--layout-center-center);
                position: relative;

                vertical-align: middle;

                fill: var(--iron-icon-fill-color, currentcolor);
                stroke: var(--iron-icon-stroke-color, none);

                width: var(--iron-icon-width, 24px);
                height: var(--iron-icon-height, 24px);
            }
        </style>

        <template>
        </template>

        <script>

            Polymer({

                is: 'iron-icon',

                properties: {

                    /**
                     * The name of the icon to use. The name should be of the form:
                     * `iconset_name:icon_name`.
                     */
                    icon: {
                        type: String,
                        observer: '_iconChanged'
                    },

                    /**
                     * The name of the theme to used, if one is specified by the
                     * iconset.
                     */
                    theme: {
                        type: String,
                        observer: '_updateIcon'
                    },

                    /**
                     * If using iron-icon without an iconset, you can set the src to be
                     * the URL of an individual icon image file. Note that this will take
                     * precedence over a given icon attribute.
                     */
                    src: {
                        type: String,
                        observer: '_srcChanged'
                    },

                    /**
                     * @type {!Polymer.IronMeta}
                     */
                    _meta: {
                        value: Polymer.Base.create('iron-meta', {type: 'iconset'})
                    }

                },

                _DEFAULT_ICONSET: 'icons',

                _iconChanged: function (icon) {
                    var parts = (icon || '').split(':');
                    this._iconName = parts.pop();
                    this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
                    this._updateIcon();
                },

                _srcChanged: function (src) {
                    this._updateIcon();
                },

                _usesIconset: function () {
                    return this.icon || !this.src;
                },

                /** @suppress {visibility} */
                _updateIcon: function () {
                    if (this._usesIconset()) {
                        if (this._iconsetName) {
                            this._iconset = /** @type {?Polymer.Iconset} */ (
                                    this._meta.byKey(this._iconsetName));
                            if (this._iconset) {
                                this._iconset.applyIcon(this, this._iconName, this.theme);
                                this.unlisten(window, 'iron-iconset-added', '_updateIcon');
                            } else {
                                this.listen(window, 'iron-iconset-added', '_updateIcon');
                            }
                        }
                    } else {
                        if (!this._img) {
                            this._img = document.createElement('img');
                            this._img.style.width = '100%';
                            this._img.style.height = '100%';
                            this._img.draggable = false;
                        }
                        this._img.src = this.src;
                        Polymer.dom(this.root).appendChild(this._img);
                    }
                }

            });

        </script>

    </dom-module>
    <dom-module id="paper-ripple" assetpath="../components/paper-ripple/">

        <!--
  Fired when the animation finishes. This is useful if you want to wait until the ripple
  animation finishes to perform some action.

  @event transitionend
  @param {Object} detail
  @param {Object} detail.node The animated node
  -->

        <template>
            <style>
                :host {
                    display: block;
                    position: absolute;
                    border-radius: inherit;
                    overflow: hidden;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;

                    /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,
         * creating a node (with a position:absolute) in the middle of an event
         * handler "interrupts" that event handler (which happens when the
         * ripple is created on demand) */
                    pointer-events: none;
                }

                :host([animating]) {
                    /* This resolves a rendering issue in Chrome (as of 40) where the
           ripple is not properly clipped by its parent (which may have
           rounded corners). See: http://jsbin.com/temexa/4

           Note: We only apply this style conditionally. Otherwise, the browser
           will create a new compositing layer for every ripple element on the
           page, and that would be bad. */
                    -webkit-transform: translate(0, 0);
                    transform: translate3d(0, 0, 0);
                }

                :host([noink]) {
                    pointer-events: none;
                }

                #background,
                #waves,
                .wave-container,
                .wave {
                    pointer-events: none;
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                }

                #background,
                .wave {
                    opacity: 0;
                }

                #waves,
                .wave {
                    overflow: hidden;
                }

                .wave-container,
                .wave {
                    border-radius: 50%;
                }

                :host(.circle) #background,
                :host(.circle) #waves {
                    border-radius: 50%;
                }

                :host(.circle) .wave-container {
                    overflow: hidden;
                }
            </style>

            <div id="background"></div>
            <div id="waves"></div>
        </template>
    </dom-module>
    <script>
        (function () {
            var Utility = {
                distance: function (x1, y1, x2, y2) {
                    var xDelta = (x1 - x2);
                    var yDelta = (y1 - y2);

                    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
                },

                now: window.performance && window.performance.now ?
                        window.performance.now.bind(window.performance) : Date.now
            };

            /**
             * @param {HTMLElement} element
             * @constructor
             */
            function ElementMetrics(element) {
                this.element = element;
                this.width = this.boundingRect.width;
                this.height = this.boundingRect.height;

                this.size = Math.max(this.width, this.height);
            }

            ElementMetrics.prototype = {
                get boundingRect() {
                    return this.element.getBoundingClientRect();
                },

                furthestCornerDistanceFrom: function (x, y) {
                    var topLeft = Utility.distance(x, y, 0, 0);
                    var topRight = Utility.distance(x, y, this.width, 0);
                    var bottomLeft = Utility.distance(x, y, 0, this.height);
                    var bottomRight = Utility.distance(x, y, this.width, this.height);

                    return Math.max(topLeft, topRight, bottomLeft, bottomRight);
                }
            };

            /**
             * @param {HTMLElement} element
             * @constructor
             */
            function Ripple(element) {
                this.element = element;
                this.color = window.getComputedStyle(element).color;

                this.wave = document.createElement('div');
                this.waveContainer = document.createElement('div');
                this.wave.style.backgroundColor = this.color;
                this.wave.classList.add('wave');
                this.waveContainer.classList.add('wave-container');
                Polymer.dom(this.waveContainer).appendChild(this.wave);

                this.resetInteractionState();
            }

            Ripple.MAX_RADIUS = 300;

            Ripple.prototype = {
                get recenters() {
                    return this.element.recenters;
                },

                get center() {
                    return this.element.center;
                },

                get mouseDownElapsed() {
                    var elapsed;

                    if (!this.mouseDownStart) {
                        return 0;
                    }

                    elapsed = Utility.now() - this.mouseDownStart;

                    if (this.mouseUpStart) {
                        elapsed -= this.mouseUpElapsed;
                    }

                    return elapsed;
                },

                get mouseUpElapsed() {
                    return this.mouseUpStart ?
                    Utility.now () - this.mouseUpStart : 0;
                },

                get mouseDownElapsedSeconds() {
                    return this.mouseDownElapsed / 1000;
                },

                get mouseUpElapsedSeconds() {
                    return this.mouseUpElapsed / 1000;
                },

                get mouseInteractionSeconds() {
                    return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
                },

                get initialOpacity() {
                    return this.element.initialOpacity;
                },

                get opacityDecayVelocity() {
                    return this.element.opacityDecayVelocity;
                },

                get radius() {
                    var width2 = this.containerMetrics.width * this.containerMetrics.width;
                    var height2 = this.containerMetrics.height * this.containerMetrics.height;
                    var waveRadius = Math.min(
                                    Math.sqrt(width2 + height2),
                                    Ripple.MAX_RADIUS
                            ) * 1.1 + 5;

                    var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
                    var timeNow = this.mouseInteractionSeconds / duration;
                    var size = waveRadius * (1 - Math.pow(80, -timeNow));

                    return Math.abs(size);
                },

                get opacity() {
                    if (!this.mouseUpStart) {
                        return this.initialOpacity;
                    }

                    return Math.max(
                            0,
                            this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity
                    );
                },

                get outerOpacity() {
                    // Linear increase in background opacity, capped at the opacity
                    // of the wavefront (waveOpacity).
                    var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
                    var waveOpacity = this.opacity;

                    return Math.max(
                            0,
                            Math.min(outerOpacity, waveOpacity)
                    );
                },

                get isOpacityFullyDecayed() {
                    return this.opacity < 0.01 &&
                            this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
                },

                get isRestingAtMaxRadius() {
                    return this.opacity >= this.initialOpacity &&
                            this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
                },

                get isAnimationComplete() {
                    return this.mouseUpStart ?
                            this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
                },

                get translationFraction() {
                    return Math.min(
                            1,
                            this.radius / this.containerMetrics.size * 2 / Math.sqrt(2)
                    );
                },

                get xNow() {
                    if (this.xEnd) {
                        return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
                    }

                    return this.xStart;
                },

                get yNow() {
                    if (this.yEnd) {
                        return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
                    }

                    return this.yStart;
                },

                get isMouseDown() {
                    return this.mouseDownStart && !this.mouseUpStart;
                },

                resetInteractionState: function () {
                    this.maxRadius = 0;
                    this.mouseDownStart = 0;
                    this.mouseUpStart = 0;

                    this.xStart = 0;
                    this.yStart = 0;
                    this.xEnd = 0;
                    this.yEnd = 0;
                    this.slideDistance = 0;

                    this.containerMetrics = new ElementMetrics(this.element);
                },

                draw: function () {
                    var scale;
                    var translateString;
                    var dx;
                    var dy;

                    this.wave.style.opacity = this.opacity;

                    scale = this.radius / (this.containerMetrics.size / 2);
                    dx = this.xNow - (this.containerMetrics.width / 2);
                    dy = this.yNow - (this.containerMetrics.height / 2);


                    // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
                    // https://bugs.webkit.org/show_bug.cgi?id=98538
                    this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
                    this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
                    this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
                    this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
                },

                /** @param {Event=} event */
                downAction: function (event) {
                    var xCenter = this.containerMetrics.width / 2;
                    var yCenter = this.containerMetrics.height / 2;

                    this.resetInteractionState();
                    this.mouseDownStart = Utility.now();

                    if (this.center) {
                        this.xStart = xCenter;
                        this.yStart = yCenter;
                        this.slideDistance = Utility.distance(
                                this.xStart, this.yStart, this.xEnd, this.yEnd
                        );
                    } else {
                        this.xStart = event ?
                        event.detail.x - this.containerMetrics.boundingRect.left :
                        this.containerMetrics.width / 2;
                        this.yStart = event ?
                        event.detail.y - this.containerMetrics.boundingRect.top :
                        this.containerMetrics.height / 2;
                    }

                    if (this.recenters) {
                        this.xEnd = xCenter;
                        this.yEnd = yCenter;
                        this.slideDistance = Utility.distance(
                                this.xStart, this.yStart, this.xEnd, this.yEnd
                        );
                    }

                    this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(
                            this.xStart,
                            this.yStart
                    );

                    this.waveContainer.style.top =
                            (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
                    this.waveContainer.style.left =
                            (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

                    this.waveContainer.style.width = this.containerMetrics.size + 'px';
                    this.waveContainer.style.height = this.containerMetrics.size + 'px';
                },

                /** @param {Event=} event */
                upAction: function (event) {
                    if (!this.isMouseDown) {
                        return;
                    }

                    this.mouseUpStart = Utility.now();
                },

                remove: function () {
                    Polymer.dom(this.waveContainer.parentNode).removeChild(
                            this.waveContainer
                    );
                }
            };

            Polymer({
                is: 'paper-ripple',

                behaviors: [
                    Polymer.IronA11yKeysBehavior
                ],

                properties: {
                    /**
                     * The initial opacity set on the wave.
                     *
                     * @attribute initialOpacity
                     * @type number
                     * @default 0.25
                     */
                    initialOpacity: {
                        type: Number,
                        value: 0.25
                    },

                    /**
                     * How fast (opacity per second) the wave fades out.
                     *
                     * @attribute opacityDecayVelocity
                     * @type number
                     * @default 0.8
                     */
                    opacityDecayVelocity: {
                        type: Number,
                        value: 0.8
                    },

                    /**
                     * If true, ripples will exhibit a gravitational pull towards
                     * the center of their container as they fade away.
                     *
                     * @attribute recenters
                     * @type boolean
                     * @default false
                     */
                    recenters: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * If true, ripples will center inside its container
                     *
                     * @attribute recenters
                     * @type boolean
                     * @default false
                     */
                    center: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * A list of the visual ripples.
                     *
                     * @attribute ripples
                     * @type Array
                     * @default []
                     */
                    ripples: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    /**
                     * True when there are visible ripples animating within the
                     * element.
                     */
                    animating: {
                        type: Boolean,
                        readOnly: true,
                        reflectToAttribute: true,
                        value: false
                    },

                    /**
                     * If true, the ripple will remain in the "down" state until `holdDown`
                     * is set to false again.
                     */
                    holdDown: {
                        type: Boolean,
                        value: false,
                        observer: '_holdDownChanged'
                    },

                    /**
                     * If true, the ripple will not generate a ripple effect
                     * via pointer interaction.
                     * Calling ripple's imperative api like `simulatedRipple` will
                     * still generate the ripple effect.
                     */
                    noink: {
                        type: Boolean,
                        value: false
                    },

                    _animating: {
                        type: Boolean
                    },

                    _boundAnimate: {
                        type: Function,
                        value: function () {
                            return this.animate.bind(this);
                        }
                    }
                },

                observers: [
                    '_noinkChanged(noink, isAttached)'
                ],

                get target() {
                    var ownerRoot = Polymer.dom(this).getOwnerRoot();
                    var target;

                    if (this.parentNode.nodeType == 11) { // DOCUMENT_FRAGMENT_NODE
                        target = ownerRoot.host;
                    } else {
                        target = this.parentNode;
                    }

                    return target;
                },

                keyBindings: {
                    'enter:keydown': '_onEnterKeydown',
                    'space:keydown': '_onSpaceKeydown',
                    'space:keyup': '_onSpaceKeyup'
                },

                attached: function () {
                    this.listen(this.target, 'up', 'uiUpAction');
                    this.listen(this.target, 'down', 'uiDownAction');
                },

                detached: function () {
                    this.unlisten(this.target, 'up', 'uiUpAction');
                    this.unlisten(this.target, 'down', 'uiDownAction');
                },

                get shouldKeepAnimating() {
                    for (var index = 0; index < this.ripples.length; ++index) {
                        if (!this.ripples[index].isAnimationComplete) {
                            return true;
                        }
                    }

                    return false;
                },

                simulatedRipple: function () {
                    this.downAction(null);

                    // Please see polymer/polymer#1305
                    this.async(function () {
                        this.upAction();
                    }, 1);
                },

                /**
                 * Provokes a ripple down effect via a UI event,
                 * respecting the `noink` property.
                 * @param {Event=} event
                 */
                uiDownAction: function (event) {
                    if (!this.noink) {
                        this.downAction(event);
                    }
                },

                /**
                 * Provokes a ripple down effect via a UI event,
                 * *not* respecting the `noink` property.
                 * @param {Event=} event
                 */
                downAction: function (event) {
                    if (this.holdDown && this.ripples.length > 0) {
                        return;
                    }

                    var ripple = this.addRipple();

                    ripple.downAction(event);

                    if (!this._animating) {
                        this.animate();
                    }
                },

                /**
                 * Provokes a ripple up effect via a UI event,
                 * respecting the `noink` property.
                 * @param {Event=} event
                 */
                uiUpAction: function (event) {
                    if (!this.noink) {
                        this.upAction(event);
                    }
                },

                /**
                 * Provokes a ripple up effect via a UI event,
                 * *not* respecting the `noink` property.
                 * @param {Event=} event
                 */
                upAction: function (event) {
                    if (this.holdDown) {
                        return;
                    }

                    this.ripples.forEach(function (ripple) {
                        ripple.upAction(event);
                    });

                    this.animate();
                },

                onAnimationComplete: function () {
                    this._animating = false;
                    this.$.background.style.backgroundColor = null;
                    this.fire('transitionend');
                },

                addRipple: function () {
                    var ripple = new Ripple(this);

                    Polymer.dom(this.$.waves).appendChild(ripple.waveContainer);
                    this.$.background.style.backgroundColor = ripple.color;
                    this.ripples.push(ripple);

                    this._setAnimating(true);

                    return ripple;
                },

                removeRipple: function (ripple) {
                    var rippleIndex = this.ripples.indexOf(ripple);

                    if (rippleIndex < 0) {
                        return;
                    }

                    this.ripples.splice(rippleIndex, 1);

                    ripple.remove();

                    if (!this.ripples.length) {
                        this._setAnimating(false);
                    }
                },

                animate: function () {
                    var index;
                    var ripple;

                    this._animating = true;

                    for (index = 0; index < this.ripples.length; ++index) {
                        ripple = this.ripples[index];

                        ripple.draw();

                        this.$.background.style.opacity = ripple.outerOpacity;

                        if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
                            this.removeRipple(ripple);
                        }
                    }

                    if (!this.shouldKeepAnimating && this.ripples.length === 0) {
                        this.onAnimationComplete();
                    } else {
                        window.requestAnimationFrame(this._boundAnimate);
                    }
                },

                _onEnterKeydown: function () {
                    this.uiDownAction();
                    this.async(this.uiUpAction, 1);
                },

                _onSpaceKeydown: function () {
                    this.uiDownAction();
                },

                _onSpaceKeyup: function () {
                    this.uiUpAction();
                },

                // note: holdDown does not respect noink since it can be a focus based
                // effect.
                _holdDownChanged: function (newVal, oldVal) {
                    if (oldVal === undefined) {
                        return;
                    }
                    if (newVal) {
                        this.downAction();
                    } else {
                        this.upAction();
                    }
                },

                _noinkChanged: function (noink, attached) {
                    if (attached) {
                        this.keyEventTarget = noink ? this : this.target;
                    }
                }
            });
        })();
    </script>
    <dom-module id="paper-icon-button" assetpath="../components/paper-icon-button/">
        <template strip-whitespace="">
            <style>
                :host {
                    display: inline-block;
                    position: relative;
                    padding: 8px;
                    outline: none;
                    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                    -webkit-user-select: none;
                    -moz-user-select: none;
                    -ms-user-select: none;
                    user-select: none;
                    cursor: pointer;
                    z-index: 0;
                    line-height: 1;

                    width: 40px;
                    height: 40px;

                    /* Because of polymer/2558, this style has lower specificity than * */
                    box-sizing: border-box !important;
                    @apply(--paper-icon-button);
                }

                :host #ink {
                    color: var(--paper-icon-button-ink-color, --primary-text-color);
                    opacity: 0.6;
                }

                :host([disabled]) {
                    color: var(--paper-icon-button-disabled-text, --disabled-text-color);
                    pointer-events: none;
                    cursor: auto;
                    @apply(--paper-icon-button-disabled);
                }

                iron-icon {
                    --iron-icon-width: 100%;
                    --iron-icon-height: 100%;
                }
            </style>
            <iron-icon id="icon" src="[[src]]" icon="[[icon]]" alt$="[[alt]]"></iron-icon>
        </template>

        <script>
            Polymer({
                is: 'paper-icon-button',

                hostAttributes: {
                    role: 'button',
                    tabindex: '0'
                },

                behaviors: [
                    Polymer.PaperInkyFocusBehavior
                ],

                properties: {
                    /**
                     * The URL of an image for the icon. If the src property is specified,
                     * the icon property should not be.
                     */
                    src: {
                        type: String
                    },

                    /**
                     * Specifies the icon name or index in the set of icons available in
                     * the icon's icon set. If the icon property is specified,
                     * the src property should not be.
                     */
                    icon: {
                        type: String
                    },

                    /**
                     * Specifies the alternate text for the button, for accessibility.
                     */
                    alt: {
                        type: String,
                        observer: "_altChanged"
                    }
                },

                _altChanged: function (newValue, oldValue) {
                    var label = this.getAttribute('aria-label');

                    // Don't stomp over a user-set aria-label.
                    if (!label || oldValue == label) {
                        this.setAttribute('aria-label', newValue);
                    }
                }
            });
        </script>
    </dom-module>
    <iron-iconset-svg name="paper-tabs" size="24">
        <svg>
            <defs>
                <g id="chevron-left">
                    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path>
                </g>
                <g id="chevron-right">
                    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path>
                </g>
            </defs>
        </svg>
    </iron-iconset-svg>
    <dom-module id="paper-tab" assetpath="../components/paper-tabs/">

        <style>

            :host {
                @apply(--layout-inline);
                @apply(--layout-center);
                @apply(--layout-center-justified);
                @apply(--layout-flex);

                position: relative;
                padding: 0 12px;
                overflow: hidden;
                cursor: pointer;

                @apply(--paper-tab);
            }

            :host(:focus) {
                outline: none;
            }

            :host([link]) {
                padding: 0;
            }

            .tab-content {
                height: 100%;
                -webkit-transform: translateZ(0);
                transform: translateZ(0);
                transition: opacity 0.1s cubic-bezier(0.4, 0.0, 1, 1);

                @apply(--paper-tab-content);
            }

            :host(:not(.iron-selected)) > .tab-content {
                opacity: 0.8;
            }

            :host(:focus) .tab-content {
                opacity: 1;
                font-weight: 700;
            }

            #ink {
                color: var(--paper-tab-ink, --paper-yellow-a100);
                pointer-events: none;
            }

            .tab-content > ::content > a {
                height: 100%;
                /* flex */
                -ms-flex: 1 1 0.000000001px;
                -webkit-flex: 1;
                flex: 1;
                -webkit-flex-basis: 0.000000001px;
                flex-basis: 0.000000001px;
            }

        </style>

        <template>

            <div class="tab-content flex-auto center-center horizontal layout">
                <content></content>
            </div>

            <template is="dom-if" if="[[!noink]]">
                <paper-ripple id="ink" initial-opacity="0.95" opacity-decay-velocity="0.98"></paper-ripple>
            </template>

        </template>

    </dom-module>

    <script>

        Polymer({

            is: 'paper-tab',

            behaviors: [
                Polymer.IronControlState,
                Polymer.IronButtonState
            ],

            properties: {

                /**
                 * If true, ink ripple effect is disabled.
                 *
                 * @attribute noink
                 */
                noink: {
                    type: Boolean,
                    value: false
                }

            },

            hostAttributes: {
                role: 'tab'
            },

            listeners: {
                down: '_updateNoink'
            },

            attached: function () {
                this._updateNoink();
            },

            get _parentNoink() {
                var parent = Polymer.dom(this).parentNode;
                return !!parent && !!parent.noink;
            },

            _updateNoink: function () {
                this.noink = !!this.noink || !!this._parentNoink;
            }
        });

    </script>
    <dom-module id="paper-tabs" assetpath="../components/paper-tabs/">

        <style>

            :host {
                @apply(--layout);
                @apply(--layout-center);

                height: 48px;
                font-size: 14px;
                font-weight: 500;
                overflow: hidden;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0);

                @apply(--paper-tabs);
            }

            #tabsContainer {
                position: relative;
                height: 100%;
                white-space: nowrap;
                overflow: hidden;
            }

            #tabsContent {
                height: 100%;
            }

            #tabsContent.scrollable {
                position: absolute;
                white-space: nowrap;
            }

            .hidden {
                display: none;
            }

            .not-visible {
                opacity: 0;
                cursor: default;
            }

            paper-icon-button {
                width: 24px;
                padding: 16px;
            }

            #selectionBar {
                position: absolute;
                height: 2px;
                bottom: 0;
                left: 0;
                right: 0;
                background-color: var(--paper-tabs-selection-bar-color, --paper-yellow-a100);
                -webkit-transform-origin: left center;
                transform-origin: left center;
                -webkit-transform: scale(0);
                transform: scale(0);
                transition: -webkit-transform;
                transition: transform;

                @apply(--paper-tabs-selection-bar);
            }

            #selectionBar.align-bottom {
                top: 0;
                bottom: auto;
            }

            #selectionBar.expand {
                transition-duration: 0.15s;
                transition-timing-function: cubic-bezier(0.4, 0.0, 1, 1);
            }

            #selectionBar.contract {
                transition-duration: 0.18s;
                transition-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);
            }

            #tabsContent > ::content > *:not(#selectionBar) {
                height: 100%;
            }

        </style>

        <template>

            <paper-icon-button icon="paper-tabs:chevron-left"
                               class$="[[_computeScrollButtonClass(_leftHidden, scrollable, hideScrollButtons)]]"
                               on-up="_onScrollButtonUp" on-down="_onLeftScrollButtonDown"
                               tabindex="-1"></paper-icon-button>

            <div id="tabsContainer" class="flex" on-track="_scroll" on-down="_down">

                <div id="tabsContent" class$="[[_computeTabsContentClass(scrollable)]]">

                    <content select="*"></content>

                    <div id="selectionBar" class$="[[_computeSelectionBarClass(noBar, alignBottom)]]"
                         on-transitionend="_onBarTransitionEnd"></div>

                </div>

            </div>

            <paper-icon-button icon="paper-tabs:chevron-right"
                               class$="[[_computeScrollButtonClass(_rightHidden, scrollable, hideScrollButtons)]]"
                               on-up="_onScrollButtonUp" on-down="_onRightScrollButtonDown"
                               tabindex="-1"></paper-icon-button>

        </template>

    </dom-module>

    <script>

        Polymer({

            is: 'paper-tabs',

            behaviors: [
                Polymer.IronResizableBehavior,
                Polymer.IronMenubarBehavior
            ],

            properties: {

                /**
                 * If true, ink ripple effect is disabled.
                 */
                noink: {
                    type: Boolean,
                    value: false
                },

                /**
                 * If true, the bottom bar to indicate the selected tab will not be shown.
                 */
                noBar: {
                    type: Boolean,
                    value: false
                },

                /**
                 * If true, the slide effect for the bottom bar is disabled.
                 */
                noSlide: {
                    type: Boolean,
                    value: false
                },

                /**
                 * If true, tabs are scrollable and the tab width is based on the label width.
                 */
                scrollable: {
                    type: Boolean,
                    value: false
                },

                /**
                 * If true, dragging on the tabs to scroll is disabled.
                 */
                disableDrag: {
                    type: Boolean,
                    value: false
                },

                /**
                 * If true, scroll buttons (left/right arrow) will be hidden for scrollable tabs.
                 */
                hideScrollButtons: {
                    type: Boolean,
                    value: false
                },

                /**
                 * If true, the tabs are aligned to bottom (the selection bar appears at the top).
                 */
                alignBottom: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Gets or sets the selected element. The default is to use the index of the item.
                 */
                selected: {
                    type: String,
                    notify: true
                },

                selectable: {
                    type: String,
                    value: 'paper-tab'
                },

                _step: {
                    type: Number,
                    value: 10
                },

                _holdDelay: {
                    type: Number,
                    value: 1
                },

                _leftHidden: {
                    type: Boolean,
                    value: false
                },

                _rightHidden: {
                    type: Boolean,
                    value: false
                },

                _previousTab: {
                    type: Object
                }
            },

            hostAttributes: {
                role: 'tablist'
            },

            listeners: {
                'iron-resize': '_onResize',
                'iron-select': '_onIronSelect',
                'iron-deselect': '_onIronDeselect'
            },

            ready: function () {
                this.setScrollDirection('y', this.$.tabsContainer);
            },

            _computeScrollButtonClass: function (hideThisButton, scrollable, hideScrollButtons) {
                if (!scrollable || hideScrollButtons) {
                    return 'hidden';
                }

                if (hideThisButton) {
                    return 'not-visible';
                }

                return '';
            },

            _computeTabsContentClass: function (scrollable) {
                return scrollable ? 'scrollable' : 'horizontal layout';
            },

            _computeSelectionBarClass: function (noBar, alignBottom) {
                if (noBar) {
                    return 'hidden';
                } else if (alignBottom) {
                    return 'align-bottom';
                }
            },

            // TODO(cdata): Add `track` response back in when gesture lands.

            _onResize: function () {
                this.debounce('_onResize', function () {
                    this._scroll();
                    this._tabChanged(this.selectedItem);
                }, 10);
            },

            _onIronSelect: function (event) {
                this._tabChanged(event.detail.item, this._previousTab);
                this._previousTab = event.detail.item;
                this.cancelDebouncer('tab-changed');
            },

            _onIronDeselect: function (event) {
                this.debounce('tab-changed', function () {
                    this._tabChanged(null, this._previousTab);
                    // See polymer/polymer#1305
                }, 1);
            },

            get _tabContainerScrollSize() {
                return Math.max(
                        0,
                        this.$.tabsContainer.scrollWidth -
                        this.$.tabsContainer.offsetWidth
                );
            },


            _scroll: function (e, detail) {
                if (!this.scrollable) {
                    return;
                }

                var ddx = (detail && -detail.ddx) || 0;
                this._affectScroll(ddx);
            },

            _down: function (e) {
                // go one beat async to defeat IronMenuBehavior
                // autorefocus-on-no-selection timeout
                this.async(function () {
                    if (this._defaultFocusAsync) {
                        this.cancelAsync(this._defaultFocusAsync);
                        this._defaultFocusAsync = null;
                    }
                }, 1);
            },

            _affectScroll: function (dx) {
                this.$.tabsContainer.scrollLeft += dx;

                var scrollLeft = this.$.tabsContainer.scrollLeft;

                this._leftHidden = scrollLeft === 0;
                this._rightHidden = scrollLeft === this._tabContainerScrollSize;
            },

            _onLeftScrollButtonDown: function () {
                this._scrollToLeft();
                this._holdJob = setInterval(this._scrollToLeft.bind(this), this._holdDelay);
            },

            _onRightScrollButtonDown: function () {
                this._scrollToRight();
                this._holdJob = setInterval(this._scrollToRight.bind(this), this._holdDelay);
            },

            _onScrollButtonUp: function () {
                clearInterval(this._holdJob);
                this._holdJob = null;
            },

            _scrollToLeft: function () {
                this._affectScroll(-this._step);
            },

            _scrollToRight: function () {
                this._affectScroll(this._step);
            },

            _tabChanged: function (tab, old) {
                if (!tab) {
                    this._positionBar(0, 0);
                    return;
                }

                var r = this.$.tabsContent.getBoundingClientRect();
                var w = r.width;
                var tabRect = tab.getBoundingClientRect();
                var tabOffsetLeft = tabRect.left - r.left;

                this._pos = {
                    width: this._calcPercent(tabRect.width, w),
                    left: this._calcPercent(tabOffsetLeft, w)
                };

                if (this.noSlide || old == null) {
                    // position bar directly without animation
                    this._positionBar(this._pos.width, this._pos.left);
                    return;
                }

                var oldRect = old.getBoundingClientRect();
                var oldIndex = this.items.indexOf(old);
                var index = this.items.indexOf(tab);
                var m = 5;

                // bar animation: expand
                this.$.selectionBar.classList.add('expand');

                if (oldIndex < index) {
                    this._positionBar(this._calcPercent(tabRect.left + tabRect.width - oldRect.left, w) - m,
                            this._left);
                } else {
                    this._positionBar(this._calcPercent(oldRect.left + oldRect.width - tabRect.left, w) - m,
                            this._calcPercent(tabOffsetLeft, w) + m);
                }

                if (this.scrollable) {
                    this._scrollToSelectedIfNeeded(tabRect.width, tabOffsetLeft);
                }
            },

            _scrollToSelectedIfNeeded: function (tabWidth, tabOffsetLeft) {
                var l = tabOffsetLeft - this.$.tabsContainer.scrollLeft;
                if (l < 0) {
                    this.$.tabsContainer.scrollLeft += l;
                } else {
                    l += (tabWidth - this.$.tabsContainer.offsetWidth);
                    if (l > 0) {
                        this.$.tabsContainer.scrollLeft += l;
                    }
                }
            },

            _calcPercent: function (w, w0) {
                return 100 * w / w0;
            },

            _positionBar: function (width, left) {
                width = width || 0;
                left = left || 0;

                this._width = width;
                this._left = left;
                this.transform(
                        'translate3d(' + left + '%, 0, 0) scaleX(' + (width / 100) + ')',
                        this.$.selectionBar);
            },

            _onBarTransitionEnd: function (e) {
                var cl = this.$.selectionBar.classList;
                // bar animation: expand -> contract
                if (cl.contains('expand')) {
                    cl.remove('expand');
                    cl.add('contract');
                    this._positionBar(this._pos.width, this._pos.left);
                    // bar animation done
                } else if (cl.contains('contract')) {
                    cl.remove('contract');
                }
            }

        });

    </script>
    <dom-module id="paper-material" assetpath="../components/paper-material/">
        <template>
            <style>
                :host {
                    display: block;
                    position: relative;
                }

                :host([animated]) {
                    @apply(--shadow-transition);
                }

                :host([elevation="1"]) {
                    @apply(--shadow-elevation-2dp);
                }

                :host([elevation="2"]) {
                    @apply(--shadow-elevation-4dp);
                }

                :host([elevation="3"]) {
                    @apply(--shadow-elevation-6dp);
                }

                :host([elevation="4"]) {
                    @apply(--shadow-elevation-8dp);
                }

                :host([elevation="5"]) {
                    @apply(--shadow-elevation-16dp);
                }
            </style>

            <content></content>
        </template>
    </dom-module>
    <script>
        Polymer({
            is: 'paper-material',

            properties: {
                /**
                 * The z-depth of this element, from 0-5. Setting to 0 will remove the
                 * shadow, and each increasing number greater than 0 will be "deeper"
                 * than the last.
                 *
                 * @attribute elevation
                 * @type number
                 * @default 1
                 */
                elevation: {
                    type: Number,
                    reflectToAttribute: true,
                    value: 1
                },

                /**
                 * Set this to true to animate the shadow when setting a new
                 * `elevation` value.
                 *
                 * @attribute animated
                 * @type boolean
                 * @default false
                 */
                animated: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false
                }
            }
        });
    </script>
    <dom-module id="paper-button" assetpath="../components/paper-button/">
        <template strip-whitespace="">

            <style include="paper-material">
                :host {
                    display: inline-block;
                    position: relative;
                    box-sizing: border-box;
                    min-width: 5.14em;
                    margin: 0 0.29em;
                    background: transparent;
                    text-align: center;
                    font: inherit;
                    text-transform: uppercase;
                    outline-width: 0;
                    border-radius: 3px;
                    -moz-user-select: none;
                    -ms-user-select: none;
                    -webkit-user-select: none;
                    user-select: none;
                    cursor: pointer;
                    z-index: 0;
                    padding: 0.7em 0.57em;

                    @apply(--paper-button);
                }

                :host([raised].keyboard-focus) {
                    font-weight: bold;
                    @apply(--paper-button-raised-keyboard-focus);
                }

                :host(:not([raised]).keyboard-focus) {
                    font-weight: bold;
                    @apply(--paper-button-flat-keyboard-focus);
                }

                :host([disabled]) {
                    background: #eaeaea;
                    color: #a8a8a8;
                    cursor: auto;
                    pointer-events: none;

                    @apply(--paper-button-disabled);
                }

                paper-ripple {
                    color: var(--paper-button-ink-color);
                }

                :host > ::content * {
                    text-transform: inherit;
                }
            </style>
            <content></content>
        </template>
    </dom-module>

    <script>
        Polymer({
            is: 'paper-button',

            behaviors: [
                Polymer.PaperButtonBehavior
            ],

            properties: {
                /**
                 * If true, the button should be styled with a shadow.
                 */
                raised: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: false,
                    observer: '_calculateElevation'
                }
            },

            _calculateElevation: function () {
                if (!this.raised) {
                    this.elevation = 0;
                } else {
                    Polymer.PaperButtonBehaviorImpl._calculateElevation.apply(this);
                }
            }
        });
    </script>
    <dom-module id="paper-spinner-styles" assetpath="../components/paper-spinner/">
        <template>
            <style>
                /*
      /**************************/
                /* STYLES FOR THE SPINNER */
                /**************************/

                /*
       * Constants:
       *      STROKEWIDTH = 3px
       *      ARCSIZE     = 270 degrees (amount of circle the arc takes up)
       *      ARCTIME     = 1333ms (time it takes to expand and contract arc)
       *      ARCSTARTROT = 216 degrees (how much the start location of the arc
       *                                should rotate each time, 216 gives us a
       *                                5 pointed star shape (it's 360/5 * 3).
       *                                For a 7 pointed star, we might do
       *                                360/7 * 3 = 154.286)
       *      CONTAINERWIDTH = 28px
       *      SHRINK_TIME = 400ms
       */

                :host {
                    display: inline-block;
                    position: relative;
                    width: 28px; /* CONTAINERWIDTH */
                    height: 28px; /* CONTAINERWIDTH */
                }

                #spinnerContainer {
                    width: 100%;
                    height: 100%;

                    /* The spinner does not have any contents that would have to be
         * flipped if the direction changes. Always use ltr so that the
         * style works out correctly in both cases. */
                    direction: ltr;
                }

                #spinnerContainer.active {
                    /* duration: 360 * ARCTIME / (ARCSTARTROT + (360-ARCSIZE)) */
                    -webkit-animation: container-rotate 1568ms linear infinite;
                    animation: container-rotate 1568ms linear infinite;
                }

                @-webkit-keyframes container-rotate {
                    to {
                        -webkit-transform: rotate(360deg)
                    }
                }

                @keyframes container-rotate {
                    to {
                        transform: rotate(360deg)
                    }
                }

                .spinner-layer {
                    position: absolute;
                    width: 100%;
                    height: 100%;
                    opacity: 0;
                    white-space: nowrap;
                }

                .layer-1 {
                    border-color: var(--paper-spinner-layer-1-color, --google-blue-500);
                }

                .layer-2 {
                    border-color: var(--paper-spinner-layer-2-color, --google-red-500);
                }

                .layer-3 {
                    border-color: var(--paper-spinner-layer-3-color, --google-yellow-500);
                }

                .layer-4 {
                    border-color: var(--paper-spinner-layer-4-color, --google-green-500);
                }

                /**
       * IMPORTANT NOTE ABOUT CSS ANIMATION PROPERTIES (keanulee):
       *
       * iOS Safari (tested on iOS 8.1) does not handle animation-delay very well - it doesn't
       * guarantee that the animation will start _exactly_ after that value. So we avoid using
       * animation-delay and instead set custom keyframes for each color (as layer-2undant as it
       * seems).
       *
       * We write out each animation in full (instead of separating animation-name,
       * animation-duration, etc.) because under the polyfill, Safari does not recognize those
       * specific properties properly, treats them as -webkit-animation, and overrides the
       * other animation rules. See https://github.com/Polymer/platform/issues/53.
       */
                .active .spinner-layer.layer-1 {
                    /* durations: 4 * ARCTIME */
                    -webkit-animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-1-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
                    animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-1-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
                }

                .active .spinner-layer.layer-2 {
                    /* durations: 4 * ARCTIME */
                    -webkit-animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-2-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
                    animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-2-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
                }

                .active .spinner-layer.layer-3 {
                    /* durations: 4 * ARCTIME */
                    -webkit-animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-3-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
                    animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-3-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
                }

                .active .spinner-layer.layer-4 {
                    /* durations: 4 * ARCTIME */
                    -webkit-animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-4-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
                    animation: fill-unfill-rotate 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both, layer-4-fade-in-out 5332ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
                }

                @-webkit-keyframes fill-unfill-rotate {
                    12.5% {
                        -webkit-transform: rotate(135deg);
                    }
                    /* 0.5 * ARCSIZE */
                    25% {
                        -webkit-transform: rotate(270deg);
                    }
                    /* 1   * ARCSIZE */
                    37.5% {
                        -webkit-transform: rotate(405deg);
                    }
                    /* 1.5 * ARCSIZE */
                    50% {
                        -webkit-transform: rotate(540deg);
                    }
                    /* 2   * ARCSIZE */
                    62.5% {
                        -webkit-transform: rotate(675deg);
                    }
                    /* 2.5 * ARCSIZE */
                    75% {
                        -webkit-transform: rotate(810deg);
                    }
                    /* 3   * ARCSIZE */
                    87.5% {
                        -webkit-transform: rotate(945deg);
                    }
                    /* 3.5 * ARCSIZE */
                    to {
                        -webkit-transform: rotate(1080deg);
                    }
                    /* 4   * ARCSIZE */
                }

                @keyframes fill-unfill-rotate {
                    12.5% {
                        transform: rotate(135deg);
                    }
                    /* 0.5 * ARCSIZE */
                    25% {
                        transform: rotate(270deg);
                    }
                    /* 1   * ARCSIZE */
                    37.5% {
                        transform: rotate(405deg);
                    }
                    /* 1.5 * ARCSIZE */
                    50% {
                        transform: rotate(540deg);
                    }
                    /* 2   * ARCSIZE */
                    62.5% {
                        transform: rotate(675deg);
                    }
                    /* 2.5 * ARCSIZE */
                    75% {
                        transform: rotate(810deg);
                    }
                    /* 3   * ARCSIZE */
                    87.5% {
                        transform: rotate(945deg);
                    }
                    /* 3.5 * ARCSIZE */
                    to {
                        transform: rotate(1080deg);
                    }
                    /* 4   * ARCSIZE */
                }

                /**
       * HACK: Even though the intention is to have the current .spinner-layer at
       * `opacity: 1`, we set it to `opacity: 0.99` instead since this forces Chrome
       * to do proper subpixel rendering for the elements being animated. This is
       * especially visible in Chrome 39 on Ubuntu 14.04. See:
       *
       * - https://github.com/Polymer/paper-spinner/issues/9
       * - https://code.google.com/p/chromium/issues/detail?id=436255
       */
                @-webkit-keyframes layer-1-fade-in-out {
                    from {
                        opacity: 0.99;
                    }
                    25% {
                        opacity: 0.99;
                    }
                    26% {
                        opacity: 0;
                    }
                    89% {
                        opacity: 0;
                    }
                    90% {
                        opacity: 0.99;
                    }
                    100% {
                        opacity: 0.99;
                    }
                }

                @keyframes layer-1-fade-in-out {
                    from {
                        opacity: 0.99;
                    }
                    25% {
                        opacity: 0.99;
                    }
                    26% {
                        opacity: 0;
                    }
                    89% {
                        opacity: 0;
                    }
                    90% {
                        opacity: 0.99;
                    }
                    100% {
                        opacity: 0.99;
                    }
                }

                @-webkit-keyframes layer-2-fade-in-out {
                    from {
                        opacity: 0;
                    }
                    15% {
                        opacity: 0;
                    }
                    25% {
                        opacity: 0.99;
                    }
                    50% {
                        opacity: 0.99;
                    }
                    51% {
                        opacity: 0;
                    }
                }

                @keyframes layer-2-fade-in-out {
                    from {
                        opacity: 0;
                    }
                    15% {
                        opacity: 0;
                    }
                    25% {
                        opacity: 0.99;
                    }
                    50% {
                        opacity: 0.99;
                    }
                    51% {
                        opacity: 0;
                    }
                }

                @-webkit-keyframes layer-3-fade-in-out {
                    from {
                        opacity: 0;
                    }
                    40% {
                        opacity: 0;
                    }
                    50% {
                        opacity: 0.99;
                    }
                    75% {
                        opacity: 0.99;
                    }
                    76% {
                        opacity: 0;
                    }
                }

                @keyframes layer-3-fade-in-out {
                    from {
                        opacity: 0;
                    }
                    40% {
                        opacity: 0;
                    }
                    50% {
                        opacity: 0.99;
                    }
                    75% {
                        opacity: 0.99;
                    }
                    76% {
                        opacity: 0;
                    }
                }

                @-webkit-keyframes layer-4-fade-in-out {
                    from {
                        opacity: 0;
                    }
                    65% {
                        opacity: 0;
                    }
                    75% {
                        opacity: 0.99;
                    }
                    90% {
                        opacity: 0.99;
                    }
                    100% {
                        opacity: 0;
                    }
                }

                @keyframes layer-4-fade-in-out {
                    from {
                        opacity: 0;
                    }
                    65% {
                        opacity: 0;
                    }
                    75% {
                        opacity: 0.99;
                    }
                    90% {
                        opacity: 0.99;
                    }
                    100% {
                        opacity: 0;
                    }
                }

                /**
       * Patch the gap that appear between the two adjacent div.circle-clipper while the
       * spinner is rotating (appears on Chrome 38, Safari 7.1, and IE 11).
       *
       * Update: the gap no longer appears on Chrome when .spinner-layer's opacity is 0.99,
       * but still does on Safari and IE.
       */
                .gap-patch {
                    position: absolute;
                    box-sizing: border-box;
                    top: 0;
                    left: 45%;
                    width: 10%;
                    height: 100%;
                    overflow: hidden;
                    border-color: inherit;
                }

                .gap-patch .circle {
                    width: 1000%;
                    left: -450%;
                }

                .circle-clipper {
                    display: inline-block;
                    position: relative;
                    width: 50%;
                    height: 100%;
                    overflow: hidden;
                    border-color: inherit;
                }

                .circle-clipper .circle {
                    width: 200%;
                }

                .circle {
                    box-sizing: border-box;
                    height: 100%;
                    border-width: 3px; /* STROKEWIDTH */
                    border-style: solid;
                    border-color: inherit;
                    border-bottom-color: transparent !important;
                    border-radius: 50%;
                    -webkit-animation: none;
                    animation: none;

                    @apply(--layout-fit);
                }

                .circle-clipper.left .circle {
                    border-right-color: transparent !important;
                    -webkit-transform: rotate(129deg);
                    transform: rotate(129deg);
                }

                .circle-clipper.right .circle {
                    left: -100%;
                    border-left-color: transparent !important;
                    -webkit-transform: rotate(-129deg);
                    transform: rotate(-129deg);
                }

                .active .circle-clipper.left .circle {
                    /* duration: ARCTIME */
                    -webkit-animation: left-spin 1333ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
                    animation: left-spin 1333ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
                }

                .active .circle-clipper.right .circle {
                    /* duration: ARCTIME */
                    -webkit-animation: right-spin 1333ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
                    animation: right-spin 1333ms cubic-bezier(0.4, 0.0, 0.2, 1) infinite both;
                }

                @-webkit-keyframes left-spin {
                    from {
                        -webkit-transform: rotate(130deg);
                    }
                    50% {
                        -webkit-transform: rotate(-5deg);
                    }
                    to {
                        -webkit-transform: rotate(130deg);
                    }
                }

                @keyframes left-spin {
                    from {
                        transform: rotate(130deg);
                    }
                    50% {
                        transform: rotate(-5deg);
                    }
                    to {
                        transform: rotate(130deg);
                    }
                }

                @-webkit-keyframes right-spin {
                    from {
                        -webkit-transform: rotate(-130deg);
                    }
                    50% {
                        -webkit-transform: rotate(5deg);
                    }
                    to {
                        -webkit-transform: rotate(-130deg);
                    }
                }

                @keyframes right-spin {
                    from {
                        transform: rotate(-130deg);
                    }
                    50% {
                        transform: rotate(5deg);
                    }
                    to {
                        transform: rotate(-130deg);
                    }
                }

                #spinnerContainer.cooldown {
                    /* duration: SHRINK_TIME */
                    -webkit-animation: container-rotate 1568ms linear infinite, fade-out 400ms cubic-bezier(0.4, 0.0, 0.2, 1);
                    animation: container-rotate 1568ms linear infinite, fade-out 400ms cubic-bezier(0.4, 0.0, 0.2, 1);
                }

                @-webkit-keyframes fade-out {
                    from {
                        opacity: 0.99;
                    }
                    to {
                        opacity: 0;
                    }
                }

                @keyframes fade-out {
                    from {
                        opacity: 0.99;
                    }
                    to {
                        opacity: 0;
                    }
                }
            </style>
        </template>
    </dom-module>
    <dom-module id="paper-spinner" assetpath="../components/paper-spinner/">
        <template>
            <style include="paper-spinner-styles"></style>

            <div id="spinnerContainer" class-name="[[_spinnerContainerClassName]]">
                <div class="spinner-layer layer-1">
                    <div class="circle-clipper left">
                        <div class="circle"></div>
                    </div>
                    <div class="gap-patch">
                        <div class="circle"></div>
                    </div>
                    <div class="circle-clipper right">
                        <div class="circle"></div>
                    </div>
                </div>

                <div class="spinner-layer layer-2">
                    <div class="circle-clipper left">
                        <div class="circle"></div>
                    </div>
                    <div class="gap-patch">
                        <div class="circle"></div>
                    </div>
                    <div class="circle-clipper right">
                        <div class="circle"></div>
                    </div>
                </div>

                <div class="spinner-layer layer-3">
                    <div class="circle-clipper left">
                        <div class="circle"></div>
                    </div>
                    <div class="gap-patch">
                        <div class="circle"></div>
                    </div>
                    <div class="circle-clipper right">
                        <div class="circle"></div>
                    </div>
                </div>

                <div class="spinner-layer layer-4">
                    <div class="circle-clipper left">
                        <div class="circle"></div>
                    </div>
                    <div class="gap-patch">
                        <div class="circle"></div>
                    </div>
                    <div class="circle-clipper right">
                        <div class="circle"></div>
                    </div>
                </div>
            </div>
        </template>

        <script>
            Polymer({
                is: 'paper-spinner',

                listeners: {
                    'animationend': 'reset',
                    'webkitAnimationEnd': 'reset'
                },

                properties: {
                    /**
                     * Displays the spinner.
                     *
                     * @attribute active
                     * @type boolean
                     * @default false
                     */
                    active: {
                        type: Boolean,
                        value: false,
                        reflectToAttribute: true,
                        observer: '_activeChanged'
                    },

                    /**
                     * Alternative text content for accessibility support.
                     * If alt is present, it will add an aria-label whose content matches alt when active.
                     * If alt is not present, it will default to 'loading' as the alt value.
                     *
                     * @attribute alt
                     * @type string
                     * @default 'loading'
                     */
                    alt: {
                        type: String,
                        value: 'loading',
                        observer: '_altChanged'
                    },

                    /**
                     * True when the spinner is going from active to inactive. This is represented by a fade
                     * to 0% opacity to the user.
                     */
                    _coolingDown: {
                        type: Boolean,
                        value: false
                    },

                    _spinnerContainerClassName: {
                        type: String,
                        computed: '_computeSpinnerContainerClassName(active, _coolingDown)'
                    }
                },

                _computeSpinnerContainerClassName: function (active, coolingDown) {
                    return [
                        active || coolingDown ? 'active' : '',
                        coolingDown ? 'cooldown' : ''
                    ].join(' ');
                },

                _activeChanged: function (active, old) {
                    this._setAriaHidden(!active);
                    this._coolingDown = !active && old;
                },

                _altChanged: function (alt) {
                    // user-provided `aria-label` takes precedence over prototype default
                    if (alt === this.getPropertyInfo('alt').value) {
                        this.alt = this.getAttribute('aria-label') || alt;
                    } else {
                        this._setAriaHidden(alt === '');
                        this.setAttribute('aria-label', alt);
                    }
                },

                _setAriaHidden: function (hidden) {
                    var attr = 'aria-hidden';
                    if (hidden) {
                        this.setAttribute(attr, 'true');
                    } else {
                        this.removeAttribute(attr);
                    }
                },

                reset: function () {
                    this.active = false;
                    this._coolingDown = false;
                }
            });
        </script>
    </dom-module>
    <dom-module id="paper-fab" assetpath="../components/paper-fab/">
        <template strip-whitespace="">
            <style include="paper-material">
                :host {
                    display: inline-block;
                    position: relative;
                    outline: none;
                    -moz-user-select: none;
                    -ms-user-select: none;
                    -webkit-user-select: none;
                    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                    user-select: none;
                    cursor: pointer;

                    box-sizing: border-box;
                    min-width: 0;
                    width: 56px;
                    height: 56px;
                    background: var(--paper-fab-background, --accent-color);
                    color: var(--text-primary-color);
                    border-radius: 50%;
                    padding: 16px;

                    z-index: 0;

                    @apply(--layout-vertical);
                    @apply(--layout-center-center);
                    @apply(--paper-fab);
                }

                :host([mini]) {
                    width: 40px;
                    height: 40px;
                    padding: 8px;

                    @apply(--paper-fab-mini);
                }

                :host([disabled]) {
                    color: var(--paper-fab-disabled-text, --paper-grey-500);
                    background: var(--paper-fab-disabled-background, --paper-grey-300);
                    @apply(--paper-fab-disabled);
                }

                iron-icon {
                    @apply(--paper-fab-iron-icon);
                }

                :host(.keyboard-focus) {
                    background: var(--paper-fab-keyboard-focus-background, --paper-pink-900);
                }
            </style>

            <iron-icon id="icon" src="[[src]]" icon="[[icon]]"></iron-icon>
        </template>
    </dom-module>

    <script>
        Polymer({
            is: 'paper-fab',

            behaviors: [
                Polymer.PaperButtonBehavior
            ],

            properties: {
                /**
                 * The URL of an image for the icon. If the src property is specified,
                 * the icon property should not be.
                 *
                 * @attribute src
                 * @type string
                 * @default ''
                 */
                src: {
                    type: String,
                    value: ''
                },

                /**
                 * Specifies the icon name or index in the set of icons available in
                 * the icon's icon set. If the icon property is specified,
                 * the src property should not be.
                 *
                 * @attribute icon
                 * @type string
                 * @default ''
                 */
                icon: {
                    type: String,
                    value: ''
                },

                /**
                 * Set this to true to style this is a "mini" FAB.
                 *
                 * @attribute mini
                 * @type boolean
                 * @default false
                 */
                mini: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                }
            }
        });
    </script>
    <iron-iconset-svg name="icons" size="24">
        <svg>
            <defs>
                <g id="3d-rotation">
                    <path d="M7.52 21.48C4.25 19.94 1.91 16.76 1.55 13H.05C.56 19.16 5.71 24 12 24l.66-.03-3.81-3.81-1.33 1.32zm.89-6.52c-.19 0-.37-.03-.52-.08-.16-.06-.29-.13-.4-.24-.11-.1-.2-.22-.26-.37-.06-.14-.09-.3-.09-.47h-1.3c0 .36.07.68.21.95.14.27.33.5.56.69.24.18.51.32.82.41.3.1.62.15.96.15.37 0 .72-.05 1.03-.15.32-.1.6-.25.83-.44s.42-.43.55-.72c.13-.29.2-.61.2-.97 0-.19-.02-.38-.07-.56-.05-.18-.12-.35-.23-.51-.1-.16-.24-.3-.4-.43-.17-.13-.37-.23-.61-.31.2-.09.37-.2.52-.33.15-.13.27-.27.37-.42.1-.15.17-.3.22-.46.05-.16.07-.32.07-.48 0-.36-.06-.68-.18-.96-.12-.28-.29-.51-.51-.69-.2-.19-.47-.33-.77-.43C9.1 8.05 8.76 8 8.39 8c-.36 0-.69.05-1 .16-.3.11-.57.26-.79.45-.21.19-.38.41-.51.67-.12.26-.18.54-.18.85h1.3c0-.17.03-.32.09-.45s.14-.25.25-.34c.11-.09.23-.17.38-.22.15-.05.3-.08.48-.08.4 0 .7.1.89.31.19.2.29.49.29.86 0 .18-.03.34-.08.49-.05.15-.14.27-.25.37-.11.1-.25.18-.41.24-.16.06-.36.09-.58.09H7.5v1.03h.77c.22 0 .42.02.6.07s.33.13.45.23c.12.11.22.24.29.4.07.16.1.35.1.57 0 .41-.12.72-.35.93-.23.23-.55.33-.95.33zm8.55-5.92c-.32-.33-.7-.59-1.14-.77-.43-.18-.92-.27-1.46-.27H12v8h2.3c.55 0 1.06-.09 1.51-.27.45-.18.84-.43 1.16-.76.32-.33.57-.73.74-1.19.17-.47.26-.99.26-1.57v-.4c0-.58-.09-1.1-.26-1.57-.18-.47-.43-.87-.75-1.2zm-.39 3.16c0 .42-.05.79-.14 1.13-.1.33-.24.62-.43.85-.19.23-.43.41-.71.53-.29.12-.62.18-.99.18h-.91V9.12h.97c.72 0 1.27.23 1.64.69.38.46.57 1.12.57 1.99v.4zM12 0l-.66.03 3.81 3.81 1.33-1.33c3.27 1.55 5.61 4.72 5.96 8.48h1.5C23.44 4.84 18.29 0 12 0z"></path>
                </g>
                <g id="accessibility">
                    <path d="M12 2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 7h-6v13h-2v-6h-2v6H9V9H3V7h18v2z"></path>
                </g>
                <g id="account-balance">
                    <path d="M4 10v7h3v-7H4zm6 0v7h3v-7h-3zM2 22h19v-3H2v3zm14-12v7h3v-7h-3zm-4.5-9L2 6v2h19V6l-9.5-5z"></path>
                </g>
                <g id="account-balance-wallet">
                    <path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path>
                </g>
                <g id="account-box">
                    <path d="M3 5v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2H5c-1.11 0-2 .9-2 2zm12 4c0 1.66-1.34 3-3 3s-3-1.34-3-3 1.34-3 3-3 3 1.34 3 3zm-9 8c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1H6v-1z"></path>
                </g>
                <g id="account-circle">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"></path>
                </g>
                <g id="add">
                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path>
                </g>
                <g id="add-alert">
                    <path d="M10.01 21.01c0 1.1.89 1.99 1.99 1.99s1.99-.89 1.99-1.99h-3.98zm8.87-4.19V11c0-3.25-2.25-5.97-5.29-6.69v-.72C13.59 2.71 12.88 2 12 2s-1.59.71-1.59 1.59v.72C7.37 5.03 5.12 7.75 5.12 11v5.82L3 18.94V20h18v-1.06l-2.12-2.12zM16 13.01h-3v3h-2v-3H8V11h3V8h2v3h3v2.01z"></path>
                </g>
                <g id="add-box">
                    <path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"></path>
                </g>
                <g id="add-circle">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"></path>
                </g>
                <g id="add-circle-outline">
                    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path>
                </g>
                <g id="add-shopping-cart">
                    <path d="M11 9h2V6h3V4h-3V1h-2v3H8v2h3v3zm-4 9c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2zm-9.83-3.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.86-7.01L19.42 4h-.01l-1.1 2-2.76 5H8.53l-.13-.27L6.16 6l-.95-2-.94-2H1v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.13 0-.25-.11-.25-.25z"></path>
                </g>
                <g id="alarm">
                    <path d="M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM12.5 8H11v6l4.75 2.85.75-1.23-4-2.37V8zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path>
                </g>
                <g id="alarm-add">
                    <path d="M7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm1-11h-2v3H8v2h3v3h2v-3h3v-2h-3V9z"></path>
                </g>
                <g id="alarm-off">
                    <path d="M12 6c3.87 0 7 3.13 7 7 0 .84-.16 1.65-.43 2.4l1.52 1.52c.58-1.19.91-2.51.91-3.92 0-4.97-4.03-9-9-9-1.41 0-2.73.33-3.92.91L9.6 6.43C10.35 6.16 11.16 6 12 6zm10-.28l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM2.92 2.29L1.65 3.57 2.98 4.9l-1.11.93 1.42 1.42 1.11-.94.8.8C3.83 8.69 3 10.75 3 13c0 4.97 4.02 9 9 9 2.25 0 4.31-.83 5.89-2.2l2.2 2.2 1.27-1.27L3.89 3.27l-.97-.98zm13.55 16.1C15.26 19.39 13.7 20 12 20c-3.87 0-7-3.13-7-7 0-1.7.61-3.26 1.61-4.47l9.86 9.86zM8.02 3.28L6.6 1.86l-.86.71 1.42 1.42.86-.71z"></path>
                </g>
                <g id="alarm-on">
                    <path d="M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm-1.46-5.47L8.41 12.4l-1.06 1.06 3.18 3.18 6-6-1.06-1.06-4.93 4.95z"></path>
                </g>
                <g id="android">
                    <path d="M6 18c0 .55.45 1 1 1h1v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V19h2v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V19h1c.55 0 1-.45 1-1V8H6v10zM3.5 8C2.67 8 2 8.67 2 9.5v7c0 .83.67 1.5 1.5 1.5S5 17.33 5 16.5v-7C5 8.67 4.33 8 3.5 8zm17 0c-.83 0-1.5.67-1.5 1.5v7c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5v-7c0-.83-.67-1.5-1.5-1.5zm-4.97-5.84l1.3-1.3c.2-.2.2-.51 0-.71-.2-.2-.51-.2-.71 0l-1.48 1.48C13.85 1.23 12.95 1 12 1c-.96 0-1.86.23-2.66.63L7.85.15c-.2-.2-.51-.2-.71 0-.2.2-.2.51 0 .71l1.31 1.31C6.97 3.26 6 5.01 6 7h12c0-1.99-.97-3.75-2.47-4.84zM10 5H9V4h1v1zm5 0h-1V4h1v1z"></path>
                </g>
                <g id="announcement">
                    <path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 9h-2V5h2v6zm0 4h-2v-2h2v2z"></path>
                </g>
                <g id="apps">
                    <path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"></path>
                </g>
                <g id="archive">
                    <path d="M20.54 5.23l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.16.55L3.46 5.23C3.17 5.57 3 6.02 3 6.5V19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.48-.17-.93-.46-1.27zM12 17.5L6.5 12H10v-2h4v2h3.5L12 17.5zM5.12 5l.81-1h12l.94 1H5.12z"></path>
                </g>
                <g id="arrow-back">
                    <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path>
                </g>
                <g id="arrow-drop-down">
                    <path d="M7 10l5 5 5-5z"></path>
                </g>
                <g id="arrow-drop-down-circle">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 12l-4-4h8l-4 4z"></path>
                </g>
                <g id="arrow-drop-up">
                    <path d="M7 14l5-5 5 5z"></path>
                </g>
                <g id="arrow-forward">
                    <path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path>
                </g>
                <g id="aspect-ratio">
                    <path d="M19 12h-2v3h-3v2h5v-5zM7 9h3V7H5v5h2V9zm14-6H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z"></path>
                </g>
                <g id="assessment">
                    <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"></path>
                </g>
                <g id="assignment">
                    <path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"></path>
                </g>
                <g id="assignment-ind">
                    <path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 4c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H6v-1.4c0-2 4-3.1 6-3.1s6 1.1 6 3.1V19z"></path>
                </g>
                <g id="assignment-late">
                    <path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-6 15h-2v-2h2v2zm0-4h-2V8h2v6zm-1-9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"></path>
                </g>
                <g id="assignment-return">
                    <path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm4 12h-4v3l-5-5 5-5v3h4v4z"></path>
                </g>
                <g id="assignment-returned">
                    <path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 15l-5-5h3V9h4v4h3l-5 5z"></path>
                </g>
                <g id="assignment-turned-in">
                    <path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm-2 14l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"></path>
                </g>
                <g id="attachment">
                    <path d="M7.5 18C4.46 18 2 15.54 2 12.5S4.46 7 7.5 7H18c2.21 0 4 1.79 4 4s-1.79 4-4 4H9.5C8.12 15 7 13.88 7 12.5S8.12 10 9.5 10H17v1.5H9.5c-.55 0-1 .45-1 1s.45 1 1 1H18c1.38 0 2.5-1.12 2.5-2.5S19.38 8.5 18 8.5H7.5c-2.21 0-4 1.79-4 4s1.79 4 4 4H17V18H7.5z"></path>
                </g>
                <g id="autorenew">
                    <path d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"></path>
                </g>
                <g id="backspace">
                    <path d="M22 3H7c-.69 0-1.23.35-1.59.88L0 12l5.41 8.11c.36.53.9.89 1.59.89h15c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-3 12.59L17.59 17 14 13.41 10.41 17 9 15.59 12.59 12 9 8.41 10.41 7 14 10.59 17.59 7 19 8.41 15.41 12 19 15.59z"></path>
                </g>
                <g id="backup">
                    <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"></path>
                </g>
                <g id="block">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM4 12c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L5.69 16.9C4.63 15.55 4 13.85 4 12zm8 8c-1.85 0-3.55-.63-4.9-1.69L18.31 7.1C19.37 8.45 20 10.15 20 12c0 4.42-3.58 8-8 8z"></path>
                </g>
                <g id="book">
                    <path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"></path>
                </g>
                <g id="bookmark">
                    <path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z"></path>
                </g>
                <g id="bookmark-border">
                    <path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2zm0 15l-5-2.18L7 18V5h10v13z"></path>
                </g>
                <g id="bug-report">
                    <path d="M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5c-.49 0-.96.06-1.41.17L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20V8zm-6 8h-4v-2h4v2zm0-4h-4v-2h4v2z"></path>
                </g>
                <g id="build">
                    <path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"></path>
                </g>
                <g id="cached">
                    <path d="M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z"></path>
                </g>
                <g id="camera-enhance">
                    <path d="M9 3L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2h-3.17L15 3H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zM12 17l1.25-2.75L16 13l-2.75-1.25L12 9l-1.25 2.75L8 13l2.75 1.25z"></path>
                </g>
                <g id="cancel">
                    <path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"></path>
                </g>
                <g id="card-giftcard">
                    <path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 11 8.76l1-1.36 1 1.36L15.38 12 17 10.83 14.92 8H20v6z"></path>
                </g>
                <g id="card-membership">
                    <path d="M20 2H4c-1.11 0-2 .89-2 2v11c0 1.11.89 2 2 2h4v5l4-2 4 2v-5h4c1.11 0 2-.89 2-2V4c0-1.11-.89-2-2-2zm0 13H4v-2h16v2zm0-5H4V4h16v6z"></path>
                </g>
                <g id="card-travel">
                    <path d="M20 6h-3V4c0-1.11-.89-2-2-2H9c-1.11 0-2 .89-2 2v2H4c-1.11 0-2 .89-2 2v11c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zM9 4h6v2H9V4zm11 15H4v-2h16v2zm0-5H4V8h3v2h2V8h6v2h2V8h3v6z"></path>
                </g>
                <g id="change-history">
                    <path d="M12 7.77L18.39 18H5.61L12 7.77M12 4L2 20h20L12 4z"></path>
                </g>
                <g id="check">
                    <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path>
                </g>
                <g id="check-box">
                    <path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path>
                </g>
                <g id="check-box-outline-blank">
                    <path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path>
                </g>
                <g id="check-circle">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path>
                </g>
                <g id="chevron-left">
                    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path>
                </g>
                <g id="chevron-right">
                    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path>
                </g>
                <g id="chrome-reader-mode">
                    <path d="M13 12h7v1.5h-7zm0-2.5h7V11h-7zm0 5h7V16h-7zM21 4H3c-1.1 0-2 .9-2 2v13c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 15h-9V6h9v13z"></path>
                </g>
                <g id="class">
                    <path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"></path>
                </g>
                <g id="clear">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
                </g>
                <g id="close">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
                </g>
                <g id="cloud">
                    <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z"></path>
                </g>
                <g id="cloud-circle">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.5 14H8c-1.66 0-3-1.34-3-3s1.34-3 3-3l.14.01C8.58 8.28 10.13 7 12 7c2.21 0 4 1.79 4 4h.5c1.38 0 2.5 1.12 2.5 2.5S17.88 16 16.5 16z"></path>
                </g>
                <g id="cloud-done">
                    <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM10 17l-3.5-3.5 1.41-1.41L10 14.17 15.18 9l1.41 1.41L10 17z"></path>
                </g>
                <g id="cloud-download">
                    <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM17 13l-5 5-5-5h3V9h4v4h3z"></path>
                </g>
                <g id="cloud-off">
                    <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4c-1.48 0-2.85.43-4.01 1.17l1.46 1.46C10.21 6.23 11.08 6 12 6c3.04 0 5.5 2.46 5.5 5.5v.5H19c1.66 0 3 1.34 3 3 0 1.13-.64 2.11-1.56 2.62l1.45 1.45C23.16 18.16 24 16.68 24 15c0-2.64-2.05-4.78-4.65-4.96zM3 5.27l2.75 2.74C2.56 8.15 0 10.77 0 14c0 3.31 2.69 6 6 6h11.73l2 2L21 20.73 4.27 4 3 5.27zM7.73 10l8 8H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h1.73z"></path>
                </g>
                <g id="cloud-queue">
                    <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM19 18H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h.71C7.37 7.69 9.48 6 12 6c3.04 0 5.5 2.46 5.5 5.5v.5H19c1.66 0 3 1.34 3 3s-1.34 3-3 3z"></path>
                </g>
                <g id="cloud-upload">
                    <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"></path>
                </g>
                <g id="code">
                    <path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path>
                </g>
                <g id="content-copy">
                    <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path>
                </g>
                <g id="content-cut">
                    <path d="M9.64 7.64c.23-.5.36-1.05.36-1.64 0-2.21-1.79-4-4-4S2 3.79 2 6s1.79 4 4 4c.59 0 1.14-.13 1.64-.36L10 12l-2.36 2.36C7.14 14.13 6.59 14 6 14c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4c0-.59-.13-1.14-.36-1.64L12 14l7 7h3v-1L9.64 7.64zM6 8c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm0 12c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm6-7.5c-.28 0-.5-.22-.5-.5s.22-.5.5-.5.5.22.5.5-.22.5-.5.5zM19 3l-6 6 2 2 7-7V3z"></path>
                </g>
                <g id="content-paste">
                    <path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"></path>
                </g>
                <g id="create">
                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path>
                </g>
                <g id="credit-card">
                    <path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"></path>
                </g>
                <g id="dashboard">
                    <path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"></path>
                </g>
                <g id="delete">
                    <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path>
                </g>
                <g id="description">
                    <path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"></path>
                </g>
                <g id="dns">
                    <path d="M20 13H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zM7 19c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM20 3H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zM7 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path>
                </g>
                <g id="done">
                    <path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"></path>
                </g>
                <g id="done-all">
                    <path d="M18 7l-1.41-1.41-6.34 6.34 1.41 1.41L18 7zm4.24-1.41L11.66 16.17 7.48 12l-1.41 1.41L11.66 19l12-12-1.42-1.41zM.41 13.41L6 19l1.41-1.41L1.83 12 .41 13.41z"></path>
                </g>
                <g id="drafts">
                    <path d="M21.99 8c0-.72-.37-1.35-.94-1.7L12 1 2.95 6.3C2.38 6.65 2 7.28 2 8v10c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2l-.01-10zM12 13L3.74 7.84 12 3l8.26 4.84L12 13z"></path>
                </g>
                <g id="eject">
                    <path d="M5 17h14v2H5zm7-12L5.33 15h13.34z"></path>
                </g>
                <g id="error">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path>
                </g>
                <g id="error-outline">
                    <path d="M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path>
                </g>
                <g id="event">
                    <path d="M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"></path>
                </g>
                <g id="event-seat">
                    <defs>
                        <path id="a" d="M0 0h24v24H0V0z"></path>
                    </defs>
                    <clipPath id="b">
                        <use xlink:href="#a" overflow="visible"></use>
                    </clipPath>
                    <path d="M4 18v3h3v-3h10v3h3v-6H4zm15-8h3v3h-3zM2 10h3v3H2zm15 3H7V5c0-1.1.9-2 2-2h6c1.1 0 2 .9 2 2v8z"
                          clip-path="url(#b)"></path>
                </g>
                <g id="exit-to-app">
                    <path d="M10.09 15.59L11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path>
                </g>
                <g id="expand-less">
                    <path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"></path>
                </g>
                <g id="expand-more">
                    <path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"></path>
                </g>
                <g id="explore">
                    <path d="M12 10.9c-.61 0-1.1.49-1.1 1.1s.49 1.1 1.1 1.1c.61 0 1.1-.49 1.1-1.1s-.49-1.1-1.1-1.1zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm2.19 12.19L6 18l3.81-8.19L18 6l-3.81 8.19z"></path>
                </g>
                <g id="extension">
                    <path d="M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7 1.49 0 2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11z"></path>
                </g>
                <g id="face">
                    <path d="M9 11.75c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zm6 0c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8 0-.29.02-.58.05-.86 2.36-1.05 4.23-2.98 5.21-5.37C11.07 8.33 14.05 10 17.42 10c.78 0 1.53-.09 2.25-.26.21.71.33 1.47.33 2.26 0 4.41-3.59 8-8 8z"></path>
                </g>
                <g id="favorite">
                    <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path>
                </g>
                <g id="favorite-border">
                    <path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"></path>
                </g>
                <g id="feedback">
                    <path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 12h-2v-2h2v2zm0-4h-2V6h2v4z"></path>
                </g>
                <g id="file-download">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path>
                </g>
                <g id="file-upload">
                    <path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"></path>
                </g>
                <g id="filter-list">
                    <path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"></path>
                </g>
                <g id="find-in-page">
                    <path d="M20 19.59V8l-6-6H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c.45 0 .85-.15 1.19-.4l-4.43-4.43c-.8.52-1.74.83-2.76.83-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5c0 1.02-.31 1.96-.83 2.75L20 19.59zM9 13c0 1.66 1.34 3 3 3s3-1.34 3-3-1.34-3-3-3-3 1.34-3 3z"></path>
                </g>
                <g id="find-replace">
                    <path d="M11 6c1.38 0 2.63.56 3.54 1.46L12 10h6V4l-2.05 2.05C14.68 4.78 12.93 4 11 4c-3.53 0-6.43 2.61-6.92 6H6.1c.46-2.28 2.48-4 4.9-4zm5.64 9.14c.66-.9 1.12-1.97 1.28-3.14H15.9c-.46 2.28-2.48 4-4.9 4-1.38 0-2.63-.56-3.54-1.46L10 12H4v6l2.05-2.05C7.32 17.22 9.07 18 11 18c1.55 0 2.98-.51 4.14-1.36L20 21.49 21.49 20l-4.85-4.86z"></path>
                </g>
                <g id="flag">
                    <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"></path>
                </g>
                <g id="flight-land">
                    <defs>
                        <path id="a" d="M0 0h24v24H0V0z"></path>
                    </defs>
                    <defs>
                        <path id="c" d="M0 0h24v24H0V0z"></path>
                    </defs>
                    <clipPath id="b">
                        <use xlink:href="#a" overflow="visible"></use>
                    </clipPath>
                    <clipPath id="d" clip-path="url(#b)">
                        <use xlink:href="#c" overflow="visible"></use>
                    </clipPath>
                    <path d="M2.5 19h19v2h-19zm7.18-5.73l4.35 1.16 5.31 1.42c.8.21 1.62-.26 1.84-1.06.21-.8-.26-1.62-1.06-1.84l-5.31-1.42-2.76-9.02L10.12 2v8.28L5.15 8.95l-.93-2.32-1.45-.39v5.17l1.6.43 5.31 1.43z"
                          clip-path="url(#d)"></path>
                </g>
                <g id="flight-takeoff">
                    <defs>
                        <path id="a" d="M0 0h24v24H0V0z"></path>
                    </defs>
                    <clipPath id="b">
                        <use xlink:href="#a" overflow="visible"></use>
                    </clipPath>
                    <path d="M2.5 19h19v2h-19zm19.57-9.36c-.21-.8-1.04-1.28-1.84-1.06L14.92 10l-6.9-6.43-1.93.51 4.14 7.17-4.97 1.33-1.97-1.54-1.45.39 1.82 3.16.77 1.33 1.6-.43 5.31-1.42 4.35-1.16L21 11.49c.81-.23 1.28-1.05 1.07-1.85z"
                          clip-path="url(#b)"></path>
                </g>
                <g id="flip-to-back">
                    <path d="M9 7H7v2h2V7zm0 4H7v2h2v-2zm0-8c-1.11 0-2 .9-2 2h2V3zm4 12h-2v2h2v-2zm6-12v2h2c0-1.1-.9-2-2-2zm-6 0h-2v2h2V3zM9 17v-2H7c0 1.1.89 2 2 2zm10-4h2v-2h-2v2zm0-4h2V7h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zM5 7H3v12c0 1.1.89 2 2 2h12v-2H5V7zm10-2h2V3h-2v2zm0 12h2v-2h-2v2z"></path>
                </g>
                <g id="flip-to-front">
                    <path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm2 4v-2H3c0 1.1.89 2 2 2zM3 9h2V7H3v2zm12 12h2v-2h-2v2zm4-18H9c-1.11 0-2 .9-2 2v10c0 1.1.89 2 2 2h10c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 12H9V5h10v10zm-8 6h2v-2h-2v2zm-4 0h2v-2H7v2z"></path>
                </g>
                <g id="folder">
                    <path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"></path>
                </g>
                <g id="folder-open">
                    <path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z"></path>
                </g>
                <g id="folder-shared">
                    <path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-5 3c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm4 8h-8v-1c0-1.33 2.67-2 4-2s4 .67 4 2v1z"></path>
                </g>
                <g id="font-download">
                    <path d="M9.93 13.5h4.14L12 7.98zM20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-4.05 16.5l-1.14-3H9.17l-1.12 3H5.96l5.11-13h1.86l5.11 13h-2.09z"></path>
                </g>
                <g id="forward">
                    <path d="M12 8V4l8 8-8 8v-4H4V8z"></path>
                </g>
                <g id="fullscreen">
                    <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path>
                </g>
                <g id="fullscreen-exit">
                    <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"></path>
                </g>
                <g id="gesture">
                    <path d="M4.59 6.89c.7-.71 1.4-1.35 1.71-1.22.5.2 0 1.03-.3 1.52-.25.42-2.86 3.89-2.86 6.31 0 1.28.48 2.34 1.34 2.98.75.56 1.74.73 2.64.46 1.07-.31 1.95-1.4 3.06-2.77 1.21-1.49 2.83-3.44 4.08-3.44 1.63 0 1.65 1.01 1.76 1.79-3.78.64-5.38 3.67-5.38 5.37 0 1.7 1.44 3.09 3.21 3.09 1.63 0 4.29-1.33 4.69-6.1H21v-2.5h-2.47c-.15-1.65-1.09-4.2-4.03-4.2-2.25 0-4.18 1.91-4.94 2.84-.58.73-2.06 2.48-2.29 2.72-.25.3-.68.84-1.11.84-.45 0-.72-.83-.36-1.92.35-1.09 1.4-2.86 1.85-3.52.78-1.14 1.3-1.92 1.3-3.28C8.95 3.69 7.31 3 6.44 3 5.12 3 3.97 4 3.72 4.25c-.36.36-.66.66-.88.93l1.75 1.71zm9.29 11.66c-.31 0-.74-.26-.74-.72 0-.6.73-2.2 2.87-2.76-.3 2.69-1.43 3.48-2.13 3.48z"></path>
                </g>
                <g id="get-app">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path>
                </g>
                <g id="gif">
                    <defs>
                        <path id="a" d="M24 24H0V0h24v24z"></path>
                    </defs>
                    <clipPath id="b">
                        <use xlink:href="#a" overflow="visible"></use>
                    </clipPath>
                    <path d="M11.5 9H13v6h-1.5zM9 9H6c-.6 0-1 .5-1 1v4c0 .5.4 1 1 1h3c.6 0 1-.5 1-1v-2H8.5v1.5h-2v-3H10V10c0-.5-.4-1-1-1zm10 1.5V9h-4.5v6H16v-2h2v-1.5h-2v-1z"
                          clip-path="url(#b)"></path>
                </g>
                <g id="grade">
                    <path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path>
                </g>
                <g id="group-work">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM8 17.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zM9.5 8c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5S9.5 9.38 9.5 8zm6.5 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path>
                </g>
                <g id="help">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"></path>
                </g>
                <g id="help-outline">
                    <path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"></path>
                </g>
                <g id="highlight-off">
                    <path d="M14.59 8L12 10.59 9.41 8 8 9.41 10.59 12 8 14.59 9.41 16 12 13.41 14.59 16 16 14.59 13.41 12 16 9.41 14.59 8zM12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path>
                </g>
                <g id="history">
                    <path opacity=".9"
                          d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"></path>
                </g>
                <g id="home">
                    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"></path>
                </g>
                <g id="hourglass-empty">
                    <path d="M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6zm10 14.5V20H8v-3.5l4-4 4 4zm-4-5l-4-4V4h8v3.5l-4 4z"></path>
                </g>
                <g id="hourglass-full">
                    <path d="M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6z"></path>
                </g>
                <g id="http">
                    <path d="M4.5 11h-2V9H1v6h1.5v-2.5h2V15H6V9H4.5v2zm2.5-.5h1.5V15H10v-4.5h1.5V9H7v1.5zm5.5 0H14V15h1.5v-4.5H17V9h-4.5v1.5zm9-1.5H18v6h1.5v-2h2c.8 0 1.5-.7 1.5-1.5v-1c0-.8-.7-1.5-1.5-1.5zm0 2.5h-2v-1h2v1z"></path>
                </g>
                <g id="https">
                    <path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"></path>
                </g>
                <g id="inbox">
                    <path d="M19 3H4.99c-1.1 0-1.98.9-1.98 2L3 19c0 1.1.89 2 1.99 2H19c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 12h-4c0 1.66-1.34 3-3 3s-3-1.34-3-3H4.99V5H19v10zm-3-5h-2V7h-4v3H8l4 4 4-4z"></path>
                </g>
                <g id="indeterminate-check-box">
                    <defs>
                        <path id="a" d="M0 0h24v24H0z"></path>
                    </defs>
                    <clipPath id="b">
                        <use xlink:href="#a" overflow="visible"></use>
                    </clipPath>
                    <path clip-path="url(#b)"
                          d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"></path>
                </g>
                <g id="info">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"></path>
                </g>
                <g id="info-outline">
                    <path d="M11 17h2v-6h-2v6zm1-15C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 9h2V7h-2v2z"></path>
                </g>
                <g id="input">
                    <path d="M21 3.01H3c-1.1 0-2 .9-2 2V9h2V4.99h18v14.03H3V15H1v4.01c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98v-14c0-1.11-.9-2-2-2zM11 16l4-4-4-4v3H1v2h10v3z"></path>
                </g>
                <g id="invert-colors">
                    <path d="M17.66 7.93L12 2.27 6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58c2.05 0 4.1-.78 5.66-2.34 3.12-3.12 3.12-8.19 0-11.31zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"></path>
                </g>
                <g id="label">
                    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"></path>
                </g>
                <g id="label-outline">
                    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16zM16 17H5V7h11l3.55 5L16 17z"></path>
                </g>
                <g id="language">
                    <path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm6.93 6h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56zM12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96zM4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2 0 .68.06 1.34.14 2H4.26zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56zm2.95-8H5.08c.96-1.66 2.49-2.93 4.33-3.56C8.81 5.55 8.35 6.75 8.03 8zM12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96zM14.34 14H9.66c-.09-.66-.16-1.32-.16-2 0-.68.07-1.35.16-2h4.68c.09.65.16 1.32.16 2 0 .68-.07 1.34-.16 2zm.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56zM16.36 14c.08-.66.14-1.32.14-2 0-.68-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2h-3.38z"></path>
                </g>
                <g id="launch">
                    <path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"></path>
                </g>
                <g id="link">
                    <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"></path>
                </g>
                <g id="list">
                    <path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"></path>
                </g>
                <g id="lock">
                    <path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"></path>
                </g>
                <g id="lock-open">
                    <path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z"></path>
                </g>
                <g id="lock-outline">
                    <path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6-5.1c1.71 0 3.1 1.39 3.1 3.1v2H9V6h-.1c0-1.71 1.39-3.1 3.1-3.1zM18 20H6V10h12v10zm-6-3c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z"></path>
                </g>
                <g id="loyalty">
                    <path d="M21.41 11.58l-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7zm11.77 8.27L13 19.54l-4.27-4.27C8.28 14.81 8 14.19 8 13.5c0-1.38 1.12-2.5 2.5-2.5.69 0 1.32.28 1.77.74l.73.72.73-.73c.45-.45 1.08-.73 1.77-.73 1.38 0 2.5 1.12 2.5 2.5 0 .69-.28 1.32-.73 1.77z"></path>
                </g>
                <g id="mail">
                    <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"></path>
                </g>
                <g id="markunread">
                    <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"></path>
                </g>
                <g id="markunread-mailbox">
                    <path d="M20 6H10v6H8V4h6V0H6v6H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"></path>
                </g>
                <g id="menu">
                    <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path>
                </g>
                <g id="more-horiz">
                    <path d="M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path>
                </g>
                <g id="more-vert">
                    <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path>
                </g>
                <g id="note-add">
                    <path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 14h-3v3h-2v-3H8v-2h3v-3h2v3h3v2zm-3-7V3.5L18.5 9H13z"></path>
                </g>
                <g id="offline-pin">
                    <defs>
                        <path id="a" d="M0 0h24v24H0V0z"></path>
                    </defs>
                    <clipPath id="b">
                        <use xlink:href="#a" overflow="visible"></use>
                    </clipPath>
                    <path clip-path="url(#b)"
                          d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm5 16H7v-2h10v2zm-6.7-4L7 10.7l1.4-1.4 1.9 1.9 5.3-5.3L17 7.3 10.3 14z"></path>
                </g>
                <g id="open-in-browser">
                    <path d="M19 4H5c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h4v-2H5V8h14v10h-4v2h4c1.1 0 2-.9 2-2V6c0-1.1-.89-2-2-2zm-7 6l-4 4h3v6h2v-6h3l-4-4z"></path>
                </g>
                <g id="open-in-new">
                    <path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"></path>
                </g>
                <g id="open-with">
                    <path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"></path>
                </g>
                <g id="pageview">
                    <path d="M11.5 9C10.12 9 9 10.12 9 11.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5S12.88 9 11.5 9zM20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-3.21 14.21l-2.91-2.91c-.69.44-1.51.7-2.39.7C9.01 16 7 13.99 7 11.5S9.01 7 11.5 7 16 9.01 16 11.5c0 .88-.26 1.69-.7 2.39l2.91 2.9-1.42 1.42z"></path>
                </g>
                <g id="payment">
                    <path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"></path>
                </g>
                <g id="perm-camera-mic">
                    <path d="M20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v-2.09c-2.83-.48-5-2.94-5-5.91h2c0 2.21 1.79 4 4 4s4-1.79 4-4h2c0 2.97-2.17 5.43-5 5.91V21h7c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-6 8c0 1.1-.9 2-2 2s-2-.9-2-2V9c0-1.1.9-2 2-2s2 .9 2 2v4z"></path>
                </g>
                <g id="perm-contact-calendar">
                    <path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H6v-1c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1z"></path>
                </g>
                <g id="perm-data-setting">
                    <path d="M18.99 11.5c.34 0 .67.03 1 .07L20 0 0 20h11.56c-.04-.33-.07-.66-.07-1 0-4.14 3.36-7.5 7.5-7.5zm3.71 7.99c.02-.16.04-.32.04-.49 0-.17-.01-.33-.04-.49l1.06-.83c.09-.08.12-.21.06-.32l-1-1.73c-.06-.11-.19-.15-.31-.11l-1.24.5c-.26-.2-.54-.37-.85-.49l-.19-1.32c-.01-.12-.12-.21-.24-.21h-2c-.12 0-.23.09-.25.21l-.19 1.32c-.3.13-.59.29-.85.49l-1.24-.5c-.11-.04-.24 0-.31.11l-1 1.73c-.06.11-.04.24.06.32l1.06.83c-.02.16-.03.32-.03.49 0 .17.01.33.03.49l-1.06.83c-.09.08-.12.21-.06.32l1 1.73c.06.11.19.15.31.11l1.24-.5c.26.2.54.37.85.49l.19 1.32c.02.12.12.21.25.21h2c.12 0 .23-.09.25-.21l.19-1.32c.3-.13.59-.29.84-.49l1.25.5c.11.04.24 0 .31-.11l1-1.73c.06-.11.03-.24-.06-.32l-1.07-.83zm-3.71 1.01c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path>
                </g>
                <g id="perm-device-information">
                    <path d="M13 7h-2v2h2V7zm0 4h-2v6h2v-6zm4-9.99L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z"></path>
                </g>
                <g id="perm-identity">
                    <path d="M12 5.9c1.16 0 2.1.94 2.1 2.1s-.94 2.1-2.1 2.1S9.9 9.16 9.9 8s.94-2.1 2.1-2.1m0 9c2.97 0 6.1 1.46 6.1 2.1v1.1H5.9V17c0-.64 3.13-2.1 6.1-2.1M12 4C9.79 4 8 5.79 8 8s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 9c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"></path>
                </g>
                <g id="perm-media">
                    <path d="M2 6H0v5h.01L0 20c0 1.1.9 2 2 2h18v-2H2V6zm20-2h-8l-2-2H6c-1.1 0-1.99.9-1.99 2L4 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM7 15l4.5-6 3.5 4.51 2.5-3.01L21 15H7z"></path>
                </g>
                <g id="perm-phone-msg">
                    <path d="M20 15.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.58l2.2-2.21c.28-.27.36-.66.25-1.01C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM12 3v10l3-3h6V3h-9z"></path>
                </g>
                <g id="perm-scan-wifi">
                    <path d="M12 3C6.95 3 3.15 4.85 0 7.23L12 22 24 7.25C20.85 4.87 17.05 3 12 3zm1 13h-2v-6h2v6zm-2-8V6h2v2h-2z"></path>
                </g>
                <g id="picture-in-picture">
                    <path d="M19 7h-8v6h8V7zm2-4H3c-1.1 0-2 .9-2 2v14c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98V5c0-1.1-.9-2-2-2zm0 16.01H3V4.98h18v14.03z"></path>
                </g>
                <g id="play-for-work">
                    <path fill="#010101"
                          d="M11 5v5.59H7.5l4.5 4.5 4.5-4.5H13V5h-2zm-5 9c0 3.31 2.69 6 6 6s6-2.69 6-6h-2c0 2.21-1.79 4-4 4s-4-1.79-4-4H6z"></path>
                </g>
                <g id="polymer">
                    <path d="M19 4h-4L7.11 16.63 4.5 12 9 4H5L.5 12 5 20h4l7.89-12.63L19.5 12 15 20h4l4.5-8z"></path>
                </g>
                <g id="power-settings-new">
                    <path d="M13 3h-2v10h2V3zm4.83 2.17l-1.42 1.42C17.99 7.86 19 9.81 19 12c0 3.87-3.13 7-7 7s-7-3.13-7-7c0-2.19 1.01-4.14 2.58-5.42L6.17 5.17C4.23 6.82 3 9.26 3 12c0 4.97 4.03 9 9 9s9-4.03 9-9c0-2.74-1.23-5.18-3.17-6.83z"></path>
                </g>
                <g id="print">
                    <path d="M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z"></path>
                </g>
                <g id="query-builder">
                    <path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zM12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path>
                </g>
                <g id="question-answer">
                    <path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"></path>
                </g>
                <g id="radio-button-checked">
                    <path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path>
                </g>
                <g id="radio-button-unchecked">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path>
                </g>
                <g id="receipt">
                    <path d="M18 17H6v-2h12v2zm0-4H6v-2h12v2zm0-4H6V7h12v2zM3 22l1.5-1.5L6 22l1.5-1.5L9 22l1.5-1.5L12 22l1.5-1.5L15 22l1.5-1.5L18 22l1.5-1.5L21 22V2l-1.5 1.5L18 2l-1.5 1.5L15 2l-1.5 1.5L12 2l-1.5 1.5L9 2 7.5 3.5 6 2 4.5 3.5 3 2v20z"></path>
                </g>
                <g id="redeem">
                    <path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 11 8.76l1-1.36 1 1.36L15.38 12 17 10.83 14.92 8H20v6z"></path>
                </g>
                <g id="redo">
                    <path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"></path>
                </g>
                <g id="refresh">
                    <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path>
                </g>
                <g id="remove">
                    <path d="M19 13H5v-2h14v2z"></path>
                </g>
                <g id="remove-circle">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z"></path>
                </g>
                <g id="remove-circle-outline">
                    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path>
                </g>
                <g id="reorder">
                    <path d="M3 15h18v-2H3v2zm0 4h18v-2H3v2zm0-8h18V9H3v2zm0-6v2h18V5H3z"></path>
                </g>
                <g id="reply">
                    <path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"></path>
                </g>
                <g id="reply-all">
                    <path d="M7 8V5l-7 7 7 7v-3l-4-4 4-4zm6 1V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"></path>
                </g>
                <g id="report">
                    <path d="M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"></path>
                </g>
                <g id="report-problem">
                    <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"></path>
                </g>
                <g id="restore">
                    <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"></path>
                </g>
                <g id="room">
                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path>
                </g>
                <g id="save">
                    <path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"></path>
                </g>
                <g id="schedule">
                    <path fill-opacity=".9"
                          d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zM12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path>
                </g>
                <g id="search">
                    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </g>
                <g id="select-all">
                    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z"></path>
                </g>
                <g id="send">
                    <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path>
                </g>
                <g id="settings">
                    <path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"></path>
                </g>
                <g id="settings-applications">
                    <path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7-7H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-1.75 9c0 .23-.02.46-.05.68l1.48 1.16c.13.11.17.3.08.45l-1.4 2.42c-.09.15-.27.21-.43.15l-1.74-.7c-.36.28-.76.51-1.18.69l-.26 1.85c-.03.17-.18.3-.35.3h-2.8c-.17 0-.32-.13-.35-.29l-.26-1.85c-.43-.18-.82-.41-1.18-.69l-1.74.7c-.16.06-.34 0-.43-.15l-1.4-2.42c-.09-.15-.05-.34.08-.45l1.48-1.16c-.03-.23-.05-.46-.05-.69 0-.23.02-.46.05-.68l-1.48-1.16c-.13-.11-.17-.3-.08-.45l1.4-2.42c.09-.15.27-.21.43-.15l1.74.7c.36-.28.76-.51 1.18-.69l.26-1.85c.03-.17.18-.3.35-.3h2.8c.17 0 .32.13.35.29l.26 1.85c.43.18.82.41 1.18.69l1.74-.7c.16-.06.34 0 .43.15l1.4 2.42c.09.15.05.34-.08.45l-1.48 1.16c.03.23.05.46.05.69z"></path>
                </g>
                <g id="settings-backup-restore">
                    <path d="M14 12c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2 2-.9 2-2zm-2-9c-4.97 0-9 4.03-9 9H0l4 4 4-4H5c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.51 0-2.91-.49-4.06-1.3l-1.42 1.44C8.04 20.3 9.94 21 12 21c4.97 0 9-4.03 9-9s-4.03-9-9-9z"></path>
                </g>
                <g id="settings-bluetooth">
                    <path d="M11 24h2v-2h-2v2zm-4 0h2v-2H7v2zm8 0h2v-2h-2v2zm2.71-18.29L12 0h-1v7.59L6.41 3 5 4.41 10.59 10 5 15.59 6.41 17 11 12.41V20h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 3.83l1.88 1.88L13 7.59V3.83zm1.88 10.46L13 16.17v-3.76l1.88 1.88z"></path>
                </g>
                <g id="settings-brightness">
                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02zM8 16h2.5l1.5 1.5 1.5-1.5H16v-2.5l1.5-1.5-1.5-1.5V8h-2.5L12 6.5 10.5 8H8v2.5L6.5 12 8 13.5V16zm4-7c1.66 0 3 1.34 3 3s-1.34 3-3 3V9z"></path>
                </g>
                <g id="settings-cell">
                    <path d="M7 24h2v-2H7v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zM16 .01L8 0C6.9 0 6 .9 6 2v16c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V2c0-1.1-.9-1.99-2-1.99zM16 16H8V4h8v12z"></path>
                </g>
                <g id="settings-ethernet">
                    <path d="M7.77 6.76L6.23 5.48.82 12l5.41 6.52 1.54-1.28L3.42 12l4.35-5.24zM7 13h2v-2H7v2zm10-2h-2v2h2v-2zm-6 2h2v-2h-2v2zm6.77-7.52l-1.54 1.28L20.58 12l-4.35 5.24 1.54 1.28L23.18 12l-5.41-6.52z"></path>
                </g>
                <g id="settings-input-antenna">
                    <path d="M12 5c-3.87 0-7 3.13-7 7h2c0-2.76 2.24-5 5-5s5 2.24 5 5h2c0-3.87-3.13-7-7-7zm1 9.29c.88-.39 1.5-1.26 1.5-2.29 0-1.38-1.12-2.5-2.5-2.5S9.5 10.62 9.5 12c0 1.02.62 1.9 1.5 2.29v3.3L7.59 21 9 22.41l3-3 3 3L16.41 21 13 17.59v-3.3zM12 1C5.93 1 1 5.93 1 12h2c0-4.97 4.03-9 9-9s9 4.03 9 9h2c0-6.07-4.93-11-11-11z"></path>
                </g>
                <g id="settings-input-component">
                    <path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"></path>
                </g>
                <g id="settings-input-composite">
                    <path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"></path>
                </g>
                <g id="settings-input-hdmi">
                    <path d="M18 7V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v3H5v6l3 6v3h8v-3l3-6V7h-1zM8 4h8v3h-2V5h-1v2h-2V5h-1v2H8V4z"></path>
                </g>
                <g id="settings-input-svideo">
                    <path d="M8 11.5c0-.83-.67-1.5-1.5-1.5S5 10.67 5 11.5 5.67 13 6.5 13 8 12.33 8 11.5zm7-5c0-.83-.67-1.5-1.5-1.5h-3C9.67 5 9 5.67 9 6.5S9.67 8 10.5 8h3c.83 0 1.5-.67 1.5-1.5zM8.5 15c-.83 0-1.5.67-1.5 1.5S7.67 18 8.5 18s1.5-.67 1.5-1.5S9.33 15 8.5 15zM12 1C5.93 1 1 5.93 1 12s4.93 11 11 11 11-4.93 11-11S18.07 1 12 1zm0 20c-4.96 0-9-4.04-9-9s4.04-9 9-9 9 4.04 9 9-4.04 9-9 9zm5.5-11c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm-2 5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path>
                </g>
                <g id="settings-overscan">
                    <path d="M12.01 5.5L10 8h4l-1.99-2.5zM18 10v4l2.5-1.99L18 10zM6 10l-2.5 2.01L6 14v-4zm8 6h-4l2.01 2.5L14 16zm7-13H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z"></path>
                </g>
                <g id="settings-phone">
                    <path d="M13 9h-2v2h2V9zm4 0h-2v2h2V9zm3 6.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.58l2.2-2.21c.28-.27.36-.66.25-1.01C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM19 9v2h2V9h-2z"></path>
                </g>
                <g id="settings-power">
                    <path d="M7 24h2v-2H7v2zm4 0h2v-2h-2v2zm2-22h-2v10h2V2zm3.56 2.44l-1.45 1.45C16.84 6.94 18 8.83 18 11c0 3.31-2.69 6-6 6s-6-2.69-6-6c0-2.17 1.16-4.06 2.88-5.12L7.44 4.44C5.36 5.88 4 8.28 4 11c0 4.42 3.58 8 8 8s8-3.58 8-8c0-2.72-1.36-5.12-3.44-6.56zM15 24h2v-2h-2v2z"></path>
                </g>
                <g id="settings-remote">
                    <path d="M15 9H9c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V10c0-.55-.45-1-1-1zm-3 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM7.05 6.05l1.41 1.41C9.37 6.56 10.62 6 12 6s2.63.56 3.54 1.46l1.41-1.41C15.68 4.78 13.93 4 12 4s-3.68.78-4.95 2.05zM12 0C8.96 0 6.21 1.23 4.22 3.22l1.41 1.41C7.26 3.01 9.51 2 12 2s4.74 1.01 6.36 2.64l1.41-1.41C17.79 1.23 15.04 0 12 0z"></path>
                </g>
                <g id="settings-voice">
                    <path d="M7 24h2v-2H7v2zm5-11c1.66 0 2.99-1.34 2.99-3L15 4c0-1.66-1.34-3-3-3S9 2.34 9 4v6c0 1.66 1.34 3 3 3zm-1 11h2v-2h-2v2zm4 0h2v-2h-2v2zm4-14h-1.7c0 3-2.54 5.1-5.3 5.1S6.7 13 6.7 10H5c0 3.41 2.72 6.23 6 6.72V20h2v-3.28c3.28-.49 6-3.31 6-6.72z"></path>
                </g>
                <g id="shop">
                    <path d="M16 6V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H2v13c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6h-6zm-6-2h4v2h-4V4zM9 18V9l7.5 4L9 18z"></path>
                </g>
                <g id="shop-two">
                    <path d="M3 9H1v11c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2H3V9zm15-4V3c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H5v11c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2V5h-5zm-6-2h4v2h-4V3zm0 12V8l5.5 3-5.5 4z"></path>
                </g>
                <g id="shopping-basket">
                    <path d="M17.21 9l-4.38-6.56c-.19-.28-.51-.42-.83-.42-.32 0-.64.14-.83.43L6.79 9H2c-.55 0-1 .45-1 1 0 .09.01.18.04.27l2.54 9.27c.23.84 1 1.46 1.92 1.46h13c.92 0 1.69-.62 1.93-1.46l2.54-9.27L23 10c0-.55-.45-1-1-1h-4.79zM9 9l3-4.4L15 9H9zm3 8c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path>
                </g>
                <g id="shopping-cart">
                    <path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z"></path>
                </g>
                <g id="sort">
                    <path d="M3 18h6v-2H3v2zM3 6v2h18V6H3zm0 7h12v-2H3v2z"></path>
                </g>
                <g id="speaker-notes">
                    <path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 14H6v-2h2v2zm0-3H6V9h2v2zm0-3H6V6h2v2zm7 6h-5v-2h5v2zm3-3h-8V9h8v2zm0-3h-8V6h8v2z"></path>
                </g>
                <g id="spellcheck">
                    <path d="M12.45 16h2.09L9.43 3H7.57L2.46 16h2.09l1.12-3h5.64l1.14 3zm-6.02-5L8.5 5.48 10.57 11H6.43zm15.16.59l-8.09 8.09L9.83 16l-1.41 1.41 5.09 5.09L23 13l-1.41-1.41z"></path>
                </g>
                <g id="star">
                    <path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path>
                </g>
                <g id="star-border">
                    <path d="M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"></path>
                </g>
                <g id="star-half">
                    <path d="M22 9.74l-7.19-.62L12 2.5 9.19 9.13 2 9.74l5.46 4.73-1.64 7.03L12 17.77l6.18 3.73-1.63-7.03L22 9.74zM12 15.9V6.6l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.9z"></path>
                </g>
                <g id="stars">
                    <path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm4.24 16L12 15.45 7.77 18l1.12-4.81-3.73-3.23 4.92-.42L12 5l1.92 4.53 4.92.42-3.73 3.23L16.23 18z"></path>
                </g>
                <g id="store">
                    <path d="M20 4H4v2h16V4zm1 10v-2l-1-5H4l-1 5v2h1v6h10v-6h4v6h2v-6h1zm-9 4H6v-4h6v4z"></path>
                </g>
                <g id="subject">
                    <path d="M14 17H4v2h10v-2zm6-8H4v2h16V9zM4 15h16v-2H4v2zM4 5v2h16V5H4z"></path>
                </g>
                <g id="supervisor-account">
                    <path d="M16.5 12c1.38 0 2.49-1.12 2.49-2.5S17.88 7 16.5 7C15.12 7 14 8.12 14 9.5s1.12 2.5 2.5 2.5zM9 11c1.66 0 2.99-1.34 2.99-3S10.66 5 9 5C7.34 5 6 6.34 6 8s1.34 3 3 3zm7.5 3c-1.83 0-5.5.92-5.5 2.75V19h11v-2.25c0-1.83-3.67-2.75-5.5-2.75zM9 13c-2.33 0-7 1.17-7 3.5V19h7v-2.25c0-.85.33-2.34 2.37-3.47C10.5 13.1 9.66 13 9 13z"></path>
                </g>
                <g id="swap-horiz">
                    <path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"></path>
                </g>
                <g id="swap-vert">
                    <path d="M16 17.01V10h-2v7.01h-3L15 21l4-3.99h-3zM9 3L5 6.99h3V14h2V6.99h3L9 3z"></path>
                </g>
                <g id="swap-vertical-circle">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM6.5 9L10 5.5 13.5 9H11v4H9V9H6.5zm11 6L14 18.5 10.5 15H13v-4h2v4h2.5z"></path>
                </g>
                <g id="system-update-alt">
                    <path d="M12 16.5l4-4h-3v-9h-2v9H8l4 4zm9-13h-6v1.99h6v14.03H3V5.49h6V3.5H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2z"></path>
                </g>
                <g id="tab">
                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h10v4h8v10z"></path>
                </g>
                <g id="tab-unselected">
                    <path d="M1 9h2V7H1v2zm0 4h2v-2H1v2zm0-8h2V3c-1.1 0-2 .9-2 2zm8 16h2v-2H9v2zm-8-4h2v-2H1v2zm2 4v-2H1c0 1.1.9 2 2 2zM21 3h-8v6h10V5c0-1.1-.9-2-2-2zm0 14h2v-2h-2v2zM9 5h2V3H9v2zM5 21h2v-2H5v2zM5 5h2V3H5v2zm16 16c1.1 0 2-.9 2-2h-2v2zm0-8h2v-2h-2v2zm-8 8h2v-2h-2v2zm4 0h2v-2h-2v2z"></path>
                </g>
                <g id="text-format">
                    <path d="M5 17v2h14v-2H5zm4.5-4.2h5l.9 2.2h2.1L12.75 4h-1.5L6.5 15h2.1l.9-2.2zM12 5.98L13.87 11h-3.74L12 5.98z"></path>
                </g>
                <g id="theaters">
                    <path d="M18 3v2h-2V3H8v2H6V3H4v18h2v-2h2v2h8v-2h2v2h2V3h-2zM8 17H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2zm10 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2z"></path>
                </g>
                <g id="thumb-down">
                    <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v1.91l.01.01L1 14c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"></path>
                </g>
                <g id="thumb-up">
                    <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01L23 10z"></path>
                </g>
                <g id="thumbs-up-down">
                    <path d="M12 6c0-.55-.45-1-1-1H5.82l.66-3.18.02-.23c0-.31-.13-.59-.33-.8L5.38 0 .44 4.94C.17 5.21 0 5.59 0 6v6.5c0 .83.67 1.5 1.5 1.5h6.75c.62 0 1.15-.38 1.38-.91l2.26-5.29c.07-.17.11-.36.11-.55V6zm10.5 4h-6.75c-.62 0-1.15.38-1.38.91l-2.26 5.29c-.07.17-.11.36-.11.55V18c0 .55.45 1 1 1h5.18l-.66 3.18-.02.24c0 .31.13.59.33.8l.79.78 4.94-4.94c.27-.27.44-.65.44-1.06v-6.5c0-.83-.67-1.5-1.5-1.5z"></path>
                </g>
                <g id="toc">
                    <path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z"></path>
                </g>
                <g id="today">
                    <path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"></path>
                </g>
                <g id="toll">
                    <path d="M15 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zM3 12c0-2.61 1.67-4.83 4-5.65V4.26C3.55 5.15 1 8.27 1 12s2.55 6.85 6 7.74v-2.09c-2.33-.82-4-3.04-4-5.65z"></path>
                </g>
                <g id="track-changes">
                    <path fill="#231F20"
                          d="M19.07 4.93l-1.41 1.41C19.1 7.79 20 9.79 20 12c0 4.42-3.58 8-8 8s-8-3.58-8-8c0-4.08 3.05-7.44 7-7.93v2.02C8.16 6.57 6 9.03 6 12c0 3.31 2.69 6 6 6s6-2.69 6-6c0-1.66-.67-3.16-1.76-4.24l-1.41 1.41C15.55 9.9 16 10.9 16 12c0 2.21-1.79 4-4 4s-4-1.79-4-4c0-1.86 1.28-3.41 3-3.86v2.14c-.6.35-1 .98-1 1.72 0 1.1.9 2 2 2s2-.9 2-2c0-.74-.4-1.38-1-1.72V2h-1C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10c0-2.76-1.12-5.26-2.93-7.07z"></path>
                </g>
                <g id="translate">
                    <path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path>
                </g>
                <g id="trending-down">
                    <path d="M16 18l2.29-2.29-4.88-4.88-4 4L2 7.41 3.41 6l6 6 4-4 6.3 6.29L22 12v6z"></path>
                </g>
                <g id="trending-flat">
                    <path d="M22 12l-4-4v3H3v2h15v3z"></path>
                </g>
                <g id="trending-up">
                    <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"></path>
                </g>
                <g id="turned-in">
                    <path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z"></path>
                </g>
                <g id="turned-in-not">
                    <path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2zm0 15l-5-2.18L7 18V5h10v13z"></path>
                </g>
                <g id="undo">
                    <path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"></path>
                </g>
                <g id="unfold-less">
                    <path d="M7.41 18.59L8.83 20 12 16.83 15.17 20l1.41-1.41L12 14l-4.59 4.59zm9.18-13.18L15.17 4 12 7.17 8.83 4 7.41 5.41 12 10l4.59-4.59z"></path>
                </g>
                <g id="unfold-more">
                    <path d="M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"></path>
                </g>
                <g id="verified-user">
                    <path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"></path>
                </g>
                <g id="view-agenda">
                    <path d="M20 13H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zm0-10H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"></path>
                </g>
                <g id="view-array">
                    <path d="M4 18h3V5H4v13zM18 5v13h3V5h-3zM8 18h9V5H8v13z"></path>
                </g>
                <g id="view-carousel">
                    <path d="M7 19h10V4H7v15zm-5-2h4V6H2v11zM18 6v11h4V6h-4z"></path>
                </g>
                <g id="view-column">
                    <path d="M10 18h5V5h-5v13zm-6 0h5V5H4v13zM16 5v13h5V5h-5z"></path>
                </g>
                <g id="view-day">
                    <path d="M2 21h19v-3H2v3zM20 8H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zM2 3v3h19V3H2z"></path>
                </g>
                <g id="view-headline">
                    <path d="M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"></path>
                </g>
                <g id="view-list">
                    <path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"></path>
                </g>
                <g id="view-module">
                    <path d="M4 11h5V5H4v6zm0 7h5v-6H4v6zm6 0h5v-6h-5v6zm6 0h5v-6h-5v6zm-6-7h5V5h-5v6zm6-6v6h5V5h-5z"></path>
                </g>
                <g id="view-quilt">
                    <path d="M10 18h5v-6h-5v6zm-6 0h5V5H4v13zm12 0h5v-6h-5v6zM10 5v6h11V5H10z"></path>
                </g>
                <g id="view-stream">
                    <path d="M4 18h17v-6H4v6zM4 5v6h17V5H4z"></path>
                </g>
                <g id="view-week">
                    <path d="M6 5H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm14 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-7 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z"></path>
                </g>
                <g id="visibility">
                    <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"></path>
                </g>
                <g id="visibility-off">
                    <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"></path>
                </g>
                <g id="warning">
                    <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"></path>
                </g>
                <g id="work">
                    <path d="M20 6h-4V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-6 0h-4V4h4v2z"></path>
                </g>
                <g id="youtube-searched-for">
                    <path d="M17.01 14h-.8l-.27-.27c.98-1.14 1.57-2.61 1.57-4.23 0-3.59-2.91-6.5-6.5-6.5s-6.5 3-6.5 6.5H2l3.84 4 4.16-4H6.51C6.51 7 8.53 5 11.01 5s4.5 2.01 4.5 4.5c0 2.48-2.02 4.5-4.5 4.5-.65 0-1.26-.14-1.82-.38L7.71 15.1c.97.57 2.09.9 3.3.9 1.61 0 3.08-.59 4.22-1.57l.27.27v.79l5.01 4.99L22 19l-4.99-5z"></path>
                </g>
                <g id="zoom-in">
                    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"></path>
                </g>
                <g id="zoom-out">
                    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z"></path>
                </g>
            </defs>
        </svg>
    </iron-iconset-svg>
    <dom-module id="paper-input-container" assetpath="../components/paper-input/">
        <template>

            <style>
                :host {
                    display: block;
                    padding: 8px 0;

                    @apply(--paper-input-container);
                }

                :host[inline] {
                    display: inline-block;
                }

                :host([disabled]) {
                    pointer-events: none;
                    opacity: 0.33;

                    @apply(--paper-input-container-disabled);
                }

                .floated-label-placeholder {
                    @apply(--paper-font-caption);
                }

                .underline {
                    position: relative;
                }

                .focused-line {
                    height: 2px;

                    -webkit-transform-origin: center center;
                    transform-origin: center center;
                    -webkit-transform: scale3d(0, 1, 1);
                    transform: scale3d(0, 1, 1);

                    background: var(--paper-input-container-focus-color, --default-primary-color);

                    @apply(--paper-input-container-underline-focus);
                }

                .underline.is-highlighted .focused-line {
                    -webkit-transform: none;
                    transform: none;
                    -webkit-transition: -webkit-transform 0.25s;
                    transition: transform 0.25s;

                    @apply(--paper-transition-easing);
                }

                .underline.is-invalid .focused-line {
                    background: var(--paper-input-container-invalid-color, --google-red-500);

                    -webkit-transform: none;
                    transform: none;
                    -webkit-transition: -webkit-transform 0.25s;
                    transition: transform 0.25s;

                    @apply(--paper-transition-easing);
                }

                .unfocused-line {
                    height: 1px;
                    background: var(--paper-input-container-color, --secondary-text-color);

                    @apply(--paper-input-container-underline);
                }

                :host([disabled]) .unfocused-line {
                    border-bottom: 1px dashed;
                    border-color: var(--paper-input-container-color, --secondary-text-color);
                    background: transparent;

                    @apply(--paper-input-container-underline-disabled);
                }

                .label-and-input-container {
                    @apply(--layout-flex);
                    @apply(--layout-relative);
                }

                .input-content {
                    position: relative;
                    @apply(--layout-horizontal);
                    @apply(--layout-end);
                }

                .input-content ::content label,
                .input-content ::content .paper-input-label {
                    position: absolute;
                    top: 0;
                    right: 0;
                    left: 0;
                    font: inherit;
                    color: var(--paper-input-container-color, --secondary-text-color);

                    @apply(--paper-font-common-nowrap);
                    @apply(--paper-font-subhead);
                    @apply(--paper-input-container-label);
                }

                .input-content.label-is-floating ::content label,
                .input-content.label-is-floating ::content .paper-input-label {
                    -webkit-transform: translateY(-75%) scale(0.75);
                    transform: translateY(-75%) scale(0.75);
                    -webkit-transition: -webkit-transform 0.25s;
                    transition: transform 0.25s;

                    -webkit-transform-origin: left top;
                    transform-origin: left top;

                    /* Since we scale to 75/100 of the size, we actually have 100/75 of the
        original space now available */
                    width: 133%;

                    @apply(--paper-transition-easing);
                }

                :host-context([dir="rtl"]) .input-content.label-is-floating ::content label,
                :host-context([dir="rtl"]) .input-content.label-is-floating ::content .paper-input-label {
                    /* TODO(noms): Figure out why leaving the width at 133% before the animation
         * actually makes
         * it wider on the right side, not left side, as you would expect in RTL */
                    width: 100%;
                    -webkit-transform-origin: right top;
                    transform-origin: right top;
                }

                .input-content.label-is-highlighted ::content label,
                .input-content.label-is-highlighted ::content .paper-input-label {
                    color: var(--paper-input-container-focus-color, --default-primary-color);

                    @apply(--paper-input-container-label-focus);
                }

                .input-content.is-invalid ::content label,
                .input-content.is-invalid ::content .paper-input-label {
                    color: var(--paper-input-container-invalid-color, --google-red-500);
                }

                .input-content.label-is-hidden ::content label,
                .input-content.label-is-hidden ::content .paper-input-label {
                    visibility: hidden;
                }

                .input-content ::content input,
                .input-content ::content textarea,
                .input-content ::content iron-autogrow-textarea,
                .input-content ::content .paper-input-input {
                    position: relative; /* to make a stacking context */
                    outline: none;
                    box-shadow: none;
                    padding: 0;
                    width: 100%;
                    background: transparent;
                    border: none;
                    color: var(--paper-input-container-input-color, --primary-text-color);
                    -webkit-appearance: none;
                    text-align: inherit;

                    @apply(--paper-font-subhead);
                    @apply(--paper-input-container-input);
                }

                ::content [prefix] {
                    @apply(--paper-font-subhead);
                    @apply(--paper-input-prefix);
                }

                ::content [suffix] {
                    @apply(--paper-font-subhead);
                    @apply(--paper-input-suffix);
                }

                /* Firefox sets a min-width on the input, which can cause layout issues */
                .input-content ::content input {
                    min-width: 0;
                }

                .input-content ::content textarea {
                    resize: none;
                }

                .add-on-content {
                    position: relative;
                }

                .add-on-content.is-invalid ::content * {
                    color: var(--paper-input-container-invalid-color, --google-red-500);
                }

                .add-on-content.is-highlighted ::content * {
                    color: var(--paper-input-container-focus-color, --default-primary-color);
                }
            </style>

            <template is="dom-if" if="[[!noLabelFloat]]">
                <div class="floated-label-placeholder">&nbsp;</div>
            </template>

            <div class$="[[_computeInputContentClass(noLabelFloat,alwaysFloatLabel,focused,invalid,_inputHasContent)]]">
                <content select="[prefix]" id="prefix"></content>

                <div class="label-and-input-container" id="labelAndInputContainer">
                    <content select=":not([add-on]):not([prefix]):not([suffix])"></content>
                </div>
                <content select="[suffix]"></content>
            </div>

            <div class$="[[_computeUnderlineClass(focused,invalid)]]">
                <div class="unfocused-line fit"></div>
                <div class="focused-line fit"></div>
            </div>

            <div class$="[[_computeAddOnContentClass(focused,invalid)]]">
                <content id="addOnContent" select="[add-on]"></content>
            </div>

        </template>
    </dom-module>

    <script>
        Polymer({
            is: 'paper-input-container',

            properties: {
                /**
                 * Set to true to disable the floating label. The label disappears when the input value is
                 * not null.
                 */
                noLabelFloat: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Set to true to always float the floating label.
                 */
                alwaysFloatLabel: {
                    type: Boolean,
                    value: false
                },

                /**
                 * The attribute to listen for value changes on.
                 */
                attrForValue: {
                    type: String,
                    value: 'bind-value'
                },

                /**
                 * Set to true to auto-validate the input value when it changes.
                 */
                autoValidate: {
                    type: Boolean,
                    value: false
                },

                /**
                 * True if the input is invalid. This property is set automatically when the input value
                 * changes if auto-validating, or when the `iron-input-validate` event is heard from a child.
                 */
                invalid: {
                    observer: '_invalidChanged',
                    type: Boolean,
                    value: false
                },

                /**
                 * True if the input has focus.
                 */
                focused: {
                    readOnly: true,
                    type: Boolean,
                    value: false,
                    notify: true
                },

                _addons: {
                    type: Array
                    // do not set a default value here intentionally - it will be initialized lazily when a
                    // distributed child is attached, which may occur before configuration for this element
                    // in polyfill.
                },

                _inputHasContent: {
                    type: Boolean,
                    value: false
                },

                _inputSelector: {
                    type: String,
                    value: 'input,textarea,.paper-input-input'
                },

                _boundOnFocus: {
                    type: Function,
                    value: function () {
                        return this._onFocus.bind(this);
                    }
                },

                _boundOnBlur: {
                    type: Function,
                    value: function () {
                        return this._onBlur.bind(this);
                    }
                },

                _boundOnInput: {
                    type: Function,
                    value: function () {
                        return this._onInput.bind(this);
                    }
                },

                _boundValueChanged: {
                    type: Function,
                    value: function () {
                        return this._onValueChanged.bind(this);
                    }
                }
            },

            listeners: {
                'addon-attached': '_onAddonAttached',
                'iron-input-validate': '_onIronInputValidate'
            },

            get _valueChangedEvent() {
                return this.attrForValue + '-changed';
            },

            get _propertyForValue() {
                return Polymer.CaseMap.dashToCamelCase(this.attrForValue);
            },

            get _inputElement() {
                return Polymer.dom(this).querySelector(this._inputSelector);
            },

            get _inputElementValue() {
                return this._inputElement[this._propertyForValue] || this._inputElement.value;
            },

            ready: function () {
                if (!this._addons) {
                    this._addons = [];
                }
                this.addEventListener('focus', this._boundOnFocus, true);
                this.addEventListener('blur', this._boundOnBlur, true);
                if (this.attrForValue) {
                    this._inputElement.addEventListener(this._valueChangedEvent, this._boundValueChanged);
                } else {
                    this.addEventListener('input', this._onInput);
                }
            },

            attached: function () {
                // Only validate when attached if the input already has a value.
                if (this._inputElementValue != '') {
                    this._handleValueAndAutoValidate(this._inputElement);
                } else {
                    this._handleValue(this._inputElement);
                }

                this._numberOfPrefixNodes = 0;
                this._prefixObserver = Polymer.dom(this.$.prefix).observeNodes(
                        function (mutations) {
                            // Keep track whether there's at least one prefix node, since it
                            // affects laying out the floating label.
                            this._numberOfPrefixNodes += mutations.addedNodes.length -
                                    mutations.removedNodes.length;
                        }.bind(this));
            },

            detached: function () {
                if (this._prefixObserver) {
                    Polymer.dom(this.$.prefix).unobserveNodes(this._prefixObserver);
                }
            },

            _onAddonAttached: function (event) {
                if (!this._addons) {
                    this._addons = [];
                }
                var target = event.target;
                if (this._addons.indexOf(target) === -1) {
                    this._addons.push(target);
                    if (this.isAttached) {
                        this._handleValue(this._inputElement);
                    }
                }
            },

            _onFocus: function () {
                this._setFocused(true);
            },

            _onBlur: function () {
                this._setFocused(false);
                this._handleValueAndAutoValidate(this._inputElement);
            },

            _onInput: function (event) {
                this._handleValueAndAutoValidate(event.target);
            },

            _onValueChanged: function (event) {
                this._handleValueAndAutoValidate(event.target);
            },

            _handleValue: function (inputElement) {
                var value = this._inputElementValue;

                // type="number" hack needed because this.value is empty until it's valid
                if (value || value === 0 || (inputElement.type === 'number' && !inputElement.checkValidity())) {
                    this._inputHasContent = true;
                } else {
                    this._inputHasContent = false;
                }

                this.updateAddons({
                    inputElement: inputElement,
                    value: value,
                    invalid: this.invalid
                });
            },

            _handleValueAndAutoValidate: function (inputElement) {
                if (this.autoValidate) {
                    var valid;
                    if (inputElement.validate) {
                        valid = inputElement.validate(this._inputElementValue);
                    } else {
                        valid = inputElement.checkValidity();
                    }
                    this.invalid = !valid;
                }

                // Call this last to notify the add-ons.
                this._handleValue(inputElement);
            },

            _onIronInputValidate: function (event) {
                this.invalid = this._inputElement.invalid;
            },

            _invalidChanged: function () {
                if (this._addons) {
                    this.updateAddons({invalid: this.invalid});
                }
            },

            /**
             * Call this to update the state of add-ons.
             * @param {Object} state Add-on state.
             */
            updateAddons: function (state) {
                for (var addon, index = 0; addon = this._addons[index]; index++) {
                    addon.update(state);
                }
            },

            _computeInputContentClass: function (noLabelFloat, alwaysFloatLabel, focused, invalid, _inputHasContent) {
                var cls = 'input-content';
                if (!noLabelFloat) {
                    var label = this.querySelector('label');

                    if (alwaysFloatLabel || _inputHasContent) {
                        cls += ' label-is-floating';
                        if (invalid) {
                            cls += ' is-invalid';
                        } else if (focused) {
                            cls += " label-is-highlighted";
                        }
                        // If a prefix element exists, the label has a horizontal offset
                        // which needs to be undone when displayed as a floating label.
                        if (this._numberOfPrefixNodes > 0) {
                            this.$.labelAndInputContainer.style.position = 'static';
                        }
                    } else {
                        // When the label is not floating, it should overlap the input element.
                        if (label) {
                            this.$.labelAndInputContainer.style.position = 'relative';
                        }
                    }
                } else {
                    if (_inputHasContent) {
                        cls += ' label-is-hidden';
                    }
                }
                return cls;
            },

            _computeUnderlineClass: function (focused, invalid) {
                var cls = 'underline';
                if (invalid) {
                    cls += ' is-invalid';
                } else if (focused) {
                    cls += ' is-highlighted'
                }
                return cls;
            },

            _computeAddOnContentClass: function (focused, invalid) {
                var cls = 'add-on-content';
                if (invalid) {
                    cls += ' is-invalid';
                } else if (focused) {
                    cls += ' is-highlighted'
                }
                return cls;
            }
        });
    </script>
    <dom-module id="paper-input-error" assetpath="../components/paper-input/">
        <template>

            <style>
                :host {
                    display: inline-block;
                    visibility: hidden;

                    color: var(--paper-input-container-invalid-color, --google-red-500);

                    @apply(--paper-font-caption);
                    @apply(--paper-input-error);
                    position: absolute;
                    left: 0;
                    right: 0;
                }

                :host([invalid]) {
                    visibility: visible;
                }

                ;
            </style>

            <content></content>

        </template>
    </dom-module>

    <script>
        Polymer({
            is: 'paper-input-error',

            behaviors: [
                Polymer.PaperInputAddonBehavior
            ],

            properties: {
                /**
                 * True if the error is showing.
                 */
                invalid: {
                    readOnly: true,
                    reflectToAttribute: true,
                    type: Boolean
                }
            },

            update: function (state) {
                this._setInvalid(state.invalid);
            }
        });
    </script>
    <dom-module id="paper-input-char-counter" assetpath="../components/paper-input/">
        <template>

            <style>
                :host {
                    display: inline-block;
                    float: right;

                    @apply(--paper-font-caption);
                    @apply(--paper-input-char-counter);
                }

                :host-context([dir="rtl"]) {
                    float: left;
                }
            </style>

            <span>[[_charCounterStr]]</span>

        </template>
    </dom-module>

    <script>
        Polymer({
            is: 'paper-input-char-counter',

            behaviors: [
                Polymer.PaperInputAddonBehavior
            ],

            properties: {
                _charCounterStr: {
                    type: String,
                    value: '0'
                }
            },

            update: function (state) {
                if (!state.inputElement) {
                    return;
                }

                state.value = state.value || '';

                // Account for the textarea's new lines.
                var str = state.value.replace(/(\r\n|\n|\r)/g, '--').length;

                if (state.inputElement.hasAttribute('maxlength')) {
                    str += '/' + state.inputElement.getAttribute('maxlength');
                }
                this._charCounterStr = str;
            }
        });
    </script>
    <dom-module id="paper-input" assetpath="../components/paper-input/">
        <template>

            <style>
                :host {
                    display: block;
                }

                input::-webkit-input-placeholder {
                    color: var(--paper-input-container-color, --secondary-text-color);
                }

                input:-moz-placeholder {
                    color: var(--paper-input-container-color, --secondary-text-color);
                }

                input::-moz-placeholder {
                    color: var(--paper-input-container-color, --secondary-text-color);
                }

                input:-ms-input-placeholder {
                    color: var(--paper-input-container-color, --secondary-text-color);
                }
            </style>

            <paper-input-container no-label-float="[[noLabelFloat]]"
                                   always-float-label="[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]"
                                   auto-validate$="[[autoValidate]]" disabled$="[[disabled]]" invalid="[[invalid]]">

                <content select="[prefix]"></content>

                <label hidden$="[[!label]]">[[label]]</label>

                <input is="iron-input" id="input" aria-labelledby$="[[_ariaLabelledBy]]"
                       aria-describedby$="[[_ariaDescribedBy]]" disabled$="[[disabled]]" bind-value="{{ value }}"
                       invalid="{{ invalid }}" prevent-invalid-input="[[preventInvalidInput]]"
                       allowed-pattern="[[allowedPattern]]" validator="[[validator]]" type$="[[type]]"
                       pattern$="[[pattern]]" required$="[[required]]" autocomplete$="[[autocomplete]]"
                       autofocus$="[[autofocus]]" inputmode$="[[inputmode]]" minlength$="[[minlength]]"
                       maxlength$="[[maxlength]]" min$="[[min]]" max$="[[max]]" step$="[[step]]" name$="[[name]]"
                       placeholder$="[[placeholder]]" readonly$="[[readonly]]" list$="[[list]]" size$="[[size]]"
                       autocapitalize$="[[autocapitalize]]" autocorrect$="[[autocorrect]]" on-change="_onChange"
                       autosave$="[[autosave]]" results$="[[results]]" accept$="[[accept]]" multiple$="[[multiple]]">

                <content select="[suffix]"></content>

                <template is="dom-if" if="[[errorMessage]]">
                    <paper-input-error>[[errorMessage]]</paper-input-error>
                </template>

                <template is="dom-if" if="[[charCounter]]">
                    <paper-input-char-counter></paper-input-char-counter>
                </template>

            </paper-input-container>

        </template>
    </dom-module>

    <script>
        Polymer({
            is: 'paper-input',

            behaviors: [
                Polymer.IronFormElementBehavior,
                Polymer.PaperInputBehavior,
                Polymer.IronControlState
            ]
        });
    </script>
    <dom-module id="wrapped-iframe" assetpath="../components/wrapped-iframe/">

        <style>
            :host {
                display: flex;
                flex-wrap: wrap;
                flex-direction: column;

            }

            paper-icon-button {
                color: var(--paper-red-300);
                --paper-icon-button-ink-color: var(--paper-grey-a100);
                --iron-icon-width: 10px;
                --iron-icon-height: 10px;
                padding: 0px 6px;
            }

            div {
                display: flex;
                flex: 1 1 100%;
            }

            input {
                width: 200px;
                height: 30px;
            }

            iframe {
                flex: 1 1 100%;
            }
        </style>

        <template>
            <div style="position: absolute;bottom:0;left:0;right:0;top:0;display: flex;justify-content: center;align-content: center;align-items: center;">
                <paper-spinner active="true"></paper-spinner>
            </div>
            <div style="display: flex;align-items: center;align-content: center;flex: 0 0 10%">
                <paper-icon-button icon="arrow-back" on-tap="back"></paper-icon-button>
                <paper-icon-button icon="arrow-forward" on-tap="forward"></paper-icon-button>
                <paper-input no-label-float="true" label="path" value="{{ path::input}}" on-keydown="checkforenter">
                    <span prefix="">{{ baseurl }}</span>
                    <paper-icon-button suffix="" icon="clear"></paper-icon-button>
                </paper-input>
                <input hidden="true" type="submit">
            </div>
            <div style="flex:0 0 90%;">
                <iframe src="{{ src }}"
                        onload="document.getElementsByTagName('paper-spinner')[0].removeAttribute('active');"></iframe>

            </div>

        </template>

    </dom-module>

    <script>

        Polymer({

            is: 'wrapped-iframe',
            checkforenter: function (e) {
                // check if 'enter' was pressed
                if (e.keyCode === 13) {
                    this.navigate();
                }
            },
            properties: {

                /**
                 * `fancy` indicates that the element should don a monocle and tophat,
                 * while checking its pocket watch.
                 */
                src: {
                    type: String,
                },
                load: {
                    type: String,
                    value: "http://www.example.net"
                },
                baseurl: {
                    type: String,
                    value: function () {
                        return "http://";
                    }
                }

            },

            // Element Lifecycle

            ready: function () {
                this.path = "";
                document.getElementsByTagName("paper-spinner")[0].setAttribute('active', true);
                document.getElementsByTagName("iframe")[0].setAttribute('src', this.load);
                // `ready` is called after all elements have been configured, but
                // propagates bottom-up. This element's children are ready, but parents
                // are not.
                //
                // This is the point where you should make modifications to the DOM (when
                // necessary), or kick off any processes the element wants to perform.
            },

            attached: function () {
                // `attached` fires once the element and its parents have been inserted
                // into a document.
                //
                // This is a good place to perform any work related to your element's
                // visual state or active behavior (measuring sizes, beginning animations,
                // loading resources, etc).
            },

            detached: function () {
                // The analog to `attached`, `detached` fires when the element has been
                // removed from a document.
                //
                // Use this to clean up anything you did in `attached`.
            },

            // Element Behavior

            /**
             * The `seed-element-lasers` event is fired whenever `fireLasers` is called.
             *
             * @event seed-element-lasers
             * @detail {{sound: String}}
             */

            /**
             * Sometimes it's just nice to say hi.
             *
             * @param {string} greeting A positive greeting.
             * @return {string} The full greeting.
             */
            navigate: function () {
                this.url = this.baseurl + this.path;
                console.log(this.baseurl);
                console.log(this.path);
                document.getElementsByTagName("iframe")[0].setAttribute('src', this.url);
                document.getElementsByTagName("paper-spinner")[0].setAttribute('active', true);
            },
            back: function () {
                this.$.preview.contentWindow.history.back();
            },
            forward: function () {
                this.$.preview.contentWindow.history.forward();
            },


            /**
             * Attempts to destroy this element's enemies with an any beam of light!
             *
             * Or, at least, dispatches an event in the vain hope that someone else will
             * do the zapping.
             */
            fireLasers: function () {
                this.fire('seed-element-lasers', {sound: 'Pew pew!'});
            }

        })
        ;

    </script>
    <dom-module id="paper-card" assetpath="../components/paper-card/">
        <template>
            <style include="paper-material">
                :host {
                    display: inline-block;
                    position: relative;
                    box-sizing: border-box;

                    background: #fff;
                    border-radius: 2px;
                    @apply(--paper-card);
                }

                /* IE 10 support for HTML5 hidden attr */
                [hidden] {
                    display: none !important;
                }

                .header {
                    position: relative;
                    border-top-left-radius: inherit;
                    border-top-right-radius: inherit;
                    overflow: hidden;
                    @apply(--paper-card-header);
                }

                .header img {
                    width: 100%;
                    pointer-events: none;
                    @apply(--paper-card-header-image);
                }

                .header .title-text {
                    padding: 16px;
                    font-size: 24px;
                    font-weight: bold;
                    color: var(--paper-card-header-color, #000);
                    @apply(--paper-card-header-text);
                }

                .header .title-text.over-image {
                    position: absolute;
                    bottom: 0px;
                    @apply(--paper-card-header-image-text);
                }

                :host ::content .card-content {
                    padding: 16px;
                    position: relative;
                    @apply(--paper-card-content);
                }

                :host ::content .card-actions {
                    border-top: 1px solid #e8e8e8;
                    padding: 5px 16px;
                    position: relative;
                    @apply(--paper-card-actions);
                }
            </style>

            <div class="header">
                <img hidden$="[[!image]]" src="[[image]]">

                <div hidden$="[[!heading]]" class$="[[_computeHeadingClass(image)]]">[[heading]]</div>
            </div>

            <content></content>
        </template>

    </dom-module>

    <script>

        Polymer({

            is: 'paper-card',

            properties: {

                /**
                 * The title of the card.
                 */
                heading: {
                    type: String,
                    value: '',
                    observer: '_headingChanged'
                },

                /**
                 * The url of the title image of the card.
                 */
                image: {
                    type: String,
                    value: ''
                },

                /**
                 * The z-depth of the card, from 0-5.
                 */
                elevation: {
                    type: Number,
                    value: 1,
                    reflectToAttribute: true
                },

                /**
                 * Set this to true to animate the card shadow when setting a new
                 * `z` value.
                 */
                animatedShadow: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Read-only property used to pass down the `animatedShadow` value to
                 * the underlying paper-material style (since they have different names).
                 */
                animated: {
                    type: Boolean,
                    reflectToAttribute: true,
                    readOnly: true,
                    computed: '_computeAnimated(animatedShadow)'
                }
            },

            _headingChanged: function (heading) {
                var label = this.getAttribute('aria-label');
                this.setAttribute('aria-label', heading);
            },

            _computeHeadingClass: function (image) {
                var cls = 'title-text';
                if (image)
                    cls += ' over-image';
                return cls;
            },

            _computeAnimated: function (animatedShadow) {
                return animatedShadow;
            }
        });
    </script>
    <dom-module id="paper-drawer-panel" assetpath="../components/paper-drawer-panel/">
        <style>
            /**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

            :host {
                display: block;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }

            iron-selector > #drawer {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
                background-color: white;

                -moz-box-sizing: border-box;
                box-sizing: border-box;

                @apply(--paper-drawer-panel-drawer-container);
            }

            .transition > #drawer {
                transition: -webkit-transform ease-in-out 0.3s, width ease-in-out 0.3s, visibility 0.3s;
                transition: transform ease-in-out 0.3s, width ease-in-out 0.3s, visibility 0.3s;
            }

            .left-drawer > #drawer {
                @apply(--paper-drawer-panel-left-drawer-container);
            }

            .right-drawer > #drawer {
                left: auto;
                right: 0;

                @apply(--paper-drawer-panel-right-drawer-container);
            }

            iron-selector > #main {
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;

                @apply(--paper-drawer-panel-main-container);
            }

            .transition > #main {
                transition: left ease-in-out 0.3s, padding ease-in-out 0.3s;
            }

            .right-drawer > #main {
                left: 0;
            }

            .right-drawer.transition > #main {
                transition: right ease-in-out 0.3s, padding ease-in-out 0.3s;
            }

            #main > ::content > [main] {
                height: 100%;
            }

            #drawer > ::content > [drawer] {
                height: 100%;
            }

            #scrim {
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;
                visibility: hidden;
                opacity: 0;
                transition: opacity ease-in-out 0.38s, visibility ease-in-out 0.38s;
                background-color: rgba(0, 0, 0, 0.3);
            }

            .narrow-layout > #drawer {
                will-change: transform;
            }

            .narrow-layout > #drawer.iron-selected {
                box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.15);
            }

            .right-drawer.narrow-layout > #drawer.iron-selected {
                box-shadow: -2px 2px 4px rgba(0, 0, 0, 0.15);
            }

            .narrow-layout > #drawer > ::content > [drawer] {
                border: 0;
            }

            .left-drawer.narrow-layout > #drawer:not(.iron-selected) {
                -webkit-transform: translateX(-100%);
                transform: translateX(-100%);
            }

            .right-drawer.narrow-layout > #drawer:not(.iron-selected) {
                left: auto;
                visibility: hidden;

                -webkit-transform: translateX(100%);
                transform: translateX(100%);
            }

            .right-drawer.narrow-layout.dragging > #drawer:not(.iron-selected),
            .right-drawer.narrow-layout.peeking > #drawer:not(.iron-selected) {
                visibility: visible;
            }

            .narrow-layout > #main {
                padding: 0;
            }

            .right-drawer.narrow-layout > #main {
                left: 0;
                right: 0;
            }

            .narrow-layout > #main:not(.iron-selected) > #scrim,
            .dragging > #main > #scrim {
                visibility: visible;
                opacity: var(--paper-drawer-panel-scrim-opacity, 1);
            }

            .narrow-layout > #main > * {
                margin: 0;
                min-height: 100%;
                left: 0;
                right: 0;

                -moz-box-sizing: border-box;
                box-sizing: border-box;
            }

            iron-selector:not(.narrow-layout) #main ::content [paper-drawer-toggle] {
                display: none;
            }
        </style>

        <template>
            <iron-media-query id="mq" on-query-matches-changed="_onQueryMatchesChanged"
                              query="[[_computeMediaQuery(forceNarrow, responsiveWidth)]]">
            </iron-media-query>

            <iron-selector attr-for-selected="id"
                           class$="[[_computeIronSelectorClass(narrow, transition, dragging, rightDrawer, peeking)]]"
                           activate-event="" selected="[[selected]]">

                <div id="main" style$="[[_computeMainStyle(narrow, rightDrawer, drawerWidth)]]">
                    <content select="[main]"></content>
                    <div id="scrim" on-tap="closeDrawer"></div>
                </div>

                <div id="drawer" style$="[[_computeDrawerStyle(drawerWidth)]]">
                    <content select="[drawer]"></content>
                </div>

            </iron-selector>
        </template>

    </dom-module>

    <script>

        (function () {

            'use strict';

            // this would be the only `paper-drawer-panel` in
            // the whole app that can be in `dragging` state
            var sharedPanel = null;

            function classNames(obj) {
                var classes = [];
                for (var key in obj) {
                    if (obj.hasOwnProperty(key) && obj[key]) {
                        classes.push(key);
                    }
                }

                return classes.join(' ');
            }

            Polymer({

                is: 'paper-drawer-panel',

                /**
                 * Fired when the narrow layout changes.
                 *
                 * @event paper-responsive-change {{narrow: boolean}} detail -
                 *     narrow: true if the panel is in narrow layout.
                 */

                /**
                 * Fired when the a panel is selected.
                 *
                 * Listening for this event is an alternative to observing changes in the `selected` attribute.
                 * This event is fired both when a panel is selected.
                 *
                 * @event iron-select {{item: Object}} detail -
                 *     item: The panel that the event refers to.
                 */

                /**
                 * Fired when a panel is deselected.
                 *
                 * Listening for this event is an alternative to observing changes in the `selected` attribute.
                 * This event is fired both when a panel is deselected.
                 *
                 * @event iron-deselect {{item: Object}} detail -
                 *     item: The panel that the event refers to.
                 */
                properties: {

                    /**
                     * The panel to be selected when `paper-drawer-panel` changes to narrow
                     * layout.
                     */
                    defaultSelected: {
                        type: String,
                        value: 'main'
                    },

                    /**
                     * If true, swipe from the edge is disable.
                     */
                    disableEdgeSwipe: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * If true, swipe to open/close the drawer is disabled.
                     */
                    disableSwipe: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * Whether the user is dragging the drawer interactively.
                     */
                    dragging: {
                        type: Boolean,
                        value: false,
                        readOnly: true,
                        notify: true
                    },

                    /**
                     * Width of the drawer panel.
                     */
                    drawerWidth: {
                        type: String,
                        value: '256px'
                    },

                    /**
                     * How many pixels on the side of the screen are sensitive to edge
                     * swipes and peek.
                     */
                    edgeSwipeSensitivity: {
                        type: Number,
                        value: 30
                    },

                    /**
                     * If true, ignore `responsiveWidth` setting and force the narrow layout.
                     */
                    forceNarrow: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * Whether the browser has support for the transform CSS property.
                     */
                    hasTransform: {
                        type: Boolean,
                        value: function () {
                            return 'transform' in this.style;
                        }
                    },

                    /**
                     * Whether the browser has support for the will-change CSS property.
                     */
                    hasWillChange: {
                        type: Boolean,
                        value: function () {
                            return 'willChange' in this.style;
                        }
                    },

                    /**
                     * Returns true if the panel is in narrow layout.  This is useful if you
                     * need to show/hide elements based on the layout.
                     */
                    narrow: {
                        reflectToAttribute: true,
                        type: Boolean,
                        value: false,
                        readOnly: true,
                        notify: true
                    },

                    /**
                     * Whether the drawer is peeking out from the edge.
                     */
                    peeking: {
                        type: Boolean,
                        value: false,
                        readOnly: true,
                        notify: true
                    },

                    /**
                     * Max-width when the panel changes to narrow layout.
                     */
                    responsiveWidth: {
                        type: String,
                        value: '640px'
                    },

                    /**
                     * If true, position the drawer to the right.
                     */
                    rightDrawer: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * The panel that is being selected. `drawer` for the drawer panel and
                     * `main` for the main panel.
                     */
                    selected: {
                        reflectToAttribute: true,
                        notify: true,
                        type: String,
                        value: null
                    },

                    /**
                     * The attribute on elements that should toggle the drawer on tap, also elements will
                     * automatically be hidden in wide layout.
                     */
                    drawerToggleAttribute: {
                        type: String,
                        value: 'paper-drawer-toggle'
                    },

                    /**
                     * Whether the transition is enabled.
                     */
                    transition: {
                        type: Boolean,
                        value: false
                    },

                },

                listeners: {
                    tap: '_onTap',
                    track: '_onTrack',
                    down: '_downHandler',
                    up: '_upHandler'
                },

                observers: [
                    '_forceNarrowChanged(forceNarrow, defaultSelected)'
                ],

                /**
                 * Toggles the panel open and closed.
                 *
                 * @method togglePanel
                 */
                togglePanel: function () {
                    if (this._isMainSelected()) {
                        this.openDrawer();
                    } else {
                        this.closeDrawer();
                    }
                },

                /**
                 * Opens the drawer.
                 *
                 * @method openDrawer
                 */
                openDrawer: function () {
                    this.selected = 'drawer';
                },

                /**
                 * Closes the drawer.
                 *
                 * @method closeDrawer
                 */
                closeDrawer: function () {
                    this.selected = 'main';
                },

                ready: function () {
                    // Avoid transition at the beginning e.g. page loads and enable
                    // transitions only after the element is rendered and ready.
                    this.transition = true;
                },

                _computeIronSelectorClass: function (narrow, transition, dragging, rightDrawer, peeking) {
                    return classNames({
                        dragging: dragging,
                        'narrow-layout': narrow,
                        'right-drawer': rightDrawer,
                        'left-drawer': !rightDrawer,
                        transition: transition,
                        peeking: peeking
                    });
                },

                _computeDrawerStyle: function (drawerWidth) {
                    return 'width:' + drawerWidth + ';';
                },

                _computeMainStyle: function (narrow, rightDrawer, drawerWidth) {
                    var style = '';

                    style += 'left:' + ((narrow || rightDrawer) ? '0' : drawerWidth) + ';';

                    if (rightDrawer) {
                        style += 'right:' + (narrow ? '' : drawerWidth) + ';';
                    }

                    return style;
                },

                _computeMediaQuery: function (forceNarrow, responsiveWidth) {
                    return forceNarrow ? '' : '(max-width: ' + responsiveWidth + ')';
                },

                _computeSwipeOverlayHidden: function (narrow, disableEdgeSwipe) {
                    return !narrow || disableEdgeSwipe;
                },

                _onTrack: function (event) {
                    if (sharedPanel && this !== sharedPanel) {
                        return;
                    }
                    switch (event.detail.state) {
                        case 'start':
                            this._trackStart(event);
                            break;
                        case 'track':
                            this._trackX(event);
                            break;
                        case 'end':
                            this._trackEnd(event);
                            break;
                    }

                },

                _responsiveChange: function (narrow) {
                    this._setNarrow(narrow);

                    if (this.narrow) {
                        this.selected = this.defaultSelected;
                    }

                    this.setScrollDirection(this._swipeAllowed() ? 'y' : 'all');
                    this.fire('paper-responsive-change', {narrow: this.narrow});
                },

                _onQueryMatchesChanged: function (event) {
                    this._responsiveChange(event.detail.value);
                },

                _forceNarrowChanged: function () {
                    // set the narrow mode only if we reached the `responsiveWidth`
                    this._responsiveChange(this.forceNarrow || this.$.mq.queryMatches);
                },

                _swipeAllowed: function () {
                    return this.narrow && !this.disableSwipe;
                },

                _isMainSelected: function () {
                    return this.selected === 'main';
                },

                _startEdgePeek: function () {
                    this.width = this.$.drawer.offsetWidth;
                    this._moveDrawer(this._translateXForDeltaX(this.rightDrawer ?
                            -this.edgeSwipeSensitivity : this.edgeSwipeSensitivity));
                    this._setPeeking(true);
                },

                _stopEdgePeek: function () {
                    if (this.peeking) {
                        this._setPeeking(false);
                        this._moveDrawer(null);
                    }
                },

                _downHandler: function (event) {
                    if (!this.dragging && this._isMainSelected() && this._isEdgeTouch(event) && !sharedPanel) {
                        this._startEdgePeek();
                        // cancel selection
                        event.preventDefault();
                        // grab this panel
                        sharedPanel = this;
                    }
                },

                _upHandler: function () {
                    this._stopEdgePeek();
                    // release the panel
                    sharedPanel = null;
                },

                _onTap: function (event) {
                    var targetElement = Polymer.dom(event).localTarget;
                    var isTargetToggleElement = targetElement &&
                            this.drawerToggleAttribute &&
                            targetElement.hasAttribute(this.drawerToggleAttribute);

                    if (isTargetToggleElement) {
                        this.togglePanel();
                    }
                },

                _isEdgeTouch: function (event) {
                    var x = event.detail.x;

                    return !this.disableEdgeSwipe && this._swipeAllowed() &&
                            (this.rightDrawer ?
                            x >= this.offsetWidth - this.edgeSwipeSensitivity :
                            x <= this.edgeSwipeSensitivity);
                },

                _trackStart: function (event) {
                    if (this._swipeAllowed()) {
                        sharedPanel = this;
                        this._setDragging(true);

                        if (this._isMainSelected()) {
                            this._setDragging(this.peeking || this._isEdgeTouch(event));
                        }

                        if (this.dragging) {
                            this.width = this.$.drawer.offsetWidth;
                            this.transition = false;
                        }
                    }
                },

                _translateXForDeltaX: function (deltaX) {
                    var isMain = this._isMainSelected();

                    if (this.rightDrawer) {
                        return Math.max(0, isMain ? this.width + deltaX : deltaX);
                    } else {
                        return Math.min(0, isMain ? deltaX - this.width : deltaX);
                    }
                },

                _trackX: function (event) {
                    if (this.dragging) {
                        var dx = event.detail.dx;

                        if (this.peeking) {
                            if (Math.abs(dx) <= this.edgeSwipeSensitivity) {
                                // Ignore trackx until we move past the edge peek.
                                return;
                            }
                            this._setPeeking(false);
                        }

                        this._moveDrawer(this._translateXForDeltaX(dx));
                    }
                },

                _trackEnd: function (event) {
                    if (this.dragging) {
                        var xDirection = event.detail.dx > 0;

                        this._setDragging(false);
                        this.transition = true;
                        sharedPanel = null;
                        this._moveDrawer(null);

                        if (this.rightDrawer) {
                            this[xDirection ? 'closeDrawer' : 'openDrawer']();
                        } else {
                            this[xDirection ? 'openDrawer' : 'closeDrawer']();
                        }
                    }
                },

                _transformForTranslateX: function (translateX) {
                    if (translateX === null) {
                        return '';
                    }

                    return this.hasWillChange ? 'translateX(' + translateX + 'px)' :
                    'translate3d(' + translateX + 'px, 0, 0)';
                },

                _moveDrawer: function (translateX) {
                    this.transform(this._transformForTranslateX(translateX), this.$.drawer);
                }

            });

        }());

    </script>
</div>
</body>
</html>